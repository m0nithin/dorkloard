"use strict";
(self.webpackChunkdorkl = self.webpackChunkdorkl || []).push([
    [8729], {
        5054: (Mi, je, Nt) => {
            var _t;

            function pe(_, t) {
                var e = Object.keys(_);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(_);
                    t && (i = i.filter(function(r) {
                        return Object.getOwnPropertyDescriptor(_, r).enumerable
                    })), e.push.apply(e, i)
                }
                return e
            }

            function ut(_) {
                for (var t = 1; t < arguments.length; t++) {
                    var e = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? pe(Object(e), !0).forEach(function(i) {
                        Et(_, i, e[i])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(e)) : pe(Object(e)).forEach(function(i) {
                        Object.defineProperty(_, i, Object.getOwnPropertyDescriptor(e, i))
                    })
                }
                return _
            }

            function Zt(_) {
                return (Zt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(_)
            }

            function xt(_, t) {
                if (!(_ instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function be(_, t) {
                for (var e = 0; e < t.length; e++) {
                    var i = t[e];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(_, i.key, i)
                }
            }

            function ht(_, t, e) {
                return t && be(_.prototype, t), e && be(_, e), _
            }

            function Et(_, t, e) {
                return t in _ ? Object.defineProperty(_, t, {
                    value: e,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : _[t] = e, _
            }

            function Rt(_, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                _.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: _,
                        writable: !0,
                        configurable: !0
                    }
                }), t && Ft(_, t)
            }

            function bt(_) {
                return (bt = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(_)
            }

            function Ft(_, t) {
                return (Ft = Object.setPrototypeOf || function(e, i) {
                    return e.__proto__ = i, e
                })(_, t)
            }

            function Me(_) {
                var t = function() {
                    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                    } catch {
                        return !1
                    }
                }();
                return function() {
                    var e, i = bt(_);
                    if (t) {
                        var r = bt(this).constructor;
                        e = Reflect.construct(i, arguments, r)
                    } else e = i.apply(this, arguments);
                    return function ue(_, t) {
                        if (t && ("object" == typeof t || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(_)
                    }(this, e)
                }
            }

            function ze(_, t) {
                return function(e) {
                    if (Array.isArray(e)) return e
                }(_) || function(e, i) {
                    var r = null == e ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
                    if (null != r) {
                        var l, h, d = [],
                            g = !0,
                            x = !1;
                        try {
                            for (r = r.call(e); !(g = (l = r.next()).done) && (d.push(l.value), !i || d.length !== i); g = !0);
                        } catch (b) {
                            x = !0, h = b
                        } finally {
                            try {
                                g || null == r.return || r.return()
                            } finally {
                                if (x) throw h
                            }
                        }
                        return d
                    }
                }(_, t) || ei(_, t) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function le(_) {
                return function(t) {
                    if (Array.isArray(t)) return Pi(t)
                }(_) || function(t) {
                    if (typeof Symbol < "u" && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(_) || ei(_) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function ei(_, t) {
                if (_) {
                    if ("string" == typeof _) return Pi(_, t);
                    var e = Object.prototype.toString.call(_).slice(8, -1);
                    return "Object" === e && _.constructor && (e = _.constructor.name), "Map" === e || "Set" === e ? Array.from(_) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Pi(_, t) : void 0
                }
            }

            function Pi(_, t) {
                (null == t || t > _.length) && (t = _.length);
                for (var e = 0, i = new Array(t); e < t; e++) i[e] = _[e];
                return i
            }
            var q = function() {
                    function _() {
                        xt(this, _)
                    }
                    return ht(_, [{
                        key: "shadeRGBColor",
                        value: function(t, e) {
                            var i = e.split(","),
                                r = t < 0 ? 0 : 255,
                                l = t < 0 ? -1 * t : t,
                                h = parseInt(i[0].slice(4), 10),
                                d = parseInt(i[1], 10),
                                g = parseInt(i[2], 10);
                            return "rgb(" + (Math.round((r - h) * l) + h) + "," + (Math.round((r - d) * l) + d) + "," + (Math.round((r - g) * l) + g) + ")"
                        }
                    }, {
                        key: "shadeHexColor",
                        value: function(t, e) {
                            var i = parseInt(e.slice(1), 16),
                                r = t < 0 ? 0 : 255,
                                l = t < 0 ? -1 * t : t,
                                h = i >> 16,
                                d = i >> 8 & 255,
                                g = 255 & i;
                            return "#" + (16777216 + 65536 * (Math.round((r - h) * l) + h) + 256 * (Math.round((r - d) * l) + d) + (Math.round((r - g) * l) + g)).toString(16).slice(1)
                        }
                    }, {
                        key: "shadeColor",
                        value: function(t, e) {
                            return _.isColorHex(e) ? this.shadeHexColor(t, e) : this.shadeRGBColor(t, e)
                        }
                    }], [{
                        key: "bind",
                        value: function(t, e) {
                            return function() {
                                return t.apply(e, arguments)
                            }
                        }
                    }, {
                        key: "isObject",
                        value: function(t) {
                            return t && "object" === Zt(t) && !Array.isArray(t) && null != t
                        }
                    }, {
                        key: "is",
                        value: function(t, e) {
                            return Object.prototype.toString.call(e) === "[object " + t + "]"
                        }
                    }, {
                        key: "listToArray",
                        value: function(t) {
                            var e, i = [];
                            for (e = 0; e < t.length; e++) i[e] = t[e];
                            return i
                        }
                    }, {
                        key: "extend",
                        value: function(t, e) {
                            var i = this;
                            "function" != typeof Object.assign && (Object.assign = function(l) {
                                if (null == l) throw new TypeError("Cannot convert undefined or null to object");
                                for (var h = Object(l), d = 1; d < arguments.length; d++) {
                                    var g = arguments[d];
                                    if (null != g)
                                        for (var x in g) g.hasOwnProperty(x) && (h[x] = g[x])
                                }
                                return h
                            });
                            var r = Object.assign({}, t);
                            return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(function(l) {
                                i.isObject(e[l]) && l in t ? r[l] = i.extend(t[l], e[l]) : Object.assign(r, Et({}, l, e[l]))
                            }), r
                        }
                    }, {
                        key: "extendArray",
                        value: function(t, e) {
                            var i = [];
                            return t.map(function(r) {
                                i.push(_.extend(e, r))
                            }), i
                        }
                    }, {
                        key: "monthMod",
                        value: function(t) {
                            return t % 12
                        }
                    }, {
                        key: "clone",
                        value: function(t) {
                            if (_.is("Array", t)) {
                                for (var e = [], i = 0; i < t.length; i++) e[i] = this.clone(t[i]);
                                return e
                            }
                            if (_.is("Null", t)) return null;
                            if (_.is("Date", t)) return t;
                            if ("object" === Zt(t)) {
                                var r = {};
                                for (var l in t) t.hasOwnProperty(l) && (r[l] = this.clone(t[l]));
                                return r
                            }
                            return t
                        }
                    }, {
                        key: "log10",
                        value: function(t) {
                            return Math.log(t) / Math.LN10
                        }
                    }, {
                        key: "roundToBase10",
                        value: function(t) {
                            return Math.pow(10, Math.floor(Math.log10(t)))
                        }
                    }, {
                        key: "roundToBase",
                        value: function(t, e) {
                            return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)))
                        }
                    }, {
                        key: "parseNumber",
                        value: function(t) {
                            return null === t ? t : parseFloat(t)
                        }
                    }, {
                        key: "stripNumber",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                            return Number.isInteger(t) ? t : parseFloat(t.toPrecision(e))
                        }
                    }, {
                        key: "randomId",
                        value: function() {
                            return (Math.random() + 1).toString(36).substring(4)
                        }
                    }, {
                        key: "noExponents",
                        value: function(t) {
                            var e = String(t).split(/[eE]/);
                            if (1 === e.length) return e[0];
                            var i = "",
                                r = t < 0 ? "-" : "",
                                l = e[0].replace(".", ""),
                                h = Number(e[1]) + 1;
                            if (h < 0) {
                                for (i = r + "0."; h++;) i += "0";
                                return i + l.replace(/^-/, "")
                            }
                            for (h -= l.length; h--;) i += "0";
                            return l + i
                        }
                    }, {
                        key: "getDimensions",
                        value: function(t) {
                            var e = getComputedStyle(t, null),
                                i = t.clientHeight,
                                r = t.clientWidth;
                            return i -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), [r -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i]
                        }
                    }, {
                        key: "getBoundingClientRect",
                        value: function(t) {
                            var e = t.getBoundingClientRect();
                            return {
                                top: e.top,
                                right: e.right,
                                bottom: e.bottom,
                                left: e.left,
                                width: t.clientWidth,
                                height: t.clientHeight,
                                x: e.left,
                                y: e.top
                            }
                        }
                    }, {
                        key: "getLargestStringFromArr",
                        value: function(t) {
                            return t.reduce(function(e, i) {
                                return Array.isArray(i) && (i = i.reduce(function(r, l) {
                                    return r.length > l.length ? r : l
                                })), e.length > i.length ? e : i
                            }, 0)
                        }
                    }, {
                        key: "hexToRgba",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                            "#" !== t.substring(0, 1) && (t = "#999999");
                            var i = t.replace("#", "");
                            i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
                            for (var r = 0; r < i.length; r++) i[r] = parseInt(1 === i[r].length ? i[r] + i[r] : i[r], 16);
                            return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")"
                        }
                    }, {
                        key: "getOpacityFromRGBA",
                        value: function(t) {
                            return parseFloat(t.replace(/^.*,(.+)\)/, "$1"))
                        }
                    }, {
                        key: "rgb2hex",
                        value: function(t) {
                            return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : ""
                        }
                    }, {
                        key: "isColorHex",
                        value: function(t) {
                            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)
                        }
                    }, {
                        key: "getPolygonPos",
                        value: function(t, e) {
                            for (var i = [], r = 2 * Math.PI / e, l = 0; l < e; l++) {
                                var h = {};
                                h.x = t * Math.sin(l * r), h.y = -t * Math.cos(l * r), i.push(h)
                            }
                            return i
                        }
                    }, {
                        key: "polarToCartesian",
                        value: function(t, e, i, r) {
                            var l = (r - 90) * Math.PI / 180;
                            return {
                                x: t + i * Math.cos(l),
                                y: e + i * Math.sin(l)
                            }
                        }
                    }, {
                        key: "escapeString",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x";
                            return t.toString().slice().replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e)
                        }
                    }, {
                        key: "negToZero",
                        value: function(t) {
                            return t < 0 ? 0 : t
                        }
                    }, {
                        key: "moveIndexInArray",
                        value: function(t, e, i) {
                            if (i >= t.length)
                                for (var r = i - t.length + 1; r--;) t.push(void 0);
                            return t.splice(i, 0, t.splice(e, 1)[0]), t
                        }
                    }, {
                        key: "extractNumber",
                        value: function(t) {
                            return parseFloat(t.replace(/[^\d.]*/g, ""))
                        }
                    }, {
                        key: "findAncestor",
                        value: function(t, e) {
                            for (;
                                (t = t.parentElement) && !t.classList.contains(e););
                            return t
                        }
                    }, {
                        key: "setELstyles",
                        value: function(t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t.style.key = e[i])
                        }
                    }, {
                        key: "isNumber",
                        value: function(t) {
                            return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10))
                        }
                    }, {
                        key: "isFloat",
                        value: function(t) {
                            return Number(t) === t && t % 1 != 0
                        }
                    }, {
                        key: "isSafari",
                        value: function() {
                            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
                        }
                    }, {
                        key: "isFirefox",
                        value: function() {
                            return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
                        }
                    }, {
                        key: "isIE11",
                        value: function() {
                            if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0
                        }
                    }, {
                        key: "isIE",
                        value: function() {
                            var t = window.navigator.userAgent,
                                e = t.indexOf("MSIE ");
                            if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
                            if (t.indexOf("Trident/") > 0) {
                                var i = t.indexOf("rv:");
                                return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10)
                            }
                            var r = t.indexOf("Edge/");
                            return r > 0 && parseInt(t.substring(r + 5, t.indexOf(".", r)), 10)
                        }
                    }]), _
                }(),
                Bt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.setEasingFunctions()
                    }
                    return ht(_, [{
                        key: "setEasingFunctions",
                        value: function() {
                            var t;
                            if (!this.w.globals.easing) {
                                switch (this.w.config.chart.animations.easing) {
                                    case "linear":
                                        t = "-";
                                        break;
                                    case "easein":
                                        t = "<";
                                        break;
                                    case "easeout":
                                        t = ">";
                                        break;
                                    case "easeinout":
                                    default:
                                        t = "<>";
                                        break;
                                    case "swing":
                                        t = function(e) {
                                            var i = 1.70158;
                                            return (e -= 1) * e * ((i + 1) * e + i) + 1
                                        };
                                        break;
                                    case "bounce":
                                        t = function(e) {
                                            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                                        };
                                        break;
                                    case "elastic":
                                        t = function(e) {
                                            return e === !!e ? e : Math.pow(2, -10 * e) * Math.sin((e - .075) * (2 * Math.PI) / .3) + 1
                                        }
                                }
                                this.w.globals.easing = t
                            }
                        }
                    }, {
                        key: "animateLine",
                        value: function(t, e, i, r) {
                            t.attr(e).animate(r).attr(i)
                        }
                    }, {
                        key: "animateMarker",
                        value: function(t, e, i, r, l, h) {
                            e || (e = 0), t.attr({
                                r: e,
                                width: e,
                                height: e
                            }).animate(r, l).attr({
                                r: i,
                                width: i.width,
                                height: i.height
                            }).afterAll(function() {
                                h()
                            })
                        }
                    }, {
                        key: "animateCircle",
                        value: function(t, e, i, r, l) {
                            t.attr({
                                r: e.r,
                                cx: e.cx,
                                cy: e.cy
                            }).animate(r, l).attr({
                                r: i.r,
                                cx: i.cx,
                                cy: i.cy
                            })
                        }
                    }, {
                        key: "animateRect",
                        value: function(t, e, i, r, l) {
                            t.attr(e).animate(r).attr(i).afterAll(function() {
                                return l()
                            })
                        }
                    }, {
                        key: "animatePathsGradually",
                        value: function(t) {
                            var b = this.w,
                                v = 0;
                            b.config.chart.animations.animateGradually.enabled && (v = b.config.chart.animations.animateGradually.delay), b.config.chart.animations.dynamicAnimation.enabled && b.globals.dataChanged && "bar" !== b.config.chart.type && (v = 0), this.morphSVG(t.el, t.realIndex, t.j, "line" !== b.config.chart.type || b.globals.comboCharts ? t.fill : "stroke", t.pathFrom, t.pathTo, t.speed, t.delay * v)
                        }
                    }, {
                        key: "showDelayedElements",
                        value: function() {
                            this.w.globals.delayedElements.forEach(function(t) {
                                var e = t.el;
                                e.classList.remove("apexcharts-element-hidden"), e.classList.add("apexcharts-hidden-element-shown")
                            })
                        }
                    }, {
                        key: "animationCompleted",
                        value: function(t) {
                            var e = this.w;
                            e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
                                el: t,
                                w: e
                            }))
                        }
                    }, {
                        key: "morphSVG",
                        value: function(t, e, i, r, l, h, d, g) {
                            var x = this,
                                b = this.w;
                            l || (l = t.attr("pathFrom")), h || (h = t.attr("pathTo"));
                            var v = function(w) {
                                return "radar" === b.config.chart.type && (d = 1), "M 0 ".concat(b.globals.gridHeight)
                            };
                            (!l || l.indexOf("undefined") > -1 || l.indexOf("NaN") > -1) && (l = v()), (!h || h.indexOf("undefined") > -1 || h.indexOf("NaN") > -1) && (h = v()), b.globals.shouldAnimate || (d = 1), t.plot(l).animate(1, b.globals.easing, g).plot(l).animate(d, b.globals.easing, g).plot(h).afterAll(function() {
                                q.isNumber(i) ? i === b.globals.series[b.globals.maxValsInArrayIndex].length - 2 && b.globals.shouldAnimate && x.animationCompleted(t) : "none" !== r && b.globals.shouldAnimate && (!b.globals.comboCharts && e === b.globals.series.length - 1 || b.globals.comboCharts) && x.animationCompleted(t), x.showDelayedElements()
                            })
                        }
                    }]), _
                }(),
                ae = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "getDefaultFilter",
                        value: function(t, e) {
                            var i = this.w;
                            t.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e)
                        }
                    }, {
                        key: "addNormalFilter",
                        value: function(t, e) {
                            var i = this.w;
                            i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, e)
                        }
                    }, {
                        key: "addLightenFilter",
                        value: function(t, e, i) {
                            var r = this,
                                l = this.w,
                                h = i.intensity;
                            t.unfilter(!0), new window.SVG.Filter, t.filter(function(d) {
                                var g = l.config.chart.dropShadow;
                                (g.enabled ? r.addShadow(d, e, g) : d).componentTransfer({
                                    rgb: {
                                        type: "linear",
                                        slope: 1.5,
                                        intercept: h
                                    }
                                })
                            }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                        }
                    }, {
                        key: "addDarkenFilter",
                        value: function(t, e, i) {
                            var r = this,
                                l = this.w,
                                h = i.intensity;
                            t.unfilter(!0), new window.SVG.Filter, t.filter(function(d) {
                                var g = l.config.chart.dropShadow;
                                (g.enabled ? r.addShadow(d, e, g) : d).componentTransfer({
                                    rgb: {
                                        type: "linear",
                                        slope: h
                                    }
                                })
                            }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                        }
                    }, {
                        key: "applyFilter",
                        value: function(t, e, i) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                            switch (i) {
                                case "none":
                                    this.addNormalFilter(t, e);
                                    break;
                                case "lighten":
                                    this.addLightenFilter(t, e, {
                                        intensity: r
                                    });
                                    break;
                                case "darken":
                                    this.addDarkenFilter(t, e, {
                                        intensity: r
                                    })
                            }
                        }
                    }, {
                        key: "addShadow",
                        value: function(t, e, i) {
                            var r = i.blur,
                                l = i.top,
                                h = i.left,
                                d = i.color,
                                g = i.opacity,
                                x = t.flood(Array.isArray(d) ? d[e] : d, g).composite(t.sourceAlpha, "in").offset(h, l).gaussianBlur(r).merge(t.source);
                            return t.blend(t.source, x)
                        }
                    }, {
                        key: "dropShadow",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                r = e.top,
                                l = e.left,
                                h = e.blur,
                                d = e.color,
                                g = e.opacity,
                                x = e.noUserSpaceOnUse,
                                b = this.w;
                            return t.unfilter(!0), q.isIE() && "radialBar" === b.config.chart.type || (d = Array.isArray(d) ? d[i] : d, t.filter(function(v) {
                                var w;
                                w = q.isSafari() || q.isFirefox() || q.isIE() ? v.flood(d, g).composite(v.sourceAlpha, "in").offset(l, r).gaussianBlur(h) : v.flood(d, g).composite(v.sourceAlpha, "in").offset(l, r).gaussianBlur(h).merge(v.source), v.blend(v.source, w)
                            }), x || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t
                        }
                    }, {
                        key: "setSelectionFilter",
                        value: function(t, e, i) {
                            var r = this.w;
                            if (void 0 !== r.globals.selectedDataPoints[e] && r.globals.selectedDataPoints[e].indexOf(i) > -1) {
                                t.node.setAttribute("selected", !0);
                                var l = r.config.states.active.filter;
                                "none" !== l && this.applyFilter(t, e, l.type, l.value)
                            }
                        }
                    }, {
                        key: "_scaleFilterSize",
                        value: function(t) {
                            ! function(e) {
                                for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                            }({
                                width: "200%",
                                height: "200%",
                                x: "-50%",
                                y: "-50%"
                            })
                        }
                    }]), _
                }(),
                ot = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "roundPathCorners",
                        value: function(t, e) {
                            function i(H, j, U) {
                                var Q = j.x - H.x,
                                    at = j.y - H.y,
                                    it = Math.sqrt(Q * Q + at * at);
                                return r(H, j, Math.min(1, U / it))
                            }

                            function r(H, j, U) {
                                return {
                                    x: H.x + (j.x - H.x) * U,
                                    y: H.y + (j.y - H.y) * U
                                }
                            }

                            function l(H, j) {
                                H.length > 2 && (H[H.length - 2] = j.x, H[H.length - 1] = j.y)
                            }

                            function h(H) {
                                return {
                                    x: parseFloat(H[H.length - 2]),
                                    y: parseFloat(H[H.length - 1])
                                }
                            }
                            t.indexOf("NaN") > -1 && (t = "");
                            var d = t.split(/[,\s]/).reduce(function(H, j) {
                                    var U = j.match("([a-zA-Z])(.+)");
                                    return U ? (H.push(U[1]), H.push(U[2])) : H.push(j), H
                                }, []).reduce(function(H, j) {
                                    return parseFloat(j) == j && H.length ? H[H.length - 1].push(j) : H.push([j]), H
                                }, []),
                                g = [];
                            if (d.length > 1) {
                                var x = h(d[0]),
                                    b = null;
                                "Z" == d[d.length - 1][0] && d[0].length > 2 && (d[d.length - 1] = b = ["L", x.x, x.y]), g.push(d[0]);
                                for (var v = 1; v < d.length; v++) {
                                    var w = g[g.length - 1],
                                        S = d[v],
                                        C = S == b ? d[1] : d[v + 1];
                                    if (C && w && w.length > 2 && "L" == S[0] && C.length > 2 && "L" == C[0]) {
                                        var P, T, I = h(w),
                                            R = h(S),
                                            p = h(C);
                                        P = i(R, I, e), T = i(R, p, e), l(S, P), S.origPoint = R, g.push(S);
                                        var k = r(P, R, .5),
                                            M = r(R, T, .5),
                                            D = ["C", k.x, k.y, M.x, M.y, T.x, T.y];
                                        D.origPoint = R, g.push(D)
                                    } else g.push(S)
                                }
                                if (b) {
                                    var X = h(g[g.length - 1]);
                                    g.push(["Z"]), l(g[0], X)
                                }
                            } else g = d;
                            return g.reduce(function(H, j) {
                                return H + j.join(" ") + " "
                            }, "")
                        }
                    }, {
                        key: "drawLine",
                        value: function(t, e, i, r) {
                            var l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                                h = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                                d = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                g = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
                            return this.w.globals.dom.Paper.line().attr({
                                x1: t,
                                y1: e,
                                x2: i,
                                y2: r,
                                stroke: l,
                                "stroke-dasharray": h,
                                "stroke-width": d,
                                "stroke-linecap": g
                            })
                        }
                    }, {
                        key: "drawRect",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                                h = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                                d = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                                g = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                x = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                                b = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
                                v = this.w.globals.dom.Paper.rect();
                            return v.attr({
                                x: t,
                                y: e,
                                width: i > 0 ? i : 0,
                                height: r > 0 ? r : 0,
                                rx: l,
                                ry: l,
                                opacity: d,
                                "stroke-width": null !== g ? g : 0,
                                stroke: null !== x ? x : "none",
                                "stroke-dasharray": b
                            }), v.node.setAttribute("fill", h), v
                        }
                    }, {
                        key: "drawPolygon",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
                            return this.w.globals.dom.Paper.polygon(t).attr({
                                fill: r,
                                stroke: e,
                                "stroke-width": i
                            })
                        }
                    }, {
                        key: "drawCircle",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            t < 0 && (t = 0);
                            var i = this.w.globals.dom.Paper.circle(2 * t);
                            return null !== e && i.attr(e), i
                        }
                    }, {
                        key: "drawPath",
                        value: function(t) {
                            var e = t.d,
                                i = void 0 === e ? "" : e,
                                r = t.stroke,
                                l = void 0 === r ? "#a8a8a8" : r,
                                h = t.strokeWidth,
                                d = void 0 === h ? 1 : h,
                                g = t.fill,
                                x = t.fillOpacity,
                                b = void 0 === x ? 1 : x,
                                v = t.strokeOpacity,
                                w = void 0 === v ? 1 : v,
                                S = t.classes,
                                C = t.strokeLinecap,
                                P = void 0 === C ? null : C,
                                T = t.strokeDashArray,
                                I = void 0 === T ? 0 : T,
                                R = this.w;
                            return null === P && (P = R.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(R.globals.gridHeight)), R.globals.dom.Paper.path(i).attr({
                                fill: g,
                                "fill-opacity": b,
                                stroke: l,
                                "stroke-opacity": w,
                                "stroke-linecap": P,
                                "stroke-width": d,
                                "stroke-dasharray": I,
                                class: S
                            })
                        }
                    }, {
                        key: "group",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                e = this.w.globals.dom.Paper.group();
                            return null !== t && e.attr(t), e
                        }
                    }, {
                        key: "move",
                        value: function(t, e) {
                            return ["M", t, e].join(" ")
                        }
                    }, {
                        key: "line",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                r = null;
                            return null === i ? r = [" L", t, e].join(" ") : "H" === i ? r = [" H", t].join(" ") : "V" === i && (r = [" V", e].join(" ")), r
                        }
                    }, {
                        key: "curve",
                        value: function(t, e, i, r, l, h) {
                            return ["C", t, e, i, r, l, h].join(" ")
                        }
                    }, {
                        key: "quadraticCurve",
                        value: function(t, e, i, r) {
                            return ["Q", t, e, i, r].join(" ")
                        }
                    }, {
                        key: "arc",
                        value: function(t, e, i, r, l, h, d) {
                            var g = "A";
                            return arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (g = "a"), [g, t, e, i, r, l, h, d].join(" ")
                        }
                    }, {
                        key: "renderPaths",
                        value: function(t) {
                            var e, i = t.j,
                                r = t.realIndex,
                                l = t.pathFrom,
                                h = t.pathTo,
                                d = t.stroke,
                                g = t.strokeWidth,
                                x = t.strokeLinecap,
                                b = t.fill,
                                v = t.animationDelay,
                                w = t.initialSpeed,
                                S = t.dataChangeSpeed,
                                C = t.className,
                                P = t.shouldClipToGrid,
                                T = void 0 === P || P,
                                I = t.bindEventsOnPaths,
                                R = void 0 === I || I,
                                p = t.drawShadow,
                                k = void 0 === p || p,
                                M = this.w,
                                D = new ae(this.ctx),
                                X = new Bt(this.ctx),
                                H = this.w.config.chart.animations.enabled,
                                j = H && this.w.config.chart.animations.dynamicAnimation.enabled,
                                U = !!(H && !M.globals.resized || j && M.globals.dataChanged && M.globals.shouldAnimate);
                            U ? e = l : (e = h, M.globals.animationEnded = !0);
                            var at, Q = M.config.stroke.dashArray;
                            at = Array.isArray(Q) ? Q[r] : M.config.stroke.dashArray;
                            var it = this.drawPath({
                                d: e,
                                stroke: d,
                                strokeWidth: g,
                                fill: b,
                                fillOpacity: 1,
                                classes: C,
                                strokeLinecap: x,
                                strokeDashArray: at
                            });
                            it.attr("index", r), T && it.attr({
                                "clip-path": "url(#gridRectMask".concat(M.globals.cuid, ")")
                            }), "none" !== M.config.states.normal.filter.type ? D.getDefaultFilter(it, r) : M.config.chart.dropShadow.enabled && k && (!M.config.chart.dropShadow.enabledOnSeries || M.config.chart.dropShadow.enabledOnSeries && -1 !== M.config.chart.dropShadow.enabledOnSeries.indexOf(r)) && D.dropShadow(it, M.config.chart.dropShadow, r), R && (it.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, it)), it.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, it)), it.node.addEventListener("mousedown", this.pathMouseDown.bind(this, it))), it.attr({
                                pathTo: h,
                                pathFrom: l
                            });
                            var yt = {
                                el: it,
                                j: i,
                                realIndex: r,
                                pathFrom: l,
                                pathTo: h,
                                fill: b,
                                strokeWidth: g,
                                delay: v
                            };
                            return !H || M.globals.resized || M.globals.dataChanged ? !M.globals.resized && M.globals.dataChanged || X.showDelayedElements() : X.animatePathsGradually(ut(ut({}, yt), {}, {
                                speed: w
                            })), M.globals.dataChanged && j && U && X.animatePathsGradually(ut(ut({}, yt), {}, {
                                speed: S
                            })), it
                        }
                    }, {
                        key: "drawPattern",
                        value: function(t, e, i) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                                l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                            return this.w.globals.dom.Paper.pattern(e, i, function(h) {
                                "horizontalLines" === t ? h.line(0, 0, i, 0).stroke({
                                    color: r,
                                    width: l + 1
                                }) : "verticalLines" === t ? h.line(0, 0, 0, e).stroke({
                                    color: r,
                                    width: l + 1
                                }) : "slantedLines" === t ? h.line(0, 0, e, i).stroke({
                                    color: r,
                                    width: l
                                }) : "squares" === t ? h.rect(e, i).fill("none").stroke({
                                    color: r,
                                    width: l
                                }) : "circles" === t && h.circle(e).fill("none").stroke({
                                    color: r,
                                    width: l
                                })
                            })
                        }
                    }, {
                        key: "drawGradient",
                        value: function(t, e, i, r, l) {
                            var h, d = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                g = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                x = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                b = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                                v = this.w;
                            e.length < 9 && 0 === e.indexOf("#") && (e = q.hexToRgba(e, r)), i.length < 9 && 0 === i.indexOf("#") && (i = q.hexToRgba(i, l));
                            var w = 0,
                                S = 1,
                                C = 1,
                                P = null;
                            null !== g && (w = void 0 !== g[0] ? g[0] / 100 : 0, S = void 0 !== g[1] ? g[1] / 100 : 1, C = void 0 !== g[2] ? g[2] / 100 : 1, P = void 0 !== g[3] ? g[3] / 100 : null);
                            var T = !("donut" !== v.config.chart.type && "pie" !== v.config.chart.type && "polarArea" !== v.config.chart.type && "bubble" !== v.config.chart.type);
                            return h = v.globals.dom.Paper.gradient(T ? "radial" : "linear", null === x || 0 === x.length ? function(p) {
                                p.at(w, e, r), p.at(S, i, l), p.at(C, i, l), null !== P && p.at(P, e, r)
                            } : function(p) {
                                (Array.isArray(x[b]) ? x[b] : x).forEach(function(k) {
                                    p.at(k.offset / 100, k.color, k.opacity)
                                })
                            }), T ? h.attr("bubble" !== v.config.chart.type ? {
                                gradientUnits: "userSpaceOnUse",
                                cx: v.globals.gridWidth / 2,
                                cy: v.globals.gridHeight / 2,
                                r: d
                            } : {
                                cx: .5,
                                cy: .5,
                                r: .8,
                                fx: .2,
                                fy: .2
                            }) : "vertical" === t ? h.from(0, 0).to(0, 1) : "diagonal" === t ? h.from(0, 0).to(1, 1) : "horizontal" === t ? h.from(0, 1).to(1, 1) : "diagonal2" === t && h.from(1, 0).to(0, 1), h
                        }
                    }, {
                        key: "getTextBasedOnMaxWidth",
                        value: function(t) {
                            var e = t.text,
                                i = t.maxWidth,
                                h = this.getTextRects(e, t.fontSize, t.fontFamily),
                                g = Math.floor(i / (h.width / e.length));
                            return i < h.width ? e.slice(0, g - 3) + "..." : e
                        }
                    }, {
                        key: "drawText",
                        value: function(t) {
                            var e = this,
                                i = t.x,
                                r = t.y,
                                l = t.text,
                                h = t.textAnchor,
                                d = t.fontSize,
                                g = t.fontFamily,
                                x = t.fontWeight,
                                b = t.foreColor,
                                v = t.opacity,
                                w = t.maxWidth,
                                S = t.cssClass,
                                C = void 0 === S ? "" : S,
                                P = t.isPlainText,
                                T = void 0 === P || P,
                                I = this.w;
                            void 0 === l && (l = "");
                            var R = l;
                            h || (h = "start"), b && b.length || (b = I.config.chart.foreColor), x = x || "regular";
                            var p, k = {
                                maxWidth: w,
                                fontSize: d = d || "11px",
                                fontFamily: g = g || I.config.chart.fontFamily
                            };
                            return Array.isArray(l) ? p = I.globals.dom.Paper.text(function(M) {
                                for (var D = 0; D < l.length; D++) R = l[D], w && (R = e.getTextBasedOnMaxWidth(ut({
                                    text: l[D]
                                }, k))), 0 === D ? M.tspan(R) : M.tspan(R).newLine()
                            }) : (w && (R = this.getTextBasedOnMaxWidth(ut({
                                text: l
                            }, k))), p = T ? I.globals.dom.Paper.plain(l) : I.globals.dom.Paper.text(function(M) {
                                return M.tspan(R)
                            })), p.attr({
                                x: i,
                                y: r,
                                "text-anchor": h,
                                "dominant-baseline": "auto",
                                "font-size": d,
                                "font-family": g,
                                "font-weight": x,
                                fill: b,
                                class: "apexcharts-text " + C
                            }), p.node.style.fontFamily = g, p.node.style.opacity = v, p
                        }
                    }, {
                        key: "drawMarker",
                        value: function(t, e, i) {
                            t = t || 0;
                            var r = i.pSize || 0,
                                l = null;
                            if ("square" === i.shape || "rect" === i.shape) {
                                var h = void 0 === i.pRadius ? r / 2 : i.pRadius;
                                null !== e && r || (r = 0, h = 0);
                                var d = 1.2 * r + h,
                                    g = this.drawRect(d, d, d, d, h);
                                g.attr({
                                    x: t - d / 2,
                                    y: e - d / 2,
                                    cx: t,
                                    cy: e,
                                    class: i.class ? i.class : "",
                                    fill: i.pointFillColor,
                                    "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                    stroke: i.pointStrokeColor,
                                    "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                    "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                                }), l = g
                            } else "circle" !== i.shape && i.shape || (q.isNumber(e) || (r = 0, e = 0), l = this.drawCircle(r, {
                                cx: t,
                                cy: e,
                                class: i.class ? i.class : "",
                                stroke: i.pointStrokeColor,
                                fill: i.pointFillColor,
                                "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                            }));
                            return l
                        }
                    }, {
                        key: "pathMouseEnter",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ae(this.ctx),
                                l = parseInt(t.node.getAttribute("index"), 10),
                                h = parseInt(t.node.getAttribute("j"), 10);
                            if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
                                    seriesIndex: l,
                                    dataPointIndex: h,
                                    w: i
                                }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
                                    seriesIndex: l,
                                    dataPointIndex: h,
                                    w: i
                                }]), ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && !i.globals.isTouchDevice) {
                                var d = i.config.states.hover.filter;
                                r.applyFilter(t, l, d.type, d.value)
                            }
                        }
                    }, {
                        key: "pathMouseLeave",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ae(this.ctx),
                                l = parseInt(t.node.getAttribute("index"), 10),
                                h = parseInt(t.node.getAttribute("j"), 10);
                            "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
                                seriesIndex: l,
                                dataPointIndex: h,
                                w: i
                            }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
                                seriesIndex: l,
                                dataPointIndex: h,
                                w: i
                            }]), "none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && r.getDefaultFilter(t, l)
                        }
                    }, {
                        key: "pathMouseDown",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ae(this.ctx),
                                l = parseInt(t.node.getAttribute("index"), 10),
                                h = parseInt(t.node.getAttribute("j"), 10),
                                d = "false";
                            if ("true" === t.node.getAttribute("selected")) {
                                if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[l].indexOf(h) > -1) {
                                    var g = i.globals.selectedDataPoints[l].indexOf(h);
                                    i.globals.selectedDataPoints[l].splice(g, 1)
                                }
                            } else {
                                if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
                                    i.globals.selectedDataPoints = [];
                                    var x = i.globals.dom.Paper.select(".apexcharts-series path").members,
                                        b = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                                        v = function(C) {
                                            Array.prototype.forEach.call(C, function(P) {
                                                P.node.setAttribute("selected", "false"), r.getDefaultFilter(P, l)
                                            })
                                        };
                                    v(x), v(b)
                                }
                                t.node.setAttribute("selected", "true"), d = "true", void 0 === i.globals.selectedDataPoints[l] && (i.globals.selectedDataPoints[l] = []), i.globals.selectedDataPoints[l].push(h)
                            }
                            if ("true" === d) {
                                var w = i.config.states.active.filter;
                                if ("none" !== w) r.applyFilter(t, l, w.type, w.value);
                                else if ("none" !== i.config.states.hover.filter && !i.globals.isTouchDevice) {
                                    var S = i.config.states.hover.filter;
                                    r.applyFilter(t, l, S.type, S.value)
                                }
                            } else "none" !== i.config.states.active.filter.type && ("none" === i.config.states.hover.filter.type || i.globals.isTouchDevice ? r.getDefaultFilter(t, l) : r.applyFilter(t, l, (S = i.config.states.hover.filter).type, S.value));
                            "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, {
                                selectedDataPoints: i.globals.selectedDataPoints,
                                seriesIndex: l,
                                dataPointIndex: h,
                                w: i
                            }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
                                selectedDataPoints: i.globals.selectedDataPoints,
                                seriesIndex: l,
                                dataPointIndex: h,
                                w: i
                            }])
                        }
                    }, {
                        key: "rotateAroundCenter",
                        value: function(t) {
                            var e = {};
                            return t && "function" == typeof t.getBBox && (e = t.getBBox()), {
                                x: e.x + e.width / 2,
                                y: e.y + e.height / 2
                            }
                        }
                    }, {
                        key: "getTextRects",
                        value: function(t, e, i, r) {
                            var l = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                h = this.w,
                                d = this.drawText({
                                    x: -200,
                                    y: -200,
                                    text: t,
                                    textAnchor: "start",
                                    fontSize: e,
                                    fontFamily: i,
                                    foreColor: "#fff",
                                    opacity: 0
                                });
                            r && d.attr("transform", r), h.globals.dom.Paper.add(d);
                            var g = d.bbox();
                            return l || (g = d.node.getBoundingClientRect()), d.remove(), {
                                width: g.width,
                                height: g.height
                            }
                        }
                    }, {
                        key: "placeTextWithEllipsis",
                        value: function(t, e, i) {
                            if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
                                for (var r = e.length - 3; r > 0; r -= 3)
                                    if (t.getSubStringLength(0, r) <= i / 1.1) return void(t.textContent = e.substring(0, r) + "...");
                                t.textContent = "."
                            }
                        }
                    }], [{
                        key: "setAttrs",
                        value: function(t, e) {
                            for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                        }
                    }]), _
                }(),
                te = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "getStackedSeriesTotals",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                e = this.w,
                                i = [];
                            if (0 === e.globals.series.length) return i;
                            for (var r = 0; r < e.globals.series[e.globals.maxValsInArrayIndex].length; r++) {
                                for (var l = 0, h = 0; h < e.globals.series.length; h++) void 0 !== e.globals.series[h][r] && -1 === t.indexOf(h) && (l += e.globals.series[h][r]);
                                i.push(l)
                            }
                            return i
                        }
                    }, {
                        key: "getSeriesTotalByIndex",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            return null === t ? this.w.config.series.reduce(function(e, i) {
                                return e + i
                            }, 0) : this.w.globals.series[t].reduce(function(e, i) {
                                return e + i
                            }, 0)
                        }
                    }, {
                        key: "isSeriesNull",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            return 0 === (null === t ? this.w.config.series.filter(function(e) {
                                return null !== e
                            }) : this.w.config.series[t].data.filter(function(e) {
                                return null !== e
                            })).length
                        }
                    }, {
                        key: "seriesHaveSameValues",
                        value: function(t) {
                            return this.w.globals.series[t].every(function(e, i, r) {
                                return e === r[0]
                            })
                        }
                    }, {
                        key: "getCategoryLabels",
                        value: function(t) {
                            var e = this.w,
                                i = t.slice();
                            return e.config.xaxis.convertedCatToNumeric && (i = t.map(function(r, l) {
                                return e.config.xaxis.labels.formatter(r - e.globals.minX + 1)
                            })), i
                        }
                    }, {
                        key: "getLargestSeries",
                        value: function() {
                            var t = this.w;
                            t.globals.maxValsInArrayIndex = t.globals.series.map(function(e) {
                                return e.length
                            }).indexOf(Math.max.apply(Math, t.globals.series.map(function(e) {
                                return e.length
                            })))
                        }
                    }, {
                        key: "getLargestMarkerSize",
                        value: function() {
                            var t = this.w,
                                e = 0;
                            return t.globals.markers.size.forEach(function(i) {
                                e = Math.max(e, i)
                            }), t.config.markers.discrete && t.config.markers.discrete.length && t.config.markers.discrete.forEach(function(i) {
                                e = Math.max(e, i.size)
                            }), e > 0 && (e += t.config.markers.hover.sizeOffset + 1), t.globals.markers.largestSize = e, e
                        }
                    }, {
                        key: "getSeriesTotals",
                        value: function() {
                            var t = this.w;
                            t.globals.seriesTotals = t.globals.series.map(function(e, i) {
                                var r = 0;
                                if (Array.isArray(e))
                                    for (var l = 0; l < e.length; l++) r += e[l];
                                else r += e;
                                return r
                            })
                        }
                    }, {
                        key: "getSeriesTotalsXRange",
                        value: function(t, e) {
                            var i = this.w;
                            return i.globals.series.map(function(r, l) {
                                for (var h = 0, d = 0; d < r.length; d++) i.globals.seriesX[l][d] > t && i.globals.seriesX[l][d] < e && (h += r[d]);
                                return h
                            })
                        }
                    }, {
                        key: "getPercentSeries",
                        value: function() {
                            var t = this.w;
                            t.globals.seriesPercent = t.globals.series.map(function(e, i) {
                                var r = [];
                                if (Array.isArray(e))
                                    for (var l = 0; l < e.length; l++) {
                                        var h = t.globals.stackedSeriesTotals[l],
                                            d = 0;
                                        h && (d = 100 * e[l] / h), r.push(d)
                                    } else {
                                        var g = 100 * e / t.globals.seriesTotals.reduce(function(x, b) {
                                            return x + b
                                        }, 0);
                                        r.push(g)
                                    }
                                return r
                            })
                        }
                    }, {
                        key: "getCalculatedRatios",
                        value: function() {
                            var t, e, i, r, l = this.w.globals,
                                h = [],
                                d = 0,
                                g = [],
                                x = .1,
                                b = 0;
                            if (l.yRange = [], l.isMultipleYAxis)
                                for (var v = 0; v < l.minYArr.length; v++) l.yRange.push(Math.abs(l.minYArr[v] - l.maxYArr[v])), g.push(0);
                            else l.yRange.push(Math.abs(l.minY - l.maxY));
                            l.xRange = Math.abs(l.maxX - l.minX), l.zRange = Math.abs(l.maxZ - l.minZ);
                            for (var w = 0; w < l.yRange.length; w++) h.push(l.yRange[w] / l.gridHeight);
                            if (e = l.xRange / l.gridWidth, i = Math.abs(l.initialMaxX - l.initialMinX) / l.gridWidth, t = l.yRange / l.gridWidth, r = l.xRange / l.gridHeight, (d = l.zRange / l.gridHeight * 16) || (d = 1), l.minY !== Number.MIN_VALUE && 0 !== Math.abs(l.minY) && (l.hasNegs = !0), l.isMultipleYAxis) {
                                g = [];
                                for (var S = 0; S < h.length; S++) g.push(-l.minYArr[S] / h[S])
                            } else g.push(-l.minY / h[0]), l.minY !== Number.MIN_VALUE && 0 !== Math.abs(l.minY) && (x = -l.minY / t, b = l.minX / e);
                            return {
                                yRatio: h,
                                invertedYRatio: t,
                                zRatio: d,
                                xRatio: e,
                                initialXRatio: i,
                                invertedXRatio: r,
                                baseLineInvertedY: x,
                                baseLineY: g,
                                baseLineX: b
                            }
                        }
                    }, {
                        key: "getLogSeries",
                        value: function(t) {
                            var e = this,
                                i = this.w;
                            return i.globals.seriesLog = t.map(function(r, l) {
                                return i.config.yaxis[l] && i.config.yaxis[l].logarithmic ? r.map(function(h) {
                                    return null === h ? null : e.getLogVal(i.config.yaxis[l].logBase, h, l)
                                }) : r
                            }), i.globals.invalidLogScale ? t : i.globals.seriesLog
                        }
                    }, {
                        key: "getBaseLog",
                        value: function(t, e) {
                            return Math.log(e) / Math.log(t)
                        }
                    }, {
                        key: "getLogVal",
                        value: function(t, e, i) {
                            if (0 === e) return 0;
                            var r = this.w,
                                l = 0 === r.globals.minYArr[i] ? -1 : this.getBaseLog(t, r.globals.minYArr[i]),
                                h = (0 === r.globals.maxYArr[i] ? 0 : this.getBaseLog(t, r.globals.maxYArr[i])) - l;
                            return e < 1 ? e / h : (this.getBaseLog(t, e) - l) / h
                        }
                    }, {
                        key: "getLogYRatios",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = this.w.globals;
                            return r.yLogRatio = t.slice(), r.logYRange = r.yRange.map(function(l, h) {
                                if (i.config.yaxis[h] && e.w.config.yaxis[h].logarithmic) {
                                    var d, g = -Number.MAX_VALUE,
                                        x = Number.MIN_VALUE;
                                    return r.seriesLog.forEach(function(b, v) {
                                        b.forEach(function(w) {
                                            i.config.yaxis[v] && i.config.yaxis[v].logarithmic && (g = Math.max(w, g), x = Math.min(w, x))
                                        })
                                    }), d = Math.pow(r.yRange[h], Math.abs(x - g) / r.yRange[h]), r.yLogRatio[h] = d / r.gridHeight, d
                                }
                            }), r.invalidLogScale ? t.slice() : r.yLogRatio
                        }
                    }], [{
                        key: "checkComboSeries",
                        value: function(t) {
                            var e = !1,
                                i = 0,
                                r = 0;
                            return t.length && void 0 !== t[0].type && t.forEach(function(l) {
                                "bar" !== l.type && "column" !== l.type && "candlestick" !== l.type && "boxPlot" !== l.type || i++, void 0 !== l.type && r++
                            }), r > 0 && (e = !0), {
                                comboBarCount: i,
                                comboCharts: e
                            }
                        }
                    }, {
                        key: "extendArrayProps",
                        value: function(t, e, i) {
                            return e.yaxis && (e = t.extendYAxis(e, i)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e
                        }
                    }]), _
                }(),
                Ue = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.annoCtx = t
                    }
                    return ht(_, [{
                        key: "setOrientations",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            if ("vertical" === t.label.orientation) {
                                var l = this.w.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(null !== e ? e : 0, "']"));
                                if (null !== l) {
                                    var h = l.getBoundingClientRect();
                                    l.setAttribute("x", parseFloat(l.getAttribute("x")) - h.height + 4), l.setAttribute("y", "top" === t.label.position ? parseFloat(l.getAttribute("y")) + h.width : parseFloat(l.getAttribute("y")) - h.width);
                                    var d = this.annoCtx.graphics.rotateAroundCenter(l),
                                        x = d.y;
                                    l.setAttribute("transform", "rotate(-90 ".concat(d.x, " ").concat(x, ")"))
                                }
                            }
                        }
                    }, {
                        key: "addBackgroundToAnno",
                        value: function(t, e) {
                            var i = this.w;
                            if (!t || void 0 === e.label.text || void 0 !== e.label.text && !String(e.label.text).trim()) return null;
                            var r = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
                                l = t.getBoundingClientRect(),
                                h = e.label.style.padding.left,
                                d = e.label.style.padding.right,
                                g = e.label.style.padding.top,
                                x = e.label.style.padding.bottom;
                            "vertical" === e.label.orientation && (g = e.label.style.padding.left, x = e.label.style.padding.right, h = e.label.style.padding.top, d = e.label.style.padding.bottom);
                            var w = this.annoCtx.graphics.drawRect(l.left - r.left - h - i.globals.barPadForNumericAxis, l.top - r.top - g, l.width + h + d, l.height + g + x, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
                            return e.id && w.node.classList.add(e.id), w
                        }
                    }, {
                        key: "annotationsBackground",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = function(r, l, h) {
                                    var d = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(h, "-annotations .apexcharts-").concat(h, "-annotation-label[rel='").concat(l, "']"));
                                    if (d) {
                                        var g = d.parentNode,
                                            x = t.addBackgroundToAnno(d, r);
                                        x && (g.insertBefore(x.node, d), r.label.mouseEnter && x.node.addEventListener("mouseenter", r.label.mouseEnter.bind(t, r)), r.label.mouseLeave && x.node.addEventListener("mouseleave", r.label.mouseLeave.bind(t, r)), r.label.click && x.node.addEventListener("click", r.label.click.bind(t, r)))
                                    }
                                };
                            e.config.annotations.xaxis.map(function(r, l) {
                                i(r, l, "xaxis")
                            }), e.config.annotations.yaxis.map(function(r, l) {
                                i(r, l, "yaxis")
                            }), e.config.annotations.points.map(function(r, l) {
                                i(r, l, "point")
                            })
                        }
                    }, {
                        key: "getY1Y2",
                        value: function(t, e) {
                            var i, r = "y1" === t ? e.y : e.y2,
                                l = this.w;
                            if (this.annoCtx.invertAxis) {
                                var h = l.globals.labels.indexOf(r);
                                l.config.xaxis.convertedCatToNumeric && (h = l.globals.categoryLabels.indexOf(r));
                                var d = l.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (h + 1) + ")");
                                d && (i = parseFloat(d.getAttribute("y")))
                            } else {
                                var g;
                                g = l.config.yaxis[e.yAxisIndex].logarithmic ? (r = new te(this.annoCtx.ctx).getLogVal(r, e.yAxisIndex)) / l.globals.yLogRatio[e.yAxisIndex] : (r - l.globals.minYArr[e.yAxisIndex]) / (l.globals.yRange[e.yAxisIndex] / l.globals.gridHeight), i = l.globals.gridHeight - g, !e.marker || null != e.y || (i = 0), l.config.yaxis[e.yAxisIndex] && l.config.yaxis[e.yAxisIndex].reversed && (i = g)
                            }
                            return "string" == typeof r && r.indexOf("px") > -1 && (i = parseFloat(r)), i
                        }
                    }, {
                        key: "getX1X2",
                        value: function(t, e) {
                            var i = this.w,
                                r = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX,
                                l = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX,
                                h = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange,
                                d = (e.x - r) / (h / i.globals.gridWidth);
                            this.annoCtx.inversedReversedAxis && (d = (l - e.x) / (h / i.globals.gridWidth)), "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (d = this.getStringX(e.x));
                            var g = (e.x2 - r) / (h / i.globals.gridWidth);
                            return this.annoCtx.inversedReversedAxis && (g = (l - e.x2) / (h / i.globals.gridWidth)), "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (g = this.getStringX(e.x2)), null != e.x || !e.marker || (d = i.globals.gridWidth), "x1" === t && "string" == typeof e.x && e.x.indexOf("px") > -1 && (d = parseFloat(e.x)), "x2" === t && "string" == typeof e.x2 && e.x2.indexOf("px") > -1 && (g = parseFloat(e.x2)), "x1" === t ? d : g
                        }
                    }, {
                        key: "getStringX",
                        value: function(t) {
                            var e = this.w,
                                i = t;
                            e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
                            var r = e.globals.labels.indexOf(t),
                                l = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (r + 1) + ")");
                            return l && (i = parseFloat(l.getAttribute("x"))), i
                        }
                    }]), _
                }(),
                li = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.annoCtx = t, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ue(this.annoCtx)
                    }
                    return ht(_, [{
                        key: "addXaxisAnnotation",
                        value: function(t, e, i) {
                            var r, l = this.w,
                                h = this.helpers.getX1X2("x1", t),
                                d = t.label.text,
                                g = t.strokeDashArray;
                            if (q.isNumber(h)) {
                                if (null == t.x2) {
                                    var x = this.annoCtx.graphics.drawLine(h + t.offsetX, 0 + t.offsetY, h + t.offsetX, l.globals.gridHeight + t.offsetY, t.borderColor, g, t.borderWidth);
                                    e.appendChild(x.node), t.id && x.node.classList.add(t.id)
                                } else {
                                    if ((r = this.helpers.getX1X2("x2", t)) < h) {
                                        var b = h;
                                        h = r, r = b
                                    }
                                    var v = this.annoCtx.graphics.drawRect(h + t.offsetX, 0 + t.offsetY, r - h, l.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, g);
                                    v.node.classList.add("apexcharts-annotation-rect"), v.attr("clip-path", "url(#gridRectMask".concat(l.globals.cuid, ")")), e.appendChild(v.node), t.id && v.node.classList.add(t.id)
                                }
                                var w = this.annoCtx.graphics.getTextRects(d, parseFloat(t.label.style.fontSize)),
                                    C = this.annoCtx.graphics.drawText({
                                        x: h + t.label.offsetX,
                                        y: ("top" === t.label.position ? 4 : "center" === t.label.position ? l.globals.gridHeight / 2 + ("vertical" === t.label.orientation ? w.width / 2 : 0) : l.globals.gridHeight) + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? w.width / 2 - 12 : -w.width / 2 : 0),
                                        text: d,
                                        textAnchor: t.label.textAnchor,
                                        fontSize: t.label.style.fontSize,
                                        fontFamily: t.label.style.fontFamily,
                                        fontWeight: t.label.style.fontWeight,
                                        foreColor: t.label.style.color,
                                        cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                    });
                                C.attr({
                                    rel: i
                                }), e.appendChild(C.node), this.annoCtx.helpers.setOrientations(t, i)
                            }
                        }
                    }, {
                        key: "drawXAxisAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-xaxis-annotations"
                                });
                            return e.config.annotations.xaxis.map(function(r, l) {
                                t.addXaxisAnnotation(r, i.node, l)
                            }), i
                        }
                    }]), _
                }(),
                hi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.annoCtx = t, this.helpers = new Ue(this.annoCtx)
                    }
                    return ht(_, [{
                        key: "addYaxisAnnotation",
                        value: function(t, e, i) {
                            var r, l = this.w,
                                h = t.strokeDashArray,
                                d = this.helpers.getY1Y2("y1", t),
                                g = t.label.text;
                            if (null == t.y2) {
                                var x = this.annoCtx.graphics.drawLine(0 + t.offsetX, d + t.offsetY, this._getYAxisAnnotationWidth(t), d + t.offsetY, t.borderColor, h, t.borderWidth);
                                e.appendChild(x.node), t.id && x.node.classList.add(t.id)
                            } else {
                                if ((r = this.helpers.getY1Y2("y2", t)) > d) {
                                    var b = d;
                                    d = r, r = b
                                }
                                var v = this.annoCtx.graphics.drawRect(0 + t.offsetX, r + t.offsetY, this._getYAxisAnnotationWidth(t), d - r, 0, t.fillColor, t.opacity, 1, t.borderColor, h);
                                v.node.classList.add("apexcharts-annotation-rect"), v.attr("clip-path", "url(#gridRectMask".concat(l.globals.cuid, ")")), e.appendChild(v.node), t.id && v.node.classList.add(t.id)
                            }
                            var S = this.annoCtx.graphics.drawText({
                                x: ("right" === t.label.position ? l.globals.gridWidth : "center" === t.label.position ? l.globals.gridWidth / 2 : 0) + t.label.offsetX,
                                y: (r ? ? d) + t.label.offsetY - 3,
                                text: g,
                                textAnchor: t.label.textAnchor,
                                fontSize: t.label.style.fontSize,
                                fontFamily: t.label.style.fontFamily,
                                fontWeight: t.label.style.fontWeight,
                                foreColor: t.label.style.color,
                                cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                            });
                            S.attr({
                                rel: i
                            }), e.appendChild(S.node)
                        }
                    }, {
                        key: "_getYAxisAnnotationWidth",
                        value: function(t) {
                            var e = this.w;
                            return (t.width.indexOf("%") > -1 ? e.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX
                        }
                    }, {
                        key: "drawYAxisAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-yaxis-annotations"
                                });
                            return e.config.annotations.yaxis.map(function(r, l) {
                                t.addYaxisAnnotation(r, i.node, l)
                            }), i
                        }
                    }]), _
                }(),
                Ni = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.annoCtx = t, this.helpers = new Ue(this.annoCtx)
                    }
                    return ht(_, [{
                        key: "addPointAnnotation",
                        value: function(t, e, i) {
                            var r = this.helpers.getX1X2("x1", t),
                                l = this.helpers.getY1Y2("y1", t);
                            if (q.isNumber(r)) {
                                var h = {
                                        pSize: t.marker.size,
                                        pointStrokeWidth: t.marker.strokeWidth,
                                        pointFillColor: t.marker.fillColor,
                                        pointStrokeColor: t.marker.strokeColor,
                                        shape: t.marker.shape,
                                        pRadius: t.marker.radius,
                                        class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
                                    },
                                    d = this.annoCtx.graphics.drawMarker(r + t.marker.offsetX, l + t.marker.offsetY, h);
                                e.appendChild(d.node);
                                var g = t.label.text ? t.label.text : "",
                                    x = this.annoCtx.graphics.drawText({
                                        x: r + t.label.offsetX,
                                        y: l + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6,
                                        text: g,
                                        textAnchor: t.label.textAnchor,
                                        fontSize: t.label.style.fontSize,
                                        fontFamily: t.label.style.fontFamily,
                                        fontWeight: t.label.style.fontWeight,
                                        foreColor: t.label.style.color,
                                        cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                    });
                                if (x.attr({
                                        rel: i
                                    }), e.appendChild(x.node), t.customSVG.SVG) {
                                    var b = this.annoCtx.graphics.group({
                                        class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass
                                    });
                                    b.attr({
                                        transform: "translate(".concat(r + t.customSVG.offsetX, ", ").concat(l + t.customSVG.offsetY, ")")
                                    }), b.node.innerHTML = t.customSVG.SVG, e.appendChild(b.node)
                                }
                                if (t.image.path) {
                                    var v = t.image.width ? t.image.width : 20,
                                        w = t.image.height ? t.image.height : 20;
                                    d = this.annoCtx.addImage({
                                        x: r + t.image.offsetX - v / 2,
                                        y: l + t.image.offsetY - w / 2,
                                        width: v,
                                        height: w,
                                        path: t.image.path,
                                        appendTo: ".apexcharts-point-annotations"
                                    })
                                }
                                t.mouseEnter && d.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)), t.mouseLeave && d.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)), t.click && d.node.addEventListener("click", t.click.bind(this, t))
                            }
                        }
                    }, {
                        key: "drawPointAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-point-annotations"
                                });
                            return e.config.annotations.points.map(function(r, l) {
                                t.addPointAnnotation(r, i.node, l)
                            }), i
                        }
                    }]), _
                }(),
                Bi = {
                    name: "en",
                    options: {
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        toolbar: {
                            exportToSVG: "Download SVG",
                            exportToPNG: "Download PNG",
                            exportToCSV: "Download CSV",
                            menu: "Menu",
                            selection: "Selection",
                            selectionZoom: "Selection Zoom",
                            zoomIn: "Zoom In",
                            zoomOut: "Zoom Out",
                            pan: "Panning",
                            reset: "Reset Zoom"
                        }
                    }
                },
                Re = function() {
                    function _() {
                        xt(this, _), this.yAxis = {
                            show: !0,
                            showAlways: !1,
                            showForNullSeries: !0,
                            seriesName: void 0,
                            opposite: !1,
                            reversed: !1,
                            logarithmic: !1,
                            logBase: 10,
                            tickAmount: void 0,
                            forceNiceScale: !1,
                            max: void 0,
                            min: void 0,
                            floating: !1,
                            decimalsInFloat: void 0,
                            labels: {
                                show: !0,
                                minWidth: 0,
                                maxWidth: 160,
                                offsetX: 0,
                                offsetY: 0,
                                align: void 0,
                                rotate: 0,
                                padding: 20,
                                style: {
                                    colors: [],
                                    fontSize: "11px",
                                    fontWeight: 400,
                                    fontFamily: void 0,
                                    cssClass: ""
                                },
                                formatter: void 0
                            },
                            axisBorder: {
                                show: !1,
                                color: "#e0e0e0",
                                width: 1,
                                offsetX: 0,
                                offsetY: 0
                            },
                            axisTicks: {
                                show: !1,
                                color: "#e0e0e0",
                                width: 6,
                                offsetX: 0,
                                offsetY: 0
                            },
                            title: {
                                text: void 0,
                                rotate: -90,
                                offsetY: 0,
                                offsetX: 0,
                                style: {
                                    color: void 0,
                                    fontSize: "11px",
                                    fontWeight: 900,
                                    fontFamily: void 0,
                                    cssClass: ""
                                }
                            },
                            tooltip: {
                                enabled: !1,
                                offsetX: 0
                            },
                            crosshairs: {
                                show: !0,
                                position: "front",
                                stroke: {
                                    color: "#b6b6b6",
                                    width: 1,
                                    dashArray: 0
                                }
                            }
                        }, this.pointAnnotation = {
                            id: void 0,
                            x: 0,
                            y: null,
                            yAxisIndex: 0,
                            seriesIndex: 0,
                            mouseEnter: void 0,
                            mouseLeave: void 0,
                            click: void 0,
                            marker: {
                                size: 4,
                                fillColor: "#fff",
                                strokeWidth: 2,
                                strokeColor: "#333",
                                shape: "circle",
                                offsetX: 0,
                                offsetY: 0,
                                radius: 2,
                                cssClass: ""
                            },
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "middle",
                                offsetX: 0,
                                offsetY: 0,
                                mouseEnter: void 0,
                                mouseLeave: void 0,
                                click: void 0,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            },
                            customSVG: {
                                SVG: void 0,
                                cssClass: void 0,
                                offsetX: 0,
                                offsetY: 0
                            },
                            image: {
                                path: void 0,
                                width: 20,
                                height: 20,
                                offsetX: 0,
                                offsetY: 0
                            }
                        }, this.yAxisAnnotation = {
                            id: void 0,
                            y: 0,
                            y2: null,
                            strokeDashArray: 1,
                            fillColor: "#c2c2c2",
                            borderColor: "#c2c2c2",
                            borderWidth: 1,
                            opacity: .3,
                            offsetX: 0,
                            offsetY: 0,
                            width: "100%",
                            yAxisIndex: 0,
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "end",
                                position: "right",
                                offsetX: 0,
                                offsetY: -3,
                                mouseEnter: void 0,
                                mouseLeave: void 0,
                                click: void 0,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            }
                        }, this.xAxisAnnotation = {
                            id: void 0,
                            x: 0,
                            x2: null,
                            strokeDashArray: 1,
                            fillColor: "#c2c2c2",
                            borderColor: "#c2c2c2",
                            borderWidth: 1,
                            opacity: .3,
                            offsetX: 0,
                            offsetY: 0,
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "middle",
                                orientation: "vertical",
                                position: "top",
                                offsetX: 0,
                                offsetY: 0,
                                mouseEnter: void 0,
                                mouseLeave: void 0,
                                click: void 0,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            }
                        }, this.text = {
                            x: 0,
                            y: 0,
                            text: "",
                            textAnchor: "start",
                            foreColor: void 0,
                            fontSize: "13px",
                            fontFamily: void 0,
                            fontWeight: 400,
                            appendTo: ".apexcharts-annotations",
                            backgroundColor: "transparent",
                            borderColor: "#c2c2c2",
                            borderRadius: 0,
                            borderWidth: 0,
                            paddingLeft: 4,
                            paddingRight: 4,
                            paddingTop: 2,
                            paddingBottom: 2
                        }
                    }
                    return ht(_, [{
                        key: "init",
                        value: function() {
                            return {
                                annotations: {
                                    yaxis: [this.yAxisAnnotation],
                                    xaxis: [this.xAxisAnnotation],
                                    points: [this.pointAnnotation],
                                    texts: [],
                                    images: [],
                                    shapes: []
                                },
                                chart: {
                                    animations: {
                                        enabled: !0,
                                        easing: "easeinout",
                                        speed: 800,
                                        animateGradually: {
                                            delay: 150,
                                            enabled: !0
                                        },
                                        dynamicAnimation: {
                                            enabled: !0,
                                            speed: 350
                                        }
                                    },
                                    background: "transparent",
                                    locales: [Bi],
                                    defaultLocale: "en",
                                    dropShadow: {
                                        enabled: !1,
                                        enabledOnSeries: void 0,
                                        top: 2,
                                        left: 2,
                                        blur: 4,
                                        color: "#000",
                                        opacity: .35
                                    },
                                    events: {
                                        animationEnd: void 0,
                                        beforeMount: void 0,
                                        mounted: void 0,
                                        updated: void 0,
                                        click: void 0,
                                        mouseMove: void 0,
                                        mouseLeave: void 0,
                                        xAxisLabelClick: void 0,
                                        legendClick: void 0,
                                        markerClick: void 0,
                                        selection: void 0,
                                        dataPointSelection: void 0,
                                        dataPointMouseEnter: void 0,
                                        dataPointMouseLeave: void 0,
                                        beforeZoom: void 0,
                                        beforeResetZoom: void 0,
                                        zoomed: void 0,
                                        scrolled: void 0,
                                        brushScrolled: void 0
                                    },
                                    foreColor: "#373d3f",
                                    fontFamily: "Helvetica, Arial, sans-serif",
                                    height: "auto",
                                    parentHeightOffset: 15,
                                    redrawOnParentResize: !0,
                                    redrawOnWindowResize: !0,
                                    id: void 0,
                                    group: void 0,
                                    offsetX: 0,
                                    offsetY: 0,
                                    selection: {
                                        enabled: !1,
                                        type: "x",
                                        fill: {
                                            color: "#24292e",
                                            opacity: .1
                                        },
                                        stroke: {
                                            width: 1,
                                            color: "#24292e",
                                            opacity: .4,
                                            dashArray: 3
                                        },
                                        xaxis: {
                                            min: void 0,
                                            max: void 0
                                        },
                                        yaxis: {
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    sparkline: {
                                        enabled: !1
                                    },
                                    brush: {
                                        enabled: !1,
                                        autoScaleYaxis: !0,
                                        target: void 0,
                                        targets: void 0
                                    },
                                    stacked: !1,
                                    stackType: "normal",
                                    toolbar: {
                                        show: !0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        tools: {
                                            download: !0,
                                            selection: !0,
                                            zoom: !0,
                                            zoomin: !0,
                                            zoomout: !0,
                                            pan: !0,
                                            reset: !0,
                                            customIcons: []
                                        },
                                        export: {
                                            csv: {
                                                filename: void 0,
                                                columnDelimiter: ",",
                                                headerCategory: "category",
                                                headerValue: "value",
                                                dateFormatter: function(t) {
                                                    return new Date(t).toDateString()
                                                }
                                            },
                                            png: {
                                                filename: void 0
                                            },
                                            svg: {
                                                filename: void 0
                                            }
                                        },
                                        autoSelected: "zoom"
                                    },
                                    type: "line",
                                    width: "100%",
                                    zoom: {
                                        enabled: !0,
                                        type: "x",
                                        autoScaleYaxis: !1,
                                        zoomedArea: {
                                            fill: {
                                                color: "#90CAF9",
                                                opacity: .4
                                            },
                                            stroke: {
                                                color: "#0D47A1",
                                                opacity: .4,
                                                width: 1
                                            }
                                        }
                                    }
                                },
                                plotOptions: {
                                    area: {
                                        fillTo: "origin"
                                    },
                                    bar: {
                                        horizontal: !1,
                                        columnWidth: "70%",
                                        barHeight: "70%",
                                        distributed: !1,
                                        borderRadius: 0,
                                        borderRadiusApplication: "around",
                                        borderRadiusWhenStacked: "last",
                                        rangeBarOverlap: !0,
                                        rangeBarGroupRows: !1,
                                        hideZeroBarsWhenGrouped: !1,
                                        isDumbbell: !1,
                                        dumbbellColors: void 0,
                                        isFunnel: !1,
                                        isFunnel3d: !0,
                                        colors: {
                                            ranges: [],
                                            backgroundBarColors: [],
                                            backgroundBarOpacity: 1,
                                            backgroundBarRadius: 0
                                        },
                                        dataLabels: {
                                            position: "top",
                                            maxItems: 100,
                                            hideOverflowingLabels: !0,
                                            orientation: "horizontal",
                                            total: {
                                                enabled: !1,
                                                formatter: void 0,
                                                offsetX: 0,
                                                offsetY: 0,
                                                style: {
                                                    color: "#373d3f",
                                                    fontSize: "12px",
                                                    fontFamily: void 0,
                                                    fontWeight: 600
                                                }
                                            }
                                        }
                                    },
                                    bubble: {
                                        zScaling: !0,
                                        minBubbleRadius: void 0,
                                        maxBubbleRadius: void 0
                                    },
                                    candlestick: {
                                        colors: {
                                            upward: "#00B746",
                                            downward: "#EF403C"
                                        },
                                        wick: {
                                            useFillColor: !0
                                        }
                                    },
                                    boxPlot: {
                                        colors: {
                                            upper: "#00E396",
                                            lower: "#008FFB"
                                        }
                                    },
                                    heatmap: {
                                        radius: 2,
                                        enableShades: !0,
                                        shadeIntensity: .5,
                                        reverseNegativeShade: !1,
                                        distributed: !1,
                                        useFillColorAsStroke: !1,
                                        colorScale: {
                                            inverse: !1,
                                            ranges: [],
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    treemap: {
                                        enableShades: !0,
                                        shadeIntensity: .5,
                                        distributed: !1,
                                        reverseNegativeShade: !1,
                                        useFillColorAsStroke: !1,
                                        dataLabels: {
                                            format: "scale"
                                        },
                                        colorScale: {
                                            inverse: !1,
                                            ranges: [],
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    radialBar: {
                                        inverseOrder: !1,
                                        startAngle: 0,
                                        endAngle: 360,
                                        offsetX: 0,
                                        offsetY: 0,
                                        hollow: {
                                            margin: 5,
                                            size: "50%",
                                            background: "transparent",
                                            image: void 0,
                                            imageWidth: 150,
                                            imageHeight: 150,
                                            imageOffsetX: 0,
                                            imageOffsetY: 0,
                                            imageClipped: !0,
                                            position: "front",
                                            dropShadow: {
                                                enabled: !1,
                                                top: 0,
                                                left: 0,
                                                blur: 3,
                                                color: "#000",
                                                opacity: .5
                                            }
                                        },
                                        track: {
                                            show: !0,
                                            startAngle: void 0,
                                            endAngle: void 0,
                                            background: "#f2f2f2",
                                            strokeWidth: "97%",
                                            opacity: 1,
                                            margin: 5,
                                            dropShadow: {
                                                enabled: !1,
                                                top: 0,
                                                left: 0,
                                                blur: 3,
                                                color: "#000",
                                                opacity: .5
                                            }
                                        },
                                        dataLabels: {
                                            show: !0,
                                            name: {
                                                show: !0,
                                                fontSize: "16px",
                                                fontFamily: void 0,
                                                fontWeight: 600,
                                                color: void 0,
                                                offsetY: 0,
                                                formatter: function(t) {
                                                    return t
                                                }
                                            },
                                            value: {
                                                show: !0,
                                                fontSize: "14px",
                                                fontFamily: void 0,
                                                fontWeight: 400,
                                                color: void 0,
                                                offsetY: 16,
                                                formatter: function(t) {
                                                    return t + "%"
                                                }
                                            },
                                            total: {
                                                show: !1,
                                                label: "Total",
                                                fontSize: "16px",
                                                fontWeight: 600,
                                                fontFamily: void 0,
                                                color: void 0,
                                                formatter: function(t) {
                                                    return t.globals.seriesTotals.reduce(function(e, i) {
                                                        return e + i
                                                    }, 0) / t.globals.series.length + "%"
                                                }
                                            }
                                        }
                                    },
                                    pie: {
                                        customScale: 1,
                                        offsetX: 0,
                                        offsetY: 0,
                                        startAngle: 0,
                                        endAngle: 360,
                                        expandOnClick: !0,
                                        dataLabels: {
                                            offset: 0,
                                            minAngleToShowLabel: 10
                                        },
                                        donut: {
                                            size: "65%",
                                            background: "transparent",
                                            labels: {
                                                show: !1,
                                                name: {
                                                    show: !0,
                                                    fontSize: "16px",
                                                    fontFamily: void 0,
                                                    fontWeight: 600,
                                                    color: void 0,
                                                    offsetY: -10,
                                                    formatter: function(t) {
                                                        return t
                                                    }
                                                },
                                                value: {
                                                    show: !0,
                                                    fontSize: "20px",
                                                    fontFamily: void 0,
                                                    fontWeight: 400,
                                                    color: void 0,
                                                    offsetY: 10,
                                                    formatter: function(t) {
                                                        return t
                                                    }
                                                },
                                                total: {
                                                    show: !1,
                                                    showAlways: !1,
                                                    label: "Total",
                                                    fontSize: "16px",
                                                    fontWeight: 400,
                                                    fontFamily: void 0,
                                                    color: void 0,
                                                    formatter: function(t) {
                                                        return t.globals.seriesTotals.reduce(function(e, i) {
                                                            return e + i
                                                        }, 0)
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    polarArea: {
                                        rings: {
                                            strokeWidth: 1,
                                            strokeColor: "#e8e8e8"
                                        },
                                        spokes: {
                                            strokeWidth: 1,
                                            connectorColors: "#e8e8e8"
                                        }
                                    },
                                    radar: {
                                        size: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        polygons: {
                                            strokeWidth: 1,
                                            strokeColors: "#e8e8e8",
                                            connectorColors: "#e8e8e8",
                                            fill: {
                                                colors: void 0
                                            }
                                        }
                                    }
                                },
                                colors: void 0,
                                dataLabels: {
                                    enabled: !0,
                                    enabledOnSeries: void 0,
                                    formatter: function(t) {
                                        return null !== t ? t : ""
                                    },
                                    textAnchor: "middle",
                                    distributed: !1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        fontSize: "12px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        colors: void 0
                                    },
                                    background: {
                                        enabled: !0,
                                        foreColor: "#fff",
                                        borderRadius: 2,
                                        padding: 4,
                                        opacity: .9,
                                        borderWidth: 1,
                                        borderColor: "#fff",
                                        dropShadow: {
                                            enabled: !1,
                                            top: 1,
                                            left: 1,
                                            blur: 1,
                                            color: "#000",
                                            opacity: .45
                                        }
                                    },
                                    dropShadow: {
                                        enabled: !1,
                                        top: 1,
                                        left: 1,
                                        blur: 1,
                                        color: "#000",
                                        opacity: .45
                                    }
                                },
                                fill: {
                                    type: "solid",
                                    colors: void 0,
                                    opacity: .85,
                                    gradient: {
                                        shade: "dark",
                                        type: "horizontal",
                                        shadeIntensity: .5,
                                        gradientToColors: void 0,
                                        inverseColors: !0,
                                        opacityFrom: 1,
                                        opacityTo: 1,
                                        stops: [0, 50, 100],
                                        colorStops: []
                                    },
                                    image: {
                                        src: [],
                                        width: void 0,
                                        height: void 0
                                    },
                                    pattern: {
                                        style: "squares",
                                        width: 6,
                                        height: 6,
                                        strokeWidth: 2
                                    }
                                },
                                forecastDataPoints: {
                                    count: 0,
                                    fillOpacity: .5,
                                    strokeWidth: void 0,
                                    dashArray: 4
                                },
                                grid: {
                                    show: !0,
                                    borderColor: "#e0e0e0",
                                    strokeDashArray: 0,
                                    position: "back",
                                    xaxis: {
                                        lines: {
                                            show: !1
                                        }
                                    },
                                    yaxis: {
                                        lines: {
                                            show: !0
                                        }
                                    },
                                    row: {
                                        colors: void 0,
                                        opacity: .5
                                    },
                                    column: {
                                        colors: void 0,
                                        opacity: .5
                                    },
                                    padding: {
                                        top: 0,
                                        right: 10,
                                        bottom: 0,
                                        left: 12
                                    }
                                },
                                labels: [],
                                legend: {
                                    show: !0,
                                    showForSingleSeries: !1,
                                    showForNullSeries: !0,
                                    showForZeroSeries: !0,
                                    floating: !1,
                                    position: "bottom",
                                    horizontalAlign: "center",
                                    inverseOrder: !1,
                                    fontSize: "12px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    width: void 0,
                                    height: void 0,
                                    formatter: void 0,
                                    tooltipHoverFormatter: void 0,
                                    offsetX: -20,
                                    offsetY: 4,
                                    customLegendItems: [],
                                    labels: {
                                        colors: void 0,
                                        useSeriesColors: !1
                                    },
                                    markers: {
                                        width: 12,
                                        height: 12,
                                        strokeWidth: 0,
                                        fillColors: void 0,
                                        strokeColor: "#fff",
                                        radius: 12,
                                        customHTML: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        onClick: void 0
                                    },
                                    itemMargin: {
                                        horizontal: 5,
                                        vertical: 2
                                    },
                                    onItemClick: {
                                        toggleDataSeries: !0
                                    },
                                    onItemHover: {
                                        highlightDataSeries: !0
                                    }
                                },
                                markers: {
                                    discrete: [],
                                    size: 0,
                                    colors: void 0,
                                    strokeColors: "#fff",
                                    strokeWidth: 2,
                                    strokeOpacity: .9,
                                    strokeDashArray: 0,
                                    fillOpacity: 1,
                                    shape: "circle",
                                    width: 8,
                                    height: 8,
                                    radius: 2,
                                    offsetX: 0,
                                    offsetY: 0,
                                    onClick: void 0,
                                    onDblClick: void 0,
                                    showNullDataPoints: !0,
                                    hover: {
                                        size: void 0,
                                        sizeOffset: 3
                                    }
                                },
                                noData: {
                                    text: void 0,
                                    align: "center",
                                    verticalAlign: "middle",
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        color: void 0,
                                        fontSize: "14px",
                                        fontFamily: void 0
                                    }
                                },
                                responsive: [],
                                series: void 0,
                                states: {
                                    normal: {
                                        filter: {
                                            type: "none",
                                            value: 0
                                        }
                                    },
                                    hover: {
                                        filter: {
                                            type: "lighten",
                                            value: .1
                                        }
                                    },
                                    active: {
                                        allowMultipleDataPointsSelection: !1,
                                        filter: {
                                            type: "darken",
                                            value: .5
                                        }
                                    }
                                },
                                title: {
                                    text: void 0,
                                    align: "left",
                                    margin: 5,
                                    offsetX: 0,
                                    offsetY: 0,
                                    floating: !1,
                                    style: {
                                        fontSize: "14px",
                                        fontWeight: 900,
                                        fontFamily: void 0,
                                        color: void 0
                                    }
                                },
                                subtitle: {
                                    text: void 0,
                                    align: "left",
                                    margin: 5,
                                    offsetX: 0,
                                    offsetY: 30,
                                    floating: !1,
                                    style: {
                                        fontSize: "12px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0
                                    }
                                },
                                stroke: {
                                    show: !0,
                                    curve: "smooth",
                                    lineCap: "butt",
                                    width: 2,
                                    colors: void 0,
                                    dashArray: 0,
                                    fill: {
                                        type: "solid",
                                        colors: void 0,
                                        opacity: .85,
                                        gradient: {
                                            shade: "dark",
                                            type: "horizontal",
                                            shadeIntensity: .5,
                                            gradientToColors: void 0,
                                            inverseColors: !0,
                                            opacityFrom: 1,
                                            opacityTo: 1,
                                            stops: [0, 50, 100],
                                            colorStops: []
                                        }
                                    }
                                },
                                tooltip: {
                                    enabled: !0,
                                    enabledOnSeries: void 0,
                                    shared: !0,
                                    followCursor: !1,
                                    intersect: !1,
                                    inverseOrder: !1,
                                    custom: void 0,
                                    fillSeriesColor: !1,
                                    theme: "light",
                                    cssClass: "",
                                    style: {
                                        fontSize: "12px",
                                        fontFamily: void 0
                                    },
                                    onDatasetHover: {
                                        highlightDataSeries: !1
                                    },
                                    x: {
                                        show: !0,
                                        format: "dd MMM",
                                        formatter: void 0
                                    },
                                    y: {
                                        formatter: void 0,
                                        title: {
                                            formatter: function(t) {
                                                return t ? t + ": " : ""
                                            }
                                        }
                                    },
                                    z: {
                                        formatter: void 0,
                                        title: "Size: "
                                    },
                                    marker: {
                                        show: !0,
                                        fillColors: void 0
                                    },
                                    items: {
                                        display: "flex"
                                    },
                                    fixed: {
                                        enabled: !1,
                                        position: "topRight",
                                        offsetX: 0,
                                        offsetY: 0
                                    }
                                },
                                xaxis: {
                                    type: "category",
                                    categories: [],
                                    convertedCatToNumeric: !1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    overwriteCategories: void 0,
                                    labels: {
                                        show: !0,
                                        rotate: -45,
                                        rotateAlways: !1,
                                        hideOverlappingLabels: !0,
                                        trim: !1,
                                        minHeight: void 0,
                                        maxHeight: 120,
                                        showDuplicates: !0,
                                        style: {
                                            colors: [],
                                            fontSize: "12px",
                                            fontWeight: 400,
                                            fontFamily: void 0,
                                            cssClass: ""
                                        },
                                        offsetX: 0,
                                        offsetY: 0,
                                        format: void 0,
                                        formatter: void 0,
                                        datetimeUTC: !0,
                                        datetimeFormatter: {
                                            year: "yyyy",
                                            month: "MMM 'yy",
                                            day: "dd MMM",
                                            hour: "HH:mm",
                                            minute: "HH:mm:ss",
                                            second: "HH:mm:ss"
                                        }
                                    },
                                    group: {
                                        groups: [],
                                        style: {
                                            colors: [],
                                            fontSize: "12px",
                                            fontWeight: 400,
                                            fontFamily: void 0,
                                            cssClass: ""
                                        }
                                    },
                                    axisBorder: {
                                        show: !0,
                                        color: "#e0e0e0",
                                        width: "100%",
                                        height: 1,
                                        offsetX: 0,
                                        offsetY: 0
                                    },
                                    axisTicks: {
                                        show: !0,
                                        color: "#e0e0e0",
                                        height: 6,
                                        offsetX: 0,
                                        offsetY: 0
                                    },
                                    tickAmount: void 0,
                                    tickPlacement: "on",
                                    min: void 0,
                                    max: void 0,
                                    range: void 0,
                                    floating: !1,
                                    decimalsInFloat: void 0,
                                    position: "bottom",
                                    title: {
                                        text: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        style: {
                                            color: void 0,
                                            fontSize: "12px",
                                            fontWeight: 900,
                                            fontFamily: void 0,
                                            cssClass: ""
                                        }
                                    },
                                    crosshairs: {
                                        show: !0,
                                        width: 1,
                                        position: "back",
                                        opacity: .9,
                                        stroke: {
                                            color: "#b6b6b6",
                                            width: 1,
                                            dashArray: 3
                                        },
                                        fill: {
                                            type: "solid",
                                            color: "#B1B9C4",
                                            gradient: {
                                                colorFrom: "#D8E3F0",
                                                colorTo: "#BED1E6",
                                                stops: [0, 100],
                                                opacityFrom: .4,
                                                opacityTo: .5
                                            }
                                        },
                                        dropShadow: {
                                            enabled: !1,
                                            left: 0,
                                            top: 0,
                                            blur: 1,
                                            opacity: .4
                                        }
                                    },
                                    tooltip: {
                                        enabled: !0,
                                        offsetY: 0,
                                        formatter: void 0,
                                        style: {
                                            fontSize: "12px",
                                            fontFamily: void 0
                                        }
                                    }
                                },
                                yaxis: this.yAxis,
                                theme: {
                                    mode: "light",
                                    palette: "palette1",
                                    monochrome: {
                                        enabled: !1,
                                        color: "#008FFB",
                                        shadeTo: "light",
                                        shadeIntensity: .65
                                    }
                                }
                            }
                        }
                    }]), _
                }(),
                ci = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.graphics = new ot(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Ue(this), this.xAxisAnnotations = new li(this), this.yAxisAnnotations = new hi(this), this.pointsAnnotations = new Ni(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
                    }
                    return ht(_, [{
                        key: "drawAxesAnnotations",
                        value: function() {
                            var t = this.w;
                            if (t.globals.axisCharts) {
                                for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), r = this.pointsAnnotations.drawPointAnnotations(), l = t.config.chart.animations.enabled, h = [e, i, r], d = [i.node, e.node, r.node], g = 0; g < 3; g++) t.globals.dom.elGraphical.add(h[g]), !l || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && d[g].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
                                    el: d[g],
                                    index: 0
                                });
                                this.helpers.annotationsBackground()
                            }
                        }
                    }, {
                        key: "drawImageAnnos",
                        value: function() {
                            var t = this;
                            this.w.config.annotations.images.map(function(e, i) {
                                t.addImage(e, i)
                            })
                        }
                    }, {
                        key: "drawTextAnnos",
                        value: function() {
                            var t = this;
                            this.w.config.annotations.texts.map(function(e, i) {
                                t.addText(e, i)
                            })
                        }
                    }, {
                        key: "addXaxisAnnotation",
                        value: function(t, e, i) {
                            this.xAxisAnnotations.addXaxisAnnotation(t, e, i)
                        }
                    }, {
                        key: "addYaxisAnnotation",
                        value: function(t, e, i) {
                            this.yAxisAnnotations.addYaxisAnnotation(t, e, i)
                        }
                    }, {
                        key: "addPointAnnotation",
                        value: function(t, e, i) {
                            this.pointsAnnotations.addPointAnnotation(t, e, i)
                        }
                    }, {
                        key: "addText",
                        value: function(t, e) {
                            var l = t.text,
                                w = t.backgroundColor,
                                S = t.borderWidth,
                                C = t.strokeDashArray,
                                P = t.borderRadius,
                                T = t.borderColor,
                                I = t.appendTo,
                                R = void 0 === I ? ".apexcharts-annotations" : I,
                                p = t.paddingLeft,
                                k = void 0 === p ? 4 : p,
                                M = t.paddingRight,
                                D = void 0 === M ? 4 : M,
                                X = t.paddingBottom,
                                H = void 0 === X ? 2 : X,
                                j = t.paddingTop,
                                U = void 0 === j ? 2 : j,
                                Q = this.w,
                                at = this.graphics.drawText({
                                    x: t.x,
                                    y: t.y,
                                    text: l,
                                    textAnchor: t.textAnchor || "start",
                                    fontSize: t.fontSize || "12px",
                                    fontWeight: t.fontWeight || "regular",
                                    fontFamily: t.fontFamily || Q.config.chart.fontFamily,
                                    foreColor: t.foreColor || Q.config.chart.foreColor,
                                    cssClass: t.cssClass
                                }),
                                it = Q.globals.dom.baseEl.querySelector(R);
                            it && it.appendChild(at.node);
                            var mt = at.bbox();
                            if (l) {
                                var yt = this.graphics.drawRect(mt.x - k, mt.y - U, mt.width + k + D, mt.height + H + U, P, w || "transparent", 1, S, T, C);
                                it.insertBefore(yt.node, at.node)
                            }
                        }
                    }, {
                        key: "addImage",
                        value: function(t, e) {
                            var i = this.w,
                                l = t.x,
                                h = void 0 === l ? 0 : l,
                                d = t.y,
                                g = void 0 === d ? 0 : d,
                                x = t.width,
                                b = void 0 === x ? 20 : x,
                                v = t.height,
                                w = void 0 === v ? 20 : v,
                                S = t.appendTo,
                                C = void 0 === S ? ".apexcharts-annotations" : S,
                                P = i.globals.dom.Paper.image(t.path);
                            P.size(b, w).move(h, g);
                            var T = i.globals.dom.baseEl.querySelector(C);
                            return T && T.appendChild(P.node), P
                        }
                    }, {
                        key: "addXaxisAnnotationExternal",
                        value: function(t, e, i) {
                            return this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "xaxis",
                                contextMethod: i.addXaxisAnnotation
                            }), i
                        }
                    }, {
                        key: "addYaxisAnnotationExternal",
                        value: function(t, e, i) {
                            return this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "yaxis",
                                contextMethod: i.addYaxisAnnotation
                            }), i
                        }
                    }, {
                        key: "addPointAnnotationExternal",
                        value: function(t, e, i) {
                            return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "point",
                                contextMethod: i.addPointAnnotation
                            }), i
                        }
                    }, {
                        key: "addAnnotationExternal",
                        value: function(t) {
                            var e = t.params,
                                i = t.pushToMemory,
                                r = t.context,
                                l = t.type,
                                h = t.contextMethod,
                                d = r,
                                g = d.w,
                                x = g.globals.dom.baseEl.querySelector(".apexcharts-".concat(l, "-annotations")),
                                b = x.childNodes.length + 1,
                                v = new Re,
                                w = Object.assign({}, "xaxis" === l ? v.xAxisAnnotation : "yaxis" === l ? v.yAxisAnnotation : v.pointAnnotation),
                                S = q.extend(w, e);
                            switch (l) {
                                case "xaxis":
                                    this.addXaxisAnnotation(S, x, b);
                                    break;
                                case "yaxis":
                                    this.addYaxisAnnotation(S, x, b);
                                    break;
                                case "point":
                                    this.addPointAnnotation(S, x, b)
                            }
                            var C = g.globals.dom.baseEl.querySelector(".apexcharts-".concat(l, "-annotations .apexcharts-").concat(l, "-annotation-label[rel='").concat(b, "']")),
                                P = this.helpers.addBackgroundToAnno(C, S);
                            return P && x.insertBefore(P.node, C), i && g.globals.memory.methodsToExec.push({
                                context: d,
                                id: S.id ? S.id : q.randomId(),
                                method: h,
                                label: "addAnnotation",
                                params: e
                            }), r
                        }
                    }, {
                        key: "clearAnnotations",
                        value: function(t) {
                            var e = t.w,
                                i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                            e.globals.memory.methodsToExec.map(function(r, l) {
                                "addText" !== r.label && "addAnnotation" !== r.label || e.globals.memory.methodsToExec.splice(l, 1)
                            }), i = q.listToArray(i), Array.prototype.forEach.call(i, function(r) {
                                for (; r.firstChild;) r.removeChild(r.firstChild)
                            })
                        }
                    }, {
                        key: "removeAnnotation",
                        value: function(t, e) {
                            var i = t.w,
                                r = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
                            r && (i.globals.memory.methodsToExec.map(function(l, h) {
                                l.id === e && i.globals.memory.methodsToExec.splice(h, 1)
                            }), Array.prototype.forEach.call(r, function(l) {
                                l.parentElement.removeChild(l)
                            }))
                        }
                    }]), _
                }(),
                ne = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
                    }
                    return ht(_, [{
                        key: "isValidDate",
                        value: function(t) {
                            return !isNaN(this.parseDate(t))
                        }
                    }, {
                        key: "getTimeStamp",
                        value: function(t) {
                            return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t
                        }
                    }, {
                        key: "getDate",
                        value: function(t) {
                            return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t)
                        }
                    }, {
                        key: "parseDate",
                        value: function(t) {
                            var e = Date.parse(t);
                            if (!isNaN(e)) return this.getTimeStamp(t);
                            var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                            return this.getTimeStamp(i)
                        }
                    }, {
                        key: "parseDateWithTimezone",
                        value: function(t) {
                            return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
                        }
                    }, {
                        key: "formatDate",
                        value: function(t, e) {
                            var i = this.w.globals.locale,
                                r = this.w.config.xaxis.labels.datetimeUTC,
                                l = ["\0"].concat(le(i.months)),
                                h = ["\x01"].concat(le(i.shortMonths)),
                                d = ["\x02"].concat(le(i.days)),
                                g = ["\x03"].concat(le(i.shortDays));

                            function x(H, j) {
                                var U = H + "";
                                for (j = j || 2; U.length < j;) U = "0" + U;
                                return U
                            }
                            var b = r ? t.getUTCFullYear() : t.getFullYear();
                            e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + b)).replace(/(^|[^\\])yy/g, "$1" + b.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + b);
                            var v = (r ? t.getUTCMonth() : t.getMonth()) + 1;
                            e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + l[0])).replace(/(^|[^\\])MMM/g, "$1" + h[0])).replace(/(^|[^\\])MM/g, "$1" + x(v))).replace(/(^|[^\\])M/g, "$1" + v);
                            var w = r ? t.getUTCDate() : t.getDate();
                            e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + d[0])).replace(/(^|[^\\])ddd/g, "$1" + g[0])).replace(/(^|[^\\])dd/g, "$1" + x(w))).replace(/(^|[^\\])d/g, "$1" + w);
                            var S = r ? t.getUTCHours() : t.getHours(),
                                C = S > 12 ? S - 12 : 0 === S ? 12 : S;
                            e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + x(S))).replace(/(^|[^\\])H/g, "$1" + S)).replace(/(^|[^\\])hh+/g, "$1" + x(C))).replace(/(^|[^\\])h/g, "$1" + C);
                            var P = r ? t.getUTCMinutes() : t.getMinutes();
                            e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + x(P))).replace(/(^|[^\\])m/g, "$1" + P);
                            var T = r ? t.getUTCSeconds() : t.getSeconds();
                            e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + x(T))).replace(/(^|[^\\])s/g, "$1" + T);
                            var I = r ? t.getUTCMilliseconds() : t.getMilliseconds();
                            e = e.replace(/(^|[^\\])fff+/g, "$1" + x(I, 3)), I = Math.round(I / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + x(I)), I = Math.round(I / 10);
                            var R = S < 12 ? "AM" : "PM";
                            e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + I)).replace(/(^|[^\\])TT+/g, "$1" + R)).replace(/(^|[^\\])T/g, "$1" + R.charAt(0));
                            var p = R.toLowerCase();
                            e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + p)).replace(/(^|[^\\])t/g, "$1" + p.charAt(0));
                            var k = -t.getTimezoneOffset(),
                                M = r || !k ? "Z" : k > 0 ? "+" : "-";
                            if (!r) {
                                var D = (k = Math.abs(k)) % 60;
                                M += x(Math.floor(k / 60)) + ":" + x(D)
                            }
                            e = e.replace(/(^|[^\\])K/g, "$1" + M);
                            var X = (r ? t.getUTCDay() : t.getDay()) + 1;
                            return (e = (e = (e = (e = e.replace(new RegExp(d[0], "g"), d[X])).replace(new RegExp(g[0], "g"), g[X])).replace(new RegExp(l[0], "g"), l[v])).replace(new RegExp(h[0], "g"), h[v])).replace(/\\(.)/g, "$1")
                        }
                    }, {
                        key: "getTimeUnitsfromTimestamp",
                        value: function(t, e, i) {
                            var r = this.w;
                            void 0 !== r.config.xaxis.min && (t = r.config.xaxis.min), void 0 !== r.config.xaxis.max && (e = r.config.xaxis.max);
                            var l = this.getDate(t),
                                h = this.getDate(e),
                                d = this.formatDate(l, "yyyy MM dd HH mm ss fff").split(" "),
                                g = this.formatDate(h, "yyyy MM dd HH mm ss fff").split(" ");
                            return {
                                minMillisecond: parseInt(d[6], 10),
                                maxMillisecond: parseInt(g[6], 10),
                                minSecond: parseInt(d[5], 10),
                                maxSecond: parseInt(g[5], 10),
                                minMinute: parseInt(d[4], 10),
                                maxMinute: parseInt(g[4], 10),
                                minHour: parseInt(d[3], 10),
                                maxHour: parseInt(g[3], 10),
                                minDate: parseInt(d[2], 10),
                                maxDate: parseInt(g[2], 10),
                                minMonth: parseInt(d[1], 10) - 1,
                                maxMonth: parseInt(g[1], 10) - 1,
                                minYear: parseInt(d[0], 10),
                                maxYear: parseInt(g[0], 10)
                            }
                        }
                    }, {
                        key: "isLeapYear",
                        value: function(t) {
                            return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
                        }
                    }, {
                        key: "calculcateLastDaysOfMonth",
                        value: function(t, e, i) {
                            return this.determineDaysOfMonths(t, e) - i
                        }
                    }, {
                        key: "determineDaysOfYear",
                        value: function(t) {
                            var e = 365;
                            return this.isLeapYear(t) && (e = 366), e
                        }
                    }, {
                        key: "determineRemainingDaysOfYear",
                        value: function(t, e, i) {
                            var r = this.daysCntOfYear[e] + i;
                            return e > 1 && this.isLeapYear() && r++, r
                        }
                    }, {
                        key: "determineDaysOfMonths",
                        value: function(t, e) {
                            var i = 30;
                            switch (t = q.monthMod(t), !0) {
                                case this.months30.indexOf(t) > -1:
                                    2 === t && (i = this.isLeapYear(e) ? 29 : 28);
                                    break;
                                case this.months31.indexOf(t) > -1:
                                default:
                                    i = 31
                            }
                            return i
                        }
                    }]), _
                }(),
                Be = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.tooltipKeyFormat = "dd MMM"
                    }
                    return ht(_, [{
                        key: "xLabelFormat",
                        value: function(t, e, i, r) {
                            var l = this.w;
                            if ("datetime" === l.config.xaxis.type && void 0 === l.config.xaxis.labels.formatter && void 0 === l.config.tooltip.x.formatter) {
                                var h = new ne(this.ctx);
                                return h.formatDate(h.getDate(e), l.config.tooltip.x.format)
                            }
                            return t(e, i, r)
                        }
                    }, {
                        key: "defaultGeneralFormatter",
                        value: function(t) {
                            return Array.isArray(t) ? t.map(function(e) {
                                return e
                            }) : t
                        }
                    }, {
                        key: "defaultYFormatter",
                        value: function(t, e, i) {
                            var r = this.w;
                            return q.isNumber(t) && (t = t.toFixed(0 !== r.globals.yValueDecimal ? void 0 !== e.decimalsInFloat ? e.decimalsInFloat : r.globals.yValueDecimal : r.globals.maxYArr[i] - r.globals.minYArr[i] < 5 ? 1 : 0)), t
                        }
                    }, {
                        key: "setLabelFormatters",
                        value: function() {
                            var t = this,
                                e = this.w;
                            return e.globals.xaxisTooltipFormatter = function(i) {
                                return t.defaultGeneralFormatter(i)
                            }, e.globals.ttKeyFormatter = function(i) {
                                return t.defaultGeneralFormatter(i)
                            }, e.globals.ttZFormatter = function(i) {
                                return i
                            }, e.globals.legendFormatter = function(i) {
                                return t.defaultGeneralFormatter(i)
                            }, e.globals.xLabelFormatter = void 0 !== e.config.xaxis.labels.formatter ? e.config.xaxis.labels.formatter : function(i) {
                                if (q.isNumber(i)) {
                                    if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type) {
                                        if (q.isNumber(e.config.xaxis.decimalsInFloat)) return i.toFixed(e.config.xaxis.decimalsInFloat);
                                        var r = e.globals.maxX - e.globals.minX;
                                        return i.toFixed(r > 0 && r < 100 ? 1 : 0)
                                    }
                                    return i.toFixed(e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4 ? 1 : 0)
                                }
                                return i
                            }, e.globals.ttKeyFormatter = "function" == typeof e.config.tooltip.x.formatter ? e.config.tooltip.x.formatter : e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(function(i, r) {
                                e.globals.yLabelFormatters[r] = void 0 !== i.labels.formatter ? i.labels.formatter : function(l) {
                                    return e.globals.xyCharts ? Array.isArray(l) ? l.map(function(h) {
                                        return t.defaultYFormatter(h, i, r)
                                    }) : t.defaultYFormatter(l, i, r) : l
                                }
                            }), e.globals
                        }
                    }, {
                        key: "heatmapLabelFormatters",
                        value: function() {
                            var t = this.w;
                            if ("heatmap" === t.config.chart.type) {
                                t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
                                var e = t.globals.seriesNames.reduce(function(i, r) {
                                    return i.length > r.length ? i : r
                                }, 0);
                                t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e
                            }
                        }
                    }]), _
                }(),
                di = function(_) {
                    var t, e = _.isTimeline,
                        i = _.ctx,
                        r = _.seriesIndex,
                        l = _.dataPointIndex,
                        h = _.y1,
                        d = _.y2,
                        g = _.w,
                        x = g.globals.seriesRangeStart[r][l],
                        b = g.globals.seriesRangeEnd[r][l],
                        v = g.globals.labels[l],
                        w = g.config.series[r].name ? g.config.series[r].name : "",
                        S = g.globals.ttKeyFormatter,
                        C = g.config.tooltip.y.title.formatter,
                        P = {
                            w: g,
                            seriesIndex: r,
                            dataPointIndex: l,
                            start: x,
                            end: b
                        };
                    "function" == typeof C && (w = C(w, P)), null !== (t = g.config.series[r].data[l]) && void 0 !== t && t.x && (v = g.config.series[r].data[l].x), e || "datetime" === g.config.xaxis.type && (v = new Be(i).xLabelFormat(g.globals.ttKeyFormatter, v, v, {
                        i: void 0,
                        dateFormatter: new ne(i).formatDate,
                        w: g
                    })), "function" == typeof S && (v = S(v, P)), Number.isFinite(h) && Number.isFinite(d) && (x = h, b = d);
                    var T = "",
                        I = "",
                        R = g.globals.colors[r];
                    if (void 0 === g.config.tooltip.x.formatter)
                        if ("datetime" === g.config.xaxis.type) {
                            var p = new ne(i);
                            T = p.formatDate(p.getDate(x), g.config.tooltip.x.format), I = p.formatDate(p.getDate(b), g.config.tooltip.x.format)
                        } else T = x, I = b;
                    else T = g.config.tooltip.x.formatter(x), I = g.config.tooltip.x.formatter(b);
                    return {
                        start: x,
                        end: b,
                        startVal: T,
                        endVal: I,
                        ylabel: v,
                        color: R,
                        seriesName: w
                    }
                },
                ui = function(_) {
                    var t = _.color,
                        e = _.seriesName,
                        i = _.ylabel,
                        r = _.start,
                        l = _.end,
                        h = _.seriesIndex,
                        d = _.dataPointIndex,
                        g = _.ctx.tooltip.tooltipLabels.getFormatters(h);
                    r = g.yLbFormatter(r), l = g.yLbFormatter(l);
                    var x = g.yLbFormatter(_.w.globals.series[h][d]),
                        b = '<span class="value start-value">\n  '.concat(r, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(l, "\n  </span>");
                    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (e || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (_.w.globals.comboCharts ? "rangeArea" === _.w.config.series[h].type || "rangeBar" === _.w.config.series[h].type ? b : "<span>".concat(x, "</span>") : b) + " </div></div>"
                },
                Ze = function() {
                    function _(t) {
                        xt(this, _), this.opts = t
                    }
                    return ht(_, [{
                        key: "hideYAxis",
                        value: function() {
                            this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0
                        }
                    }, {
                        key: "line",
                        value: function() {
                            return {
                                chart: {
                                    animations: {
                                        easing: "swing"
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                stroke: {
                                    width: 5,
                                    curve: "straight"
                                },
                                markers: {
                                    size: 0,
                                    hover: {
                                        sizeOffset: 6
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "sparkline",
                        value: function(t) {
                            return this.hideYAxis(), q.extend(t, {
                                grid: {
                                    show: !1,
                                    padding: {
                                        left: 0,
                                        right: 0,
                                        top: 0,
                                        bottom: 0
                                    }
                                },
                                legend: {
                                    show: !1
                                },
                                xaxis: {
                                    labels: {
                                        show: !1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    axisBorder: {
                                        show: !1
                                    },
                                    axisTicks: {
                                        show: !1
                                    }
                                },
                                chart: {
                                    toolbar: {
                                        show: !1
                                    },
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                }
                            })
                        }
                    }, {
                        key: "bar",
                        value: function() {
                            return {
                                chart: {
                                    stacked: !1,
                                    animations: {
                                        easing: "swing"
                                    }
                                },
                                plotOptions: {
                                    bar: {
                                        dataLabels: {
                                            position: "center"
                                        }
                                    }
                                },
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    }
                                },
                                stroke: {
                                    width: 0,
                                    lineCap: "round"
                                },
                                fill: {
                                    opacity: .85
                                },
                                legend: {
                                    markers: {
                                        shape: "square",
                                        radius: 2,
                                        size: 8
                                    }
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                xaxis: {
                                    tooltip: {
                                        enabled: !1
                                    },
                                    tickPlacement: "between",
                                    crosshairs: {
                                        width: "barWidth",
                                        position: "back",
                                        fill: {
                                            type: "gradient"
                                        },
                                        dropShadow: {
                                            enabled: !1
                                        },
                                        stroke: {
                                            width: 0
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "funnel",
                        value: function() {
                            return this.hideYAxis(), ut(ut({}, this.bar()), {}, {
                                chart: {
                                    animations: {
                                        easing: "linear",
                                        speed: 800,
                                        animateGradually: {
                                            enabled: !1
                                        }
                                    }
                                },
                                plotOptions: {
                                    bar: {
                                        horizontal: !0,
                                        borderRadiusApplication: "around",
                                        borderRadius: 0,
                                        dataLabels: {
                                            position: "center"
                                        }
                                    }
                                },
                                grid: {
                                    show: !1,
                                    padding: {
                                        left: 0,
                                        right: 0
                                    }
                                },
                                xaxis: {
                                    labels: {
                                        show: !1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    axisBorder: {
                                        show: !1
                                    },
                                    axisTicks: {
                                        show: !1
                                    }
                                }
                            })
                        }
                    }, {
                        key: "candlestick",
                        value: function() {
                            var t = this;
                            return {
                                stroke: {
                                    width: 1,
                                    colors: ["#333"]
                                },
                                fill: {
                                    opacity: 1
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !0,
                                    custom: function(e) {
                                        return t._getBoxTooltip(e.w, e.seriesIndex, e.dataPointIndex, ["Open", "High", "", "Low", "Close"], "candlestick")
                                    }
                                },
                                states: {
                                    active: {
                                        filter: {
                                            type: "none"
                                        }
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "boxPlot",
                        value: function() {
                            var t = this;
                            return {
                                chart: {
                                    animations: {
                                        dynamicAnimation: {
                                            enabled: !1
                                        }
                                    }
                                },
                                stroke: {
                                    width: 1,
                                    colors: ["#24292e"]
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !0,
                                    custom: function(e) {
                                        return t._getBoxTooltip(e.w, e.seriesIndex, e.dataPointIndex, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                                    }
                                },
                                markers: {
                                    size: 5,
                                    strokeWidth: 1,
                                    strokeColors: "#111"
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "rangeBar",
                        value: function() {
                            return {
                                chart: {
                                    animations: {
                                        animateGradually: !1
                                    }
                                },
                                stroke: {
                                    width: 0,
                                    lineCap: "square"
                                },
                                plotOptions: {
                                    bar: {
                                        borderRadius: 0,
                                        dataLabels: {
                                            position: "center"
                                        }
                                    }
                                },
                                dataLabels: {
                                    enabled: !1,
                                    formatter: function(t, e) {
                                        var i = e.seriesIndex,
                                            r = e.dataPointIndex,
                                            l = e.w,
                                            h = function() {
                                                return l.globals.seriesRangeEnd[i][r] - l.globals.seriesRangeStart[i][r]
                                            };
                                        return l.globals.comboCharts ? "rangeBar" === l.config.series[i].type || "rangeArea" === l.config.series[i].type ? h() : t : h()
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                markers: {
                                    size: 10
                                },
                                tooltip: {
                                    shared: !1,
                                    followCursor: !0,
                                    custom: function(t) {
                                        return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? (r = (i = di(ut(ut({}, e = t), {}, {
                                            isTimeline: !0
                                        }))).color, l = i.seriesName, h = i.ylabel, d = i.startVal, g = i.endVal, ui(ut(ut({}, e), {}, {
                                            color: r,
                                            seriesName: l,
                                            ylabel: h,
                                            start: d,
                                            end: g
                                        }))) : function(e) {
                                            var i = di(e),
                                                r = i.color,
                                                l = i.seriesName,
                                                h = i.ylabel,
                                                d = i.start,
                                                g = i.end;
                                            return ui(ut(ut({}, e), {}, {
                                                color: r,
                                                seriesName: l,
                                                ylabel: h,
                                                start: d,
                                                end: g
                                            }))
                                        }(t);
                                        var e, i, r, l, h, d, g
                                    }
                                },
                                xaxis: {
                                    tickPlacement: "between",
                                    tooltip: {
                                        enabled: !1
                                    },
                                    crosshairs: {
                                        stroke: {
                                            width: 0
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "dumbbell",
                        value: function(t) {
                            var e, i;
                            return null !== (e = t.plotOptions.bar) && void 0 !== e && e.barHeight || (t.plotOptions.bar.barHeight = 2), null !== (i = t.plotOptions.bar) && void 0 !== i && i.columnWidth || (t.plotOptions.bar.columnWidth = 2), t
                        }
                    }, {
                        key: "area",
                        value: function() {
                            return {
                                stroke: {
                                    width: 4,
                                    fill: {
                                        type: "solid",
                                        gradient: {
                                            inverseColors: !1,
                                            shade: "light",
                                            type: "vertical",
                                            opacityFrom: .65,
                                            opacityTo: .5,
                                            stops: [0, 100, 100]
                                        }
                                    }
                                },
                                fill: {
                                    type: "gradient",
                                    gradient: {
                                        inverseColors: !1,
                                        shade: "light",
                                        type: "vertical",
                                        opacityFrom: .65,
                                        opacityTo: .5,
                                        stops: [0, 100, 100]
                                    }
                                },
                                markers: {
                                    size: 0,
                                    hover: {
                                        sizeOffset: 6
                                    }
                                },
                                tooltip: {
                                    followCursor: !1
                                }
                            }
                        }
                    }, {
                        key: "rangeArea",
                        value: function() {
                            return {
                                stroke: {
                                    curve: "straight",
                                    width: 0
                                },
                                fill: {
                                    type: "solid",
                                    opacity: .6
                                },
                                markers: {
                                    size: 0
                                },
                                states: {
                                    hover: {
                                        filter: {
                                            type: "none"
                                        }
                                    },
                                    active: {
                                        filter: {
                                            type: "none"
                                        }
                                    }
                                },
                                tooltip: {
                                    intersect: !1,
                                    shared: !0,
                                    followCursor: !0,
                                    custom: function(t) {
                                        return r = (i = di(e = t)).color, l = i.seriesName, h = i.ylabel, d = i.start, g = i.end, ui(ut(ut({}, e), {}, {
                                            color: r,
                                            seriesName: l,
                                            ylabel: h,
                                            start: d,
                                            end: g
                                        }));
                                        var e, i, r, l, h, d, g
                                    }
                                }
                            }
                        }
                    }, {
                        key: "brush",
                        value: function(t) {
                            return q.extend(t, {
                                chart: {
                                    toolbar: {
                                        autoSelected: "selection",
                                        show: !1
                                    },
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                stroke: {
                                    width: 1
                                },
                                tooltip: {
                                    enabled: !1
                                },
                                xaxis: {
                                    tooltip: {
                                        enabled: !1
                                    }
                                }
                            })
                        }
                    }, {
                        key: "stacked100",
                        value: function(t) {
                            t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
                            var e = t.dataLabels.formatter;
                            return t.yaxis.forEach(function(i, r) {
                                t.yaxis[r].min = 0, t.yaxis[r].max = 100
                            }), "bar" === t.chart.type && (t.dataLabels.formatter = e || function(i) {
                                return "number" == typeof i && i ? i.toFixed(0) + "%" : i
                            }), t
                        }
                    }, {
                        key: "stackedBars",
                        value: function() {
                            var t = this.bar();
                            return ut(ut({}, t), {}, {
                                plotOptions: ut(ut({}, t.plotOptions), {}, {
                                    bar: ut(ut({}, t.plotOptions.bar), {}, {
                                        borderRadiusApplication: "end",
                                        borderRadiusWhenStacked: "last"
                                    })
                                })
                            })
                        }
                    }, {
                        key: "convertCatToNumeric",
                        value: function(t) {
                            return t.xaxis.convertedCatToNumeric = !0, t
                        }
                    }, {
                        key: "convertCatToNumericXaxis",
                        value: function(t, e, i) {
                            t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(h) {
                                return q.isNumber(h) ? Math.floor(h) : h
                            };
                            var r = t.xaxis.labels.formatter,
                                l = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
                            return i && i.length && (l = i.map(function(h) {
                                return Array.isArray(h) ? h : String(h)
                            })), l && l.length && (t.xaxis.labels.formatter = function(h) {
                                return q.isNumber(h) ? r(l[Math.floor(h) - 1]) : r(h)
                            }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t
                        }
                    }, {
                        key: "bubble",
                        value: function() {
                            return {
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 0
                                    }
                                },
                                fill: {
                                    type: "solid",
                                    gradient: {
                                        shade: "light",
                                        inverse: !0,
                                        shadeIntensity: .55,
                                        opacityFrom: .4,
                                        opacityTo: .8
                                    }
                                }
                            }
                        }
                    }, {
                        key: "scatter",
                        value: function() {
                            return {
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                markers: {
                                    size: 6,
                                    strokeWidth: 1,
                                    hover: {
                                        sizeOffset: 2
                                    }
                                }
                            }
                        }
                    }, {
                        key: "heatmap",
                        value: function() {
                            return {
                                chart: {
                                    stacked: !1
                                },
                                fill: {
                                    opacity: 1
                                },
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                tooltip: {
                                    followCursor: !0,
                                    marker: {
                                        show: !1
                                    },
                                    x: {
                                        show: !1
                                    }
                                },
                                legend: {
                                    position: "top",
                                    markers: {
                                        shape: "square",
                                        size: 10,
                                        offsetY: 2
                                    }
                                },
                                grid: {
                                    padding: {
                                        right: 20
                                    }
                                }
                            }
                        }
                    }, {
                        key: "treemap",
                        value: function() {
                            return {
                                chart: {
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    style: {
                                        fontSize: 14,
                                        fontWeight: 600,
                                        colors: ["#fff"]
                                    }
                                },
                                stroke: {
                                    show: !0,
                                    width: 2,
                                    colors: ["#fff"]
                                },
                                legend: {
                                    show: !1
                                },
                                fill: {
                                    gradient: {
                                        stops: [0, 100]
                                    }
                                },
                                tooltip: {
                                    followCursor: !0,
                                    x: {
                                        show: !1
                                    }
                                },
                                grid: {
                                    padding: {
                                        left: 0,
                                        right: 0
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        show: !1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "pie",
                        value: function() {
                            return {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                plotOptions: {
                                    pie: {
                                        donut: {
                                            labels: {
                                                show: !1
                                            }
                                        }
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    dropShadow: {
                                        enabled: !0
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                fill: {
                                    opacity: 1,
                                    gradient: {
                                        shade: "light",
                                        stops: [0, 100]
                                    }
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "donut",
                        value: function() {
                            return {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    dropShadow: {
                                        enabled: !0
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                fill: {
                                    opacity: 1,
                                    gradient: {
                                        shade: "light",
                                        shadeIntensity: .35,
                                        stops: [80, 100],
                                        opacityFrom: 1,
                                        opacityTo: 1
                                    }
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "polarArea",
                        value: function() {
                            return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    enabled: !1
                                },
                                stroke: {
                                    show: !0,
                                    width: 2
                                },
                                fill: {
                                    opacity: .7
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "radar",
                        value: function() {
                            return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
                                dataLabels: {
                                    enabled: !1,
                                    style: {
                                        fontSize: "11px"
                                    }
                                },
                                stroke: {
                                    width: 2
                                },
                                markers: {
                                    size: 3,
                                    strokeWidth: 1,
                                    strokeOpacity: 1
                                },
                                fill: {
                                    opacity: .2
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0,
                                    followCursor: !0
                                },
                                grid: {
                                    show: !1
                                },
                                xaxis: {
                                    labels: {
                                        formatter: function(t) {
                                            return t
                                        },
                                        style: {
                                            colors: ["#a8a8a8"],
                                            fontSize: "11px"
                                        }
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    crosshairs: {
                                        show: !1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "radialBar",
                        value: function() {
                            return {
                                chart: {
                                    animations: {
                                        dynamicAnimation: {
                                            enabled: !0,
                                            speed: 800
                                        }
                                    },
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                fill: {
                                    gradient: {
                                        shade: "dark",
                                        shadeIntensity: .4,
                                        inverseColors: !1,
                                        type: "diagonal2",
                                        opacityFrom: 1,
                                        opacityTo: 1,
                                        stops: [70, 98, 100]
                                    }
                                },
                                legend: {
                                    show: !1,
                                    position: "right"
                                },
                                tooltip: {
                                    enabled: !1,
                                    fillSeriesColor: !0
                                }
                            }
                        }
                    }, {
                        key: "_getBoxTooltip",
                        value: function(t, e, i, r, l) {
                            var h = t.globals.seriesCandleO[e][i],
                                d = t.globals.seriesCandleH[e][i],
                                g = t.globals.seriesCandleM[e][i],
                                x = t.globals.seriesCandleL[e][i],
                                b = t.globals.seriesCandleC[e][i];
                            return t.config.series[e].type && t.config.series[e].type !== l ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name ? t.config.series[e].name : "series-" + (e + 1), ": <strong>").concat(t.globals.series[e][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(r[0], ': <span class="value">') + h + "</span></div>" + "<div>".concat(r[1], ': <span class="value">') + d + "</span></div>" + (g ? "<div>".concat(r[2], ': <span class="value">') + g + "</span></div>" : "") + "<div>".concat(r[3], ': <span class="value">') + x + "</span></div>" + "<div>".concat(r[4], ': <span class="value">') + b + "</span></div></div>"
                        }
                    }]), _
                }(),
                Pe = function() {
                    function _(t) {
                        xt(this, _), this.opts = t
                    }
                    return ht(_, [{
                        key: "init",
                        value: function(t) {
                            var e = t.responsiveOverride,
                                i = this.opts,
                                r = new Re,
                                l = new Ze(i);
                            this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
                            var h = r.init(),
                                d = {};
                            if (i && "object" === Zt(i)) {
                                var g, x, b, v, w, S, C, P, T, I, R = {};
                                R = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? l[i.chart.type]() : l.line(), null !== (g = i.plotOptions) && void 0 !== g && null !== (x = g.bar) && void 0 !== x && x.isFunnel && (R = l.funnel()), i.chart.stacked && "bar" === i.chart.type && (R = l.stackedBars()), null !== (b = i.chart.brush) && void 0 !== b && b.enabled && (R = l.brush(R)), i.chart.stacked && "100%" === i.chart.stackType && (i = l.stacked100(i)), null !== (v = i.plotOptions) && void 0 !== v && null !== (w = v.bar) && void 0 !== w && w.isDumbbell && (i = l.dumbbell(i)), "monotoneCubic" === (null === (S = i) || void 0 === S || null === (C = S.stroke) || void 0 === C ? void 0 : C.curve) && (i.stroke.curve = "smooth"), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, e || (i.xaxis.convertedCatToNumeric = !1), (null !== (P = (i = this.checkForCatToNumericXAxis(this.chartType, R, i)).chart.sparkline) && void 0 !== P && P.enabled || null !== (T = window.Apex.chart) && void 0 !== T && null !== (I = T.sparkline) && void 0 !== I && I.enabled) && (R = l.sparkline(R)), d = q.extend(h, R)
                            }
                            var p = q.extend(d, window.Apex);
                            return h = q.extend(p, i), this.handleUserInputErrors(h)
                        }
                    }, {
                        key: "checkForCatToNumericXAxis",
                        value: function(t, e, i) {
                            var r, l, h = new Ze(i);
                            return ("bar" === t || "boxPlot" === t) && (null === (r = i.plotOptions) || void 0 === r || null === (l = r.bar) || void 0 === l ? void 0 : l.horizontal) || "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t || !("datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type) || "between" === (i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement) || (i = h.convertCatToNumeric(i)), i
                        }
                    }, {
                        key: "extendYAxis",
                        value: function(t, e) {
                            var i = new Re;
                            (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = q.extend(t.yaxis, window.Apex.yaxis)), t.yaxis = t.yaxis.constructor !== Array ? [q.extend(i.yAxis, t.yaxis)] : q.extendArray(t.yaxis, i.yAxis);
                            var r = !1;
                            t.yaxis.forEach(function(h) {
                                h.logarithmic && (r = !0)
                            });
                            var l = t.series;
                            return e && !l && (l = e.config.series), r && l.length !== t.yaxis.length && l.length && (t.yaxis = l.map(function(h, d) {
                                if (h.name || (l[d].name = "series-".concat(d + 1)), t.yaxis[d]) return t.yaxis[d].seriesName = l[d].name, t.yaxis[d];
                                var g = q.extend(i.yAxis, t.yaxis[0]);
                                return g.show = !1, g
                            })), r && l.length > 1 && l.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t
                        }
                    }, {
                        key: "extendAnnotations",
                        value: function(t) {
                            return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), this.extendPointAnnotations(t)
                        }
                    }, {
                        key: "extendYAxisAnnotations",
                        value: function(t) {
                            var e = new Re;
                            return t.annotations.yaxis = q.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t
                        }
                    }, {
                        key: "extendXAxisAnnotations",
                        value: function(t) {
                            var e = new Re;
                            return t.annotations.xaxis = q.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t
                        }
                    }, {
                        key: "extendPointAnnotations",
                        value: function(t) {
                            var e = new Re;
                            return t.annotations.points = q.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t
                        }
                    }, {
                        key: "checkForDarkTheme",
                        value: function(t) {
                            t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"))
                        }
                    }, {
                        key: "handleUserInputErrors",
                        value: function(t) {
                            var e = t;
                            if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                            if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
                                if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                                e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1
                            }
                            return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && "barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (e.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e.chart.type && "boxPlot" !== e.chart.type || e.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")), e.yaxis[0].reversed = !1), e
                        }
                    }]), _
                }(),
                Hi = function() {
                    function _() {
                        xt(this, _)
                    }
                    return ht(_, [{
                        key: "initGlobalVars",
                        value: function(t) {
                            t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRange = [], t.seriesPercent = [], t.seriesGoals = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.hasXaxisGroups = !1, t.groups = [], t.hasSeriesGroups = !1, t.seriesGroups = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0
                        }
                    }, {
                        key: "globalVars",
                        value: function(t) {
                            return {
                                chartID: null,
                                cuid: null,
                                events: {
                                    beforeMount: [],
                                    mounted: [],
                                    updated: [],
                                    clicked: [],
                                    selection: [],
                                    dataPointSelection: [],
                                    zoomed: [],
                                    scrolled: []
                                },
                                colors: [],
                                clientX: null,
                                clientY: null,
                                fill: {
                                    colors: []
                                },
                                stroke: {
                                    colors: []
                                },
                                dataLabels: {
                                    style: {
                                        colors: []
                                    }
                                },
                                radarPolygons: {
                                    fill: {
                                        colors: []
                                    }
                                },
                                markers: {
                                    colors: [],
                                    size: t.markers.size,
                                    largestSize: 0
                                },
                                animationEnded: !1,
                                isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                                isDirty: !1,
                                isExecCalled: !1,
                                initialConfig: null,
                                initialSeries: [],
                                lastXAxis: [],
                                lastYAxis: [],
                                columnSeries: null,
                                labels: [],
                                timescaleLabels: [],
                                noLabelsProvided: !1,
                                allSeriesCollapsed: !1,
                                collapsedSeries: [],
                                collapsedSeriesIndices: [],
                                ancillaryCollapsedSeries: [],
                                ancillaryCollapsedSeriesIndices: [],
                                risingSeries: [],
                                dataFormatXNumeric: !1,
                                capturedSeriesIndex: -1,
                                capturedDataPointIndex: -1,
                                selectedDataPoints: [],
                                goldenPadding: 35,
                                invalidLogScale: !1,
                                ignoreYAxisIndexes: [],
                                yAxisSameScaleIndices: [],
                                maxValsInArrayIndex: 0,
                                radialSize: 0,
                                selection: void 0,
                                zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
                                panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
                                selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
                                yaxis: null,
                                mousedown: !1,
                                lastClientPosition: {},
                                visibleXRange: void 0,
                                yValueDecimal: 0,
                                total: 0,
                                SVGNS: "http://www.w3.org/2000/svg",
                                svgWidth: 0,
                                svgHeight: 0,
                                noData: !1,
                                locale: {},
                                dom: {},
                                memory: {
                                    methodsToExec: []
                                },
                                shouldAnimate: !0,
                                skipLastTimelinelabel: !1,
                                skipFirstTimelinelabel: !1,
                                delayedElements: [],
                                axisCharts: !0,
                                isDataXYZ: !1,
                                resized: !1,
                                resizeTimer: null,
                                comboCharts: !1,
                                dataChanged: !1,
                                previousPaths: [],
                                allSeriesHasEqualX: !0,
                                pointsArray: [],
                                dataLabelsRects: [],
                                lastDrawnDataLabelsIndexes: [],
                                hasNullValues: !1,
                                easing: null,
                                zoomed: !1,
                                gridWidth: 0,
                                gridHeight: 0,
                                rotateXLabels: !1,
                                defaultLabels: !1,
                                xLabelFormatter: void 0,
                                yLabelFormatters: [],
                                xaxisTooltipFormatter: void 0,
                                ttKeyFormatter: void 0,
                                ttVal: void 0,
                                ttZFormatter: void 0,
                                LINE_HEIGHT_RATIO: 1.618,
                                xAxisLabelsHeight: 0,
                                xAxisGroupLabelsHeight: 0,
                                xAxisLabelsWidth: 0,
                                yAxisLabelsWidth: 0,
                                scaleX: 1,
                                scaleY: 1,
                                translateX: 0,
                                translateY: 0,
                                translateYAxisX: [],
                                yAxisWidths: [],
                                translateXAxisY: 0,
                                translateXAxisX: 0,
                                tooltip: null
                            }
                        }
                    }, {
                        key: "init",
                        value: function(t) {
                            var e = this.globalVars(t);
                            return this.initGlobalVars(e), e.initialConfig = q.extend({}, t), e.initialSeries = q.clone(t.series), e.lastXAxis = q.clone(e.initialConfig.xaxis), e.lastYAxis = q.clone(e.initialConfig.yaxis), e
                        }
                    }]), _
                }(),
                Yi = function() {
                    function _(t) {
                        xt(this, _), this.opts = t
                    }
                    return ht(_, [{
                        key: "init",
                        value: function() {
                            var t = new Pe(this.opts).init({
                                responsiveOverride: !1
                            });
                            return {
                                config: t,
                                globals: (new Hi).init(t)
                            }
                        }
                    }]), _
                }(),
                ce = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.opts = null, this.seriesIndex = 0
                    }
                    return ht(_, [{
                        key: "clippedImgArea",
                        value: function(t) {
                            var e = this.w,
                                i = e.config,
                                r = parseInt(e.globals.gridWidth, 10),
                                l = parseInt(e.globals.gridHeight, 10),
                                h = r > l ? r : l,
                                d = t.image,
                                g = 0,
                                x = 0;
                            void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (g = i.fill.image.width + 1, x = i.fill.image.height) : (g = h + 1, x = h) : (g = t.width, x = t.height);
                            var b = document.createElementNS(e.globals.SVGNS, "pattern");
                            ot.setAttrs(b, {
                                id: t.patternID,
                                patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
                                width: g + "px",
                                height: x + "px"
                            });
                            var v = document.createElementNS(e.globals.SVGNS, "image");
                            b.appendChild(v), v.setAttributeNS(window.SVG.xlink, "href", d), ot.setAttrs(v, {
                                x: 0,
                                y: 0,
                                preserveAspectRatio: "none",
                                width: g + "px",
                                height: x + "px"
                            }), v.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(b)
                        }
                    }, {
                        key: "getSeriesIndex",
                        value: function(t) {
                            var e = this.w,
                                i = e.config.chart.type;
                            return this.seriesIndex = ("bar" === i || "rangeBar" === i) && e.config.plotOptions.bar.distributed || "heatmap" === i || "treemap" === i ? t.seriesNumber : t.seriesNumber % e.globals.series.length, this.seriesIndex
                        }
                    }, {
                        key: "fillPath",
                        value: function(t) {
                            var e = this.w;
                            this.opts = t;
                            var i, r, l, h = this.w.config;
                            this.seriesIndex = this.getSeriesIndex(t);
                            var d = this.getFillColors()[this.seriesIndex];
                            void 0 !== e.globals.seriesColors[this.seriesIndex] && (d = e.globals.seriesColors[this.seriesIndex]), "function" == typeof d && (d = d({
                                seriesIndex: this.seriesIndex,
                                dataPointIndex: t.dataPointIndex,
                                value: t.value,
                                w: e
                            }));
                            var g = t.fillType ? t.fillType : this.getFillType(this.seriesIndex),
                                x = Array.isArray(h.fill.opacity) ? h.fill.opacity[this.seriesIndex] : h.fill.opacity;
                            t.color && (d = t.color), d || (d = "#fff", console.warn("undefined color - ApexCharts"));
                            var b = d;
                            if (-1 === d.indexOf("rgb") ? d.length < 9 && (b = q.hexToRgba(d, x)) : d.indexOf("rgba") > -1 && (x = q.getOpacityFromRGBA(d)), t.opacity && (x = t.opacity), "pattern" === g && (r = this.handlePatternFill({
                                    fillConfig: t.fillConfig,
                                    patternFill: r,
                                    fillColor: d,
                                    fillOpacity: x,
                                    defaultColor: b
                                })), "gradient" === g && (l = this.handleGradientFill({
                                    fillConfig: t.fillConfig,
                                    fillColor: d,
                                    fillOpacity: x,
                                    i: this.seriesIndex
                                })), "image" === g) {
                                var v = h.fill.image.src,
                                    w = t.patternID ? t.patternID : "";
                                this.clippedImgArea({
                                    opacity: x,
                                    image: Array.isArray(v) ? t.seriesNumber < v.length ? v[t.seriesNumber] : v[0] : v,
                                    width: t.width ? t.width : void 0,
                                    height: t.height ? t.height : void 0,
                                    patternUnits: t.patternUnits,
                                    patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(w)
                                }), i = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(w, ")")
                            } else i = "gradient" === g ? l : "pattern" === g ? r : b;
                            return t.solid && (i = b), i
                        }
                    }, {
                        key: "getFillType",
                        value: function(t) {
                            var e = this.w;
                            return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type
                        }
                    }, {
                        key: "getFillColors",
                        value: function() {
                            var t = this.w,
                                e = t.config,
                                i = this.opts,
                                r = [];
                            return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? r = t.globals.stroke.colors : r.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? r = t.globals.fill.colors : r.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? r = t.globals.stroke.colors : r.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? r = t.globals.fill.colors : r.push(t.globals.fill.colors), void 0 !== i.fillColors && (r = [], Array.isArray(i.fillColors) ? r = i.fillColors.slice() : r.push(i.fillColors)), r
                        }
                    }, {
                        key: "handlePatternFill",
                        value: function(t) {
                            var e = t.fillConfig,
                                r = t.fillColor,
                                l = t.fillOpacity,
                                h = t.defaultColor,
                                d = this.w.config.fill;
                            e && (d = e);
                            var g = this.opts,
                                x = new ot(this.ctx),
                                b = Array.isArray(d.pattern.strokeWidth) ? d.pattern.strokeWidth[this.seriesIndex] : d.pattern.strokeWidth,
                                v = r;
                            return Array.isArray(d.pattern.style) ? void 0 !== d.pattern.style[g.seriesNumber] ? x.drawPattern(d.pattern.style[g.seriesNumber], d.pattern.width, d.pattern.height, v, b, l) : h : x.drawPattern(d.pattern.style, d.pattern.width, d.pattern.height, v, b, l)
                        }
                    }, {
                        key: "handleGradientFill",
                        value: function(t) {
                            var e = t.fillColor,
                                i = t.fillOpacity,
                                r = t.fillConfig,
                                l = t.i,
                                h = this.w.config.fill;
                            r && (h = ut(ut({}, h), r));
                            var d, g = this.opts,
                                x = new ot(this.ctx),
                                b = new q,
                                v = h.gradient.type,
                                w = e,
                                S = void 0 === h.gradient.opacityFrom ? i : Array.isArray(h.gradient.opacityFrom) ? h.gradient.opacityFrom[l] : h.gradient.opacityFrom;
                            w.indexOf("rgba") > -1 && (S = q.getOpacityFromRGBA(w));
                            var C = void 0 === h.gradient.opacityTo ? i : Array.isArray(h.gradient.opacityTo) ? h.gradient.opacityTo[l] : h.gradient.opacityTo;
                            if (void 0 === h.gradient.gradientToColors || 0 === h.gradient.gradientToColors.length) d = b.shadeColor("dark" === h.gradient.shade ? -1 * parseFloat(h.gradient.shadeIntensity) : parseFloat(h.gradient.shadeIntensity), e.indexOf("rgb") > -1 ? q.rgb2hex(e) : e);
                            else if (h.gradient.gradientToColors[g.seriesNumber]) {
                                var P = h.gradient.gradientToColors[g.seriesNumber];
                                d = P, P.indexOf("rgba") > -1 && (C = q.getOpacityFromRGBA(P))
                            } else d = e;
                            if (h.gradient.gradientFrom && (w = h.gradient.gradientFrom), h.gradient.gradientTo && (d = h.gradient.gradientTo), h.gradient.inverseColors) {
                                var T = w;
                                w = d, d = T
                            }
                            return w.indexOf("rgb") > -1 && (w = q.rgb2hex(w)), d.indexOf("rgb") > -1 && (d = q.rgb2hex(d)), x.drawGradient(v, w, d, S, C, g.size, h.gradient.stops, h.gradient.colorStops, l)
                        }
                    }]), _
                }(),
                gi = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "setGlobalMarkerSize",
                        value: function() {
                            var t = this.w;
                            if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
                                if (t.globals.markers.size.length < t.globals.series.length + 1)
                                    for (var e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0])
                            } else t.globals.markers.size = t.config.series.map(function(i) {
                                return t.config.markers.size
                            })
                        }
                    }, {
                        key: "plotChartMarkers",
                        value: function(t, e, i, r) {
                            var l, h = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                                d = this.w,
                                g = e,
                                x = t,
                                b = null,
                                v = new ot(this.ctx),
                                w = d.config.markers.discrete && d.config.markers.discrete.length;
                            if ((d.globals.markers.size[e] > 0 || h || w) && (b = v.group({
                                    class: h || w ? "" : "apexcharts-series-markers"
                                })).attr("clip-path", "url(#gridRectMarkerMask".concat(d.globals.cuid, ")")), Array.isArray(x.x))
                                for (var S = 0; S < x.x.length; S++) {
                                    var C = i;
                                    1 === i && 0 === S && (C = 0), 1 === i && 1 === S && (C = 1);
                                    var P = "apexcharts-marker";
                                    if ("line" !== d.config.chart.type && "area" !== d.config.chart.type || d.globals.comboCharts || d.config.tooltip.intersect || (P += " no-pointer-events"), (Array.isArray(d.config.markers.size) ? d.globals.markers.size[e] > 0 : d.config.markers.size > 0) || h || w) {
                                        q.isNumber(x.y[S]) ? P += " w".concat(q.randomId()) : P = "apexcharts-nullpoint";
                                        var T = this.getMarkerConfig({
                                            cssClass: P,
                                            seriesIndex: e,
                                            dataPointIndex: C
                                        });
                                        d.config.series[g].data[C] && (d.config.series[g].data[C].fillColor && (T.pointFillColor = d.config.series[g].data[C].fillColor), d.config.series[g].data[C].strokeColor && (T.pointStrokeColor = d.config.series[g].data[C].strokeColor)), r && (T.pSize = r), (x.x[S] < 0 || x.x[S] > d.globals.gridWidth || x.y[S] < 0 || x.y[S] > d.globals.gridHeight) && (T.pSize = 0), (l = v.drawMarker(x.x[S], x.y[S], T)).attr("rel", C), l.attr("j", C), l.attr("index", e), l.node.setAttribute("default-marker-size", T.pSize), new ae(this.ctx).setSelectionFilter(l, e, C), this.addEvents(l), b && b.add(l)
                                    } else void 0 === d.globals.pointsArray[e] && (d.globals.pointsArray[e] = []), d.globals.pointsArray[e].push([x.x[S], x.y[S]])
                                }
                            return b
                        }
                    }, {
                        key: "getMarkerConfig",
                        value: function(t) {
                            var e = t.cssClass,
                                i = t.seriesIndex,
                                r = t.dataPointIndex,
                                l = void 0 === r ? null : r,
                                h = t.finishRadius,
                                d = void 0 === h ? null : h,
                                g = this.w,
                                x = this.getMarkerStyle(i),
                                b = g.globals.markers.size[i],
                                v = g.config.markers;
                            return null !== l && v.discrete.length && v.discrete.map(function(w) {
                                w.seriesIndex === i && w.dataPointIndex === l && (x.pointStrokeColor = w.strokeColor, x.pointFillColor = w.fillColor, b = w.size, x.pointShape = w.shape)
                            }), {
                                pSize: null === d ? b : d,
                                pRadius: v.radius,
                                width: Array.isArray(v.width) ? v.width[i] : v.width,
                                height: Array.isArray(v.height) ? v.height[i] : v.height,
                                pointStrokeWidth: Array.isArray(v.strokeWidth) ? v.strokeWidth[i] : v.strokeWidth,
                                pointStrokeColor: x.pointStrokeColor,
                                pointFillColor: x.pointFillColor,
                                shape: x.pointShape || (Array.isArray(v.shape) ? v.shape[i] : v.shape),
                                class: e,
                                pointStrokeOpacity: Array.isArray(v.strokeOpacity) ? v.strokeOpacity[i] : v.strokeOpacity,
                                pointStrokeDashArray: Array.isArray(v.strokeDashArray) ? v.strokeDashArray[i] : v.strokeDashArray,
                                pointFillOpacity: Array.isArray(v.fillOpacity) ? v.fillOpacity[i] : v.fillOpacity,
                                seriesIndex: i
                            }
                        }
                    }, {
                        key: "addEvents",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx);
                            t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), {
                                passive: !0
                            })
                        }
                    }, {
                        key: "getMarkerStyle",
                        value: function(t) {
                            var e = this.w,
                                i = e.globals.markers.colors,
                                r = e.config.markers.strokeColor || e.config.markers.strokeColors;
                            return {
                                pointStrokeColor: Array.isArray(r) ? r[t] : r,
                                pointFillColor: Array.isArray(i) ? i[t] : i
                            }
                        }
                    }]), _
                }(),
                fi = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = new ot(this.ctx),
                                h = i.realIndex,
                                d = i.pointsPos,
                                g = i.zRatio,
                                x = i.elParent,
                                b = l.group({
                                    class: "apexcharts-series-markers apexcharts-series-".concat(r.config.chart.type)
                                });
                            if (b.attr("clip-path", "url(#gridRectMarkerMask".concat(r.globals.cuid, ")")), Array.isArray(d.x))
                                for (var v = 0; v < d.x.length; v++) {
                                    var w = e + 1,
                                        S = !0;
                                    0 === e && 0 === v && (w = 0), 0 === e && 1 === v && (w = 1);
                                    var C = 0,
                                        P = r.globals.markers.size[h];
                                    if (g !== 1 / 0) {
                                        var T = r.config.plotOptions.bubble;
                                        P = r.globals.seriesZ[h][w], T.zScaling && (P /= g), T.minBubbleRadius && P < T.minBubbleRadius && (P = T.minBubbleRadius), T.maxBubbleRadius && P > T.maxBubbleRadius && (P = T.maxBubbleRadius)
                                    }
                                    r.config.chart.animations.enabled || (C = P);
                                    var R = d.y[v];
                                    if (C = C || 0, null !== R && void 0 !== r.globals.series[h][w] || (S = !1), S) {
                                        var p = this.drawPoint(d.x[v], R, C, P, h, w, e);
                                        b.add(p)
                                    }
                                    x.add(b)
                                }
                        }
                    }, {
                        key: "drawPoint",
                        value: function(t, e, i, r, l, h, d) {
                            var g = this.w,
                                x = l,
                                b = new Bt(this.ctx),
                                v = new ae(this.ctx),
                                w = new ce(this.ctx),
                                S = new gi(this.ctx),
                                C = new ot(this.ctx),
                                P = S.getMarkerConfig({
                                    cssClass: "apexcharts-marker",
                                    seriesIndex: x,
                                    dataPointIndex: h,
                                    finishRadius: "bubble" === g.config.chart.type || g.globals.comboCharts && g.config.series[l] && "bubble" === g.config.series[l].type ? r : null
                                });
                            r = P.pSize;
                            var T, I = w.fillPath({
                                seriesNumber: l,
                                dataPointIndex: h,
                                color: P.pointFillColor,
                                patternUnits: "objectBoundingBox",
                                value: g.globals.series[l][d]
                            });
                            if ("circle" === P.shape ? T = C.drawCircle(i) : "square" !== P.shape && "rect" !== P.shape || (T = C.drawRect(0, 0, P.width - P.pointStrokeWidth / 2, P.height - P.pointStrokeWidth / 2, P.pRadius)), g.config.series[x].data[h] && g.config.series[x].data[h].fillColor && (I = g.config.series[x].data[h].fillColor), T.attr({
                                    x: t - P.width / 2 - P.pointStrokeWidth / 2,
                                    y: e - P.height / 2 - P.pointStrokeWidth / 2,
                                    cx: t,
                                    cy: e,
                                    fill: I,
                                    "fill-opacity": P.pointFillOpacity,
                                    stroke: P.pointStrokeColor,
                                    r,
                                    "stroke-width": P.pointStrokeWidth,
                                    "stroke-dasharray": P.pointStrokeDashArray,
                                    "stroke-opacity": P.pointStrokeOpacity
                                }), g.config.chart.dropShadow.enabled && v.dropShadow(T, g.config.chart.dropShadow, l), !this.initialAnim || g.globals.dataChanged || g.globals.resized ? g.globals.animationEnded = !0 : b.animateMarker(T, 0, "circle" === P.shape ? r : {
                                    width: P.width,
                                    height: P.height
                                }, g.config.chart.animations.speed, g.globals.easing, function() {
                                    window.setTimeout(function() {
                                        b.animationCompleted(T)
                                    }, 100)
                                }), g.globals.dataChanged && "circle" === P.shape)
                                if (this.dynamicAnim) {
                                    var k, M, D, X, H = g.config.chart.animations.dynamicAnimation.speed;
                                    null != (X = g.globals.previousPaths[l] && g.globals.previousPaths[l][d]) && (k = X.x, M = X.y, D = void 0 !== X.r ? X.r : r);
                                    for (var j = 0; j < g.globals.collapsedSeries.length; j++) g.globals.collapsedSeries[j].index === l && (H = 1, r = 0);
                                    0 === t && 0 === e && (r = 0), b.animateCircle(T, {
                                        cx: k,
                                        cy: M,
                                        r: D
                                    }, {
                                        cx: t,
                                        cy: e,
                                        r
                                    }, H, g.globals.easing)
                                } else T.attr({
                                    r
                                });
                            return T.attr({
                                rel: h,
                                j: h,
                                index: l,
                                "default-marker-size": r
                            }), v.setSelectionFilter(T, l, h), S.addEvents(T), T.node.classList.add("apexcharts-marker"), T
                        }
                    }, {
                        key: "centerTextInBubble",
                        value: function(t) {
                            return {
                                y: t += parseInt(this.w.config.dataLabels.style.fontSize, 10) / 4
                            }
                        }
                    }]), _
                }(),
                ve = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "dataLabelsCorrection",
                        value: function(t, e, i, r, l, h, d) {
                            var g = this.w,
                                x = !1,
                                b = new ot(this.ctx).getTextRects(i, d),
                                v = b.width,
                                w = b.height;
                            if (e < 0 && (e = 0), e > g.globals.gridHeight + w && (e = g.globals.gridHeight + w / 2), void 0 === g.globals.dataLabelsRects[r] && (g.globals.dataLabelsRects[r] = []), g.globals.dataLabelsRects[r].push({
                                    x: t,
                                    y: e,
                                    width: v,
                                    height: w
                                }), void 0 !== g.globals.dataLabelsRects[r][g.globals.dataLabelsRects[r].length - 2]) {
                                var P = g.globals.dataLabelsRects[r][void 0 !== g.globals.lastDrawnDataLabelsIndexes[r] ? g.globals.lastDrawnDataLabelsIndexes[r][g.globals.lastDrawnDataLabelsIndexes[r].length - 1] : 0];
                                (t > P.x + P.width || e > P.y + P.height || e + w < P.y || t + v < P.x) && (x = !0)
                            }
                            return (0 === l || h) && (x = !0), {
                                x: t,
                                y: e,
                                textRects: b,
                                drawnextLabel: x
                            }
                        }
                    }, {
                        key: "drawDataLabel",
                        value: function(t) {
                            var e = this,
                                i = t.type,
                                r = t.pos,
                                l = t.i,
                                h = t.j,
                                d = t.isRangeStart,
                                g = t.strokeWidth,
                                x = void 0 === g ? 2 : g,
                                b = this.w,
                                v = new ot(this.ctx),
                                w = b.config.dataLabels,
                                S = 0,
                                C = 0,
                                P = h,
                                T = null;
                            if (!w.enabled || !Array.isArray(r.x)) return T;
                            T = v.group({
                                class: "apexcharts-data-labels"
                            });
                            for (var I = 0; I < r.x.length; I++)
                                if (S = r.x[I] + w.offsetX, C = r.y[I] + w.offsetY + x, !isNaN(S)) {
                                    1 === h && 0 === I && (P = 0), 1 === h && 1 === I && (P = 1);
                                    var R = b.globals.series[l][P];
                                    "rangeArea" === i && (R = d ? b.globals.seriesRangeStart[l][P] : b.globals.seriesRangeEnd[l][P]);
                                    var p = "",
                                        k = function(M) {
                                            return b.config.dataLabels.formatter(M, {
                                                ctx: e.ctx,
                                                seriesIndex: l,
                                                dataPointIndex: P,
                                                w: b
                                            })
                                        };
                                    "bubble" === b.config.chart.type ? (p = k(R = b.globals.seriesZ[l][P]), C = r.y[I], C = new fi(this.ctx).centerTextInBubble(C, l, P).y) : void 0 !== R && (p = k(R)), this.plotDataLabelsText({
                                        x: S,
                                        y: C,
                                        text: p,
                                        i: l,
                                        j: P,
                                        parent: T,
                                        offsetCorrection: !0,
                                        dataLabelsConfig: b.config.dataLabels
                                    })
                                }
                            return T
                        }
                    }, {
                        key: "plotDataLabelsText",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx),
                                r = t.x,
                                l = t.y,
                                h = t.i,
                                d = t.j,
                                g = t.text,
                                x = t.textAnchor,
                                b = t.fontSize,
                                v = t.parent,
                                w = t.dataLabelsConfig,
                                S = t.color,
                                C = t.alwaysDrawDataLabel,
                                P = t.offsetCorrection;
                            if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(h) < 0)) {
                                var T = {
                                    x: r,
                                    y: l,
                                    drawnextLabel: !0,
                                    textRects: null
                                };
                                P && (T = this.dataLabelsCorrection(r, l, g, h, d, C, parseInt(w.style.fontSize, 10))), e.globals.zoomed || (r = T.x, l = T.y), T.textRects && (r < -10 - T.textRects.width || r > e.globals.gridWidth + T.textRects.width + 10) && (g = "");
                                var I = e.globals.dataLabels.style.colors[h];
                                (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (I = e.globals.dataLabels.style.colors[d]), "function" == typeof I && (I = I({
                                    series: e.globals.series,
                                    seriesIndex: h,
                                    dataPointIndex: d,
                                    w: e
                                })), S && (I = S);
                                var R = w.offsetX,
                                    p = w.offsetY;
                                if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (R = 0, p = 0), T.drawnextLabel) {
                                    var k = i.drawText({
                                        width: 100,
                                        height: parseInt(w.style.fontSize, 10),
                                        x: r + R,
                                        y: l + p,
                                        foreColor: I,
                                        textAnchor: x || w.textAnchor,
                                        text: g,
                                        fontSize: b || w.style.fontSize,
                                        fontFamily: w.style.fontFamily,
                                        fontWeight: w.style.fontWeight || "normal"
                                    });
                                    if (k.attr({
                                            class: "apexcharts-datalabel",
                                            cx: r,
                                            cy: l
                                        }), w.dropShadow.enabled) {
                                        var M = w.dropShadow;
                                        new ae(this.ctx).dropShadow(k, M)
                                    }
                                    v.add(k), void 0 === e.globals.lastDrawnDataLabelsIndexes[h] && (e.globals.lastDrawnDataLabelsIndexes[h] = []), e.globals.lastDrawnDataLabelsIndexes[h].push(d)
                                }
                            }
                        }
                    }, {
                        key: "addBackgroundToDataLabel",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.config.dataLabels.background,
                                l = r.padding,
                                h = r.padding / 2,
                                d = e.width,
                                g = e.height,
                                x = new ot(this.ctx).drawRect(e.x - l, e.y - h / 2, d + 2 * l, g + h, r.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, r.opacity, r.borderWidth, r.borderColor);
                            return r.dropShadow.enabled && new ae(this.ctx).dropShadow(x, r.dropShadow), x
                        }
                    }, {
                        key: "dataLabelsBackground",
                        value: function() {
                            var t = this.w;
                            if ("bubble" !== t.config.chart.type)
                                for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e.length; i++) {
                                    var r = e[i],
                                        l = r.getBBox(),
                                        h = null;
                                    if (l.width && l.height && (h = this.addBackgroundToDataLabel(r, l)), h) {
                                        r.parentNode.insertBefore(h.node, r);
                                        var d = r.getAttribute("fill");
                                        !t.config.chart.animations.enabled || t.globals.resized || t.globals.dataChanged ? h.attr({
                                            fill: d
                                        }) : h.animate().attr({
                                            fill: d
                                        }), r.setAttribute("fill", t.config.dataLabels.background.foreColor)
                                    }
                                }
                        }
                    }, {
                        key: "bringForward",
                        value: function() {
                            for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), r = 0; r < e.length; r++) i && i.insertBefore(e[r], i.nextSibling)
                        }
                    }]), _
                }(),
                xe = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.legendInactiveClass = "legend-mouseover-inactive"
                    }
                    return ht(_, [{
                        key: "getAllSeriesEls",
                        value: function() {
                            return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
                        }
                    }, {
                        key: "getSeriesByName",
                        value: function(t) {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(q.escapeString(t), "']"))
                        }
                    }, {
                        key: "isSeriesHidden",
                        value: function(t) {
                            var e = this.getSeriesByName(t),
                                i = parseInt(e.getAttribute("data:realIndex"), 10);
                            return {
                                isHidden: e.classList.contains("apexcharts-series-collapsed"),
                                realIndex: i
                            }
                        }
                    }, {
                        key: "addCollapsedClassToSeries",
                        value: function(t, e) {
                            var i = this.w;

                            function r(l) {
                                for (var h = 0; h < l.length; h++) l[h].index === e && t.node.classList.add("apexcharts-series-collapsed")
                            }
                            r(i.globals.collapsedSeries), r(i.globals.ancillaryCollapsedSeries)
                        }
                    }, {
                        key: "toggleSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden
                        }
                    }, {
                        key: "showSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0)
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1)
                        }
                    }, {
                        key: "resetSeries",
                        value: function() {
                            var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                r = this.w,
                                l = q.clone(r.globals.initialSeries);
                            r.globals.previousPaths = [], i ? (r.globals.collapsedSeries = [], r.globals.ancillaryCollapsedSeries = [], r.globals.collapsedSeriesIndices = [], r.globals.ancillaryCollapsedSeriesIndices = []) : l = this.emptyCollapsedSeries(l), r.config.series = l, t && (e && (r.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(l, r.config.chart.animations.dynamicAnimation.enabled))
                        }
                    }, {
                        key: "emptyCollapsedSeries",
                        value: function(t) {
                            for (var e = this.w, i = 0; i < t.length; i++) e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
                            return t
                        }
                    }, {
                        key: "toggleSeriesOnHover",
                        value: function(t, e) {
                            var i = this.w;
                            e || (e = t.target);
                            var r = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                            if ("mousemove" === t.type) {
                                var l = parseInt(e.getAttribute("rel"), 10) - 1,
                                    h = null,
                                    d = null;
                                i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (h = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(l, "']")), d = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(l, "']"))) : h = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(l + 1, "']")) : h = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(l + 1, "'] path"));
                                for (var g = 0; g < r.length; g++) r[g].classList.add(this.legendInactiveClass);
                                null !== h && (i.globals.axisCharts || h.parentNode.classList.remove(this.legendInactiveClass), h.classList.remove(this.legendInactiveClass), null !== d && d.classList.remove(this.legendInactiveClass))
                            } else if ("mouseout" === t.type)
                                for (var x = 0; x < r.length; x++) r[x].classList.remove(this.legendInactiveClass)
                        }
                    }, {
                        key: "highlightRangeInSeries",
                        value: function(t, e) {
                            var i = this,
                                r = this.w,
                                l = r.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
                                h = function(g) {
                                    for (var x = 0; x < l.length; x++) l[x].classList[g](i.legendInactiveClass)
                                };
                            if ("mousemove" === t.type) {
                                var d = parseInt(e.getAttribute("rel"), 10) - 1;
                                h("add"),
                                    function(g) {
                                        for (var x = 0; x < l.length; x++) {
                                            var b = parseInt(l[x].getAttribute("val"), 10);
                                            b >= g.from && b <= g.to && l[x].classList.remove(i.legendInactiveClass)
                                        }
                                    }(r.config.plotOptions.heatmap.colorScale.ranges[d])
                            } else "mouseout" === t.type && h("remove")
                        }
                    }, {
                        key: "getActiveConfigSeriesIndex",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc",
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                                i = this.w,
                                r = 0;
                            if (i.config.series.length > 1)
                                for (var l = i.config.series.map(function(d, g) {
                                        return d.data && d.data.length > 0 && -1 === i.globals.collapsedSeriesIndices.indexOf(g) && (!i.globals.comboCharts || 0 === e.length || e.length && e.indexOf(i.config.series[g].type) > -1) ? g : -1
                                    }), h = "asc" === t ? 0 : l.length - 1;
                                    "asc" === t ? h < l.length : h >= 0;
                                    "asc" === t ? h++ : h--)
                                    if (-1 !== l[h]) {
                                        r = l[h];
                                        break
                                    }
                            return r
                        }
                    }, {
                        key: "getBarSeriesIndices",
                        value: function() {
                            return this.w.globals.comboCharts ? this.w.config.series.map(function(t, e) {
                                return "bar" === t.type || "column" === t.type ? e : -1
                            }).filter(function(t) {
                                return -1 !== t
                            }) : this.w.config.series.map(function(t, e) {
                                return e
                            })
                        }
                    }, {
                        key: "getPreviousPaths",
                        value: function() {
                            var t = this.w;

                            function e(h, d, g) {
                                for (var x = h[d].childNodes, b = {
                                        type: g,
                                        paths: [],
                                        realIndex: h[d].getAttribute("data:realIndex")
                                    }, v = 0; v < x.length; v++)
                                    if (x[v].hasAttribute("pathTo")) {
                                        var w = x[v].getAttribute("pathTo");
                                        b.paths.push({
                                            d: w
                                        })
                                    }
                                t.globals.previousPaths.push(b)
                            }
                            t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(h) {
                                for (var g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(h, "-series .apexcharts-series")), x = 0; x < g.length; x++) e(g, x, h)
                            }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
                            var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
                            if (i.length > 0)
                                for (var r = function(h) {
                                        for (var d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(h, "'] rect")), g = [], x = function(v) {
                                                var w = function(C) {
                                                        return d[v].getAttribute(C)
                                                    },
                                                    S = {
                                                        x: parseFloat(w("x")),
                                                        y: parseFloat(w("y")),
                                                        width: parseFloat(w("width")),
                                                        height: parseFloat(w("height"))
                                                    };
                                                g.push({
                                                    rect: S,
                                                    color: d[v].getAttribute("color")
                                                })
                                            }, b = 0; b < d.length; b++) x(b);
                                        t.globals.previousPaths.push(g)
                                    }, l = 0; l < i.length; l++) r(l);
                            t.globals.axisCharts || (t.globals.previousPaths = t.globals.series)
                        }
                    }, {
                        key: "handlePrevBubbleScatterPaths",
                        value: function(t) {
                            var e = this.w,
                                i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
                            if (i.length > 0)
                                for (var r = 0; r < i.length; r++) {
                                    for (var l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(r, "'] circle")), h = [], d = 0; d < l.length; d++) h.push({
                                        x: l[d].getAttribute("cx"),
                                        y: l[d].getAttribute("cy"),
                                        r: l[d].getAttribute("r")
                                    });
                                    e.globals.previousPaths.push(h)
                                }
                        }
                    }, {
                        key: "clearPreviousPaths",
                        value: function() {
                            var t = this.w;
                            t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1
                        }
                    }, {
                        key: "handleNoData",
                        value: function() {
                            var t = this.w,
                                e = t.config.noData,
                                i = new ot(this.ctx),
                                r = t.globals.svgWidth / 2,
                                l = t.globals.svgHeight / 2,
                                h = "middle";
                            if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (r = 10, h = "start") : "right" === e.align && (r = t.globals.svgWidth - 10, h = "end"), "top" === e.verticalAlign ? l = 50 : "bottom" === e.verticalAlign && (l = t.globals.svgHeight - 50), r += e.offsetX, l = l + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
                                var d = i.drawText({
                                    x: r,
                                    y: l,
                                    text: e.text,
                                    textAnchor: h,
                                    fontSize: e.style.fontSize,
                                    fontFamily: e.style.fontFamily,
                                    foreColor: e.style.color,
                                    opacity: 1,
                                    class: "apexcharts-text-nodata"
                                });
                                t.globals.dom.Paper.add(d)
                            }
                        }
                    }, {
                        key: "setNullSeriesToZeroValues",
                        value: function(t) {
                            for (var e = this.w, i = 0; i < t.length; i++)
                                if (0 === t[i].length)
                                    for (var r = 0; r < t[e.globals.maxValsInArrayIndex].length; r++) t[i].push(0);
                            return t
                        }
                    }, {
                        key: "hasAllSeriesEqualX",
                        value: function() {
                            for (var t = !0, e = this.w, i = this.filteredSeriesX(), r = 0; r < i.length - 1; r++)
                                if (i[r][0] !== i[r + 1][0]) {
                                    t = !1;
                                    break
                                }
                            return e.globals.allSeriesHasEqualX = t, t
                        }
                    }, {
                        key: "filteredSeriesX",
                        value: function() {
                            return this.w.globals.seriesX.map(function(e) {
                                return e.length > 0 ? e : []
                            })
                        }
                    }]), _
                }(),
                He = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new te(this.ctx)
                    }
                    return ht(_, [{
                        key: "isMultiFormat",
                        value: function() {
                            return this.isFormatXY() || this.isFormat2DArray()
                        }
                    }, {
                        key: "isFormatXY",
                        value: function() {
                            var t = this.w.config.series.slice(),
                                e = new xe(this.ctx);
                            if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0
                        }
                    }, {
                        key: "isFormat2DArray",
                        value: function() {
                            var t = this.w.config.series.slice(),
                                e = new xe(this.ctx);
                            if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null != t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0
                        }
                    }, {
                        key: "handleFormat2DArray",
                        value: function(t, e) {
                            for (var i = this.w.config, r = this.w.globals, l = "boxPlot" === i.chart.type || "boxPlot" === i.series[e].type, h = 0; h < t[e].data.length; h++)
                                if (void 0 !== t[e].data[h][1] && (Array.isArray(t[e].data[h][1]) && 4 === t[e].data[h][1].length && !l ? this.twoDSeries.push(q.parseNumber(t[e].data[h][1][3])) : this.twoDSeries.push(q.parseNumber(t[e].data[h].length >= 5 ? t[e].data[h][4] : t[e].data[h][1])), r.dataFormatXNumeric = !0), "datetime" === i.xaxis.type) {
                                    var d = new Date(t[e].data[h][0]);
                                    d = new Date(d).getTime(), this.twoDSeriesX.push(d)
                                } else this.twoDSeriesX.push(t[e].data[h][0]);
                            for (var g = 0; g < t[e].data.length; g++) void 0 !== t[e].data[g][2] && (this.threeDSeries.push(t[e].data[g][2]), r.isDataXYZ = !0)
                        }
                    }, {
                        key: "handleFormatXY",
                        value: function(t, e) {
                            var i = this.w.config,
                                r = this.w.globals,
                                l = new ne(this.ctx),
                                h = e;
                            r.collapsedSeriesIndices.indexOf(e) > -1 && (h = this.activeSeriesIndex);
                            for (var d = 0; d < t[e].data.length; d++) void 0 !== t[e].data[d].y && (Array.isArray(t[e].data[d].y) ? this.twoDSeries.push(q.parseNumber(t[e].data[d].y[t[e].data[d].y.length - 1])) : this.twoDSeries.push(q.parseNumber(t[e].data[d].y))), void 0 !== t[e].data[d].goals && Array.isArray(t[e].data[d].goals) ? (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []), this.seriesGoals[e].push(t[e].data[d].goals)) : (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []), this.seriesGoals[e].push(null));
                            for (var g = 0; g < t[h].data.length; g++) {
                                var x = "string" == typeof t[h].data[g].x,
                                    b = Array.isArray(t[h].data[g].x),
                                    v = !b && !!l.isValidDate(t[h].data[g].x.toString());
                                x || v ? x || i.xaxis.convertedCatToNumeric ? "datetime" !== i.xaxis.type || r.isBarHorizontal && r.isRangeData ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[h].data[g].x), isNaN(t[h].data[g].x) || "category" === this.w.config.xaxis.type || "string" == typeof t[h].data[g].x || (r.isXNumeric = !0)) : this.twoDSeriesX.push(l.parseDate(t[h].data[g].x)) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(l.parseDate(t[h].data[g].x.toString())) : (r.dataFormatXNumeric = !0, r.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[h].data[g].x))) : b ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[h].data[g].x)) : (r.isXNumeric = !0, r.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[h].data[g].x))
                            }
                            if (t[e].data[0] && void 0 !== t[e].data[0].z) {
                                for (var S = 0; S < t[e].data.length; S++) this.threeDSeries.push(t[e].data[S].z);
                                r.isDataXYZ = !0
                            }
                        }
                    }, {
                        key: "handleRangeData",
                        value: function(t, e) {
                            var i = this.w.globals,
                                r = {};
                            return this.isFormat2DArray() ? r = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (r = this.handleRangeDataFormat("xy", t, e)), i.seriesRangeStart.push(r.start), i.seriesRangeEnd.push(r.end), i.seriesRange.push(r.rangeUniques), i.seriesRange.forEach(function(l, h) {
                                l && l.forEach(function(d, g) {
                                    d.y.forEach(function(x, b) {
                                        for (var v = 0; v < d.y.length; v++) b !== v && x.y1 <= d.y[v].y2 && d.y[v].y1 <= x.y2 && (d.overlaps.indexOf(x.rangeName) < 0 && d.overlaps.push(x.rangeName), d.overlaps.indexOf(d.y[v].rangeName) < 0 && d.overlaps.push(d.y[v].rangeName))
                                    })
                                })
                            }), r
                        }
                    }, {
                        key: "handleCandleStickBoxData",
                        value: function(t, e) {
                            var i = this.w.globals,
                                r = {};
                            return this.isFormat2DArray() ? r = this.handleCandleStickBoxDataFormat("array", t, e) : this.isFormatXY() && (r = this.handleCandleStickBoxDataFormat("xy", t, e)), i.seriesCandleO[e] = r.o, i.seriesCandleH[e] = r.h, i.seriesCandleM[e] = r.m, i.seriesCandleL[e] = r.l, i.seriesCandleC[e] = r.c, r
                        }
                    }, {
                        key: "handleRangeDataFormat",
                        value: function(t, e, i) {
                            var r = [],
                                l = [],
                                h = e[i].data.filter(function(b, v, w) {
                                    return v === w.findIndex(function(S) {
                                        return S.x === b.x
                                    })
                                }).map(function(b, v) {
                                    return {
                                        x: b.x,
                                        overlaps: [],
                                        y: []
                                    }
                                });
                            if ("array" === t)
                                for (var d = 0; d < e[i].data.length; d++) Array.isArray(e[i].data[d]) ? (r.push(e[i].data[d][1][0]), l.push(e[i].data[d][1][1])) : (r.push(e[i].data[d]), l.push(e[i].data[d]));
                            else if ("xy" === t)
                                for (var g = function(b) {
                                        var v = Array.isArray(e[i].data[b].y),
                                            w = q.randomId(),
                                            S = e[i].data[b].x,
                                            C = {
                                                y1: v ? e[i].data[b].y[0] : e[i].data[b].y,
                                                y2: v ? e[i].data[b].y[1] : e[i].data[b].y,
                                                rangeName: w
                                            };
                                        e[i].data[b].rangeName = w;
                                        var P = h.findIndex(function(T) {
                                            return T.x === S
                                        });
                                        h[P].y.push(C), r.push(C.y1), l.push(C.y2)
                                    }, x = 0; x < e[i].data.length; x++) g(x);
                            return {
                                start: r,
                                end: l,
                                rangeUniques: h
                            }
                        }
                    }, {
                        key: "handleCandleStickBoxDataFormat",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[i].type,
                                h = [],
                                d = [],
                                g = [],
                                x = [],
                                b = [];
                            if ("array" === t)
                                if (l && 6 === e[i].data[0].length || !l && 5 === e[i].data[0].length)
                                    for (var v = 0; v < e[i].data.length; v++) h.push(e[i].data[v][1]), d.push(e[i].data[v][2]), l ? (g.push(e[i].data[v][3]), x.push(e[i].data[v][4]), b.push(e[i].data[v][5])) : (x.push(e[i].data[v][3]), b.push(e[i].data[v][4]));
                                else
                                    for (var w = 0; w < e[i].data.length; w++) Array.isArray(e[i].data[w][1]) && (h.push(e[i].data[w][1][0]), d.push(e[i].data[w][1][1]), l ? (g.push(e[i].data[w][1][2]), x.push(e[i].data[w][1][3]), b.push(e[i].data[w][1][4])) : (x.push(e[i].data[w][1][2]), b.push(e[i].data[w][1][3])));
                            else if ("xy" === t)
                                for (var S = 0; S < e[i].data.length; S++) Array.isArray(e[i].data[S].y) && (h.push(e[i].data[S].y[0]), d.push(e[i].data[S].y[1]), l ? (g.push(e[i].data[S].y[2]), x.push(e[i].data[S].y[3]), b.push(e[i].data[S].y[4])) : (x.push(e[i].data[S].y[2]), b.push(e[i].data[S].y[3])));
                            return {
                                o: h,
                                h: d,
                                m: g,
                                l: x,
                                c: b
                            }
                        }
                    }, {
                        key: "parseDataAxisCharts",
                        value: function(t) {
                            var e, i = this,
                                l = this.w.config,
                                h = this.w.globals,
                                d = new ne(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx),
                                g = l.labels.length > 0 ? l.labels.slice() : l.xaxis.categories.slice();
                            if (h.isRangeBar = "rangeBar" === l.chart.type && h.isBarHorizontal, h.hasXaxisGroups = "category" === l.xaxis.type && l.xaxis.group.groups.length > 0, h.hasXaxisGroups && (h.groups = l.xaxis.group.groups), h.hasSeriesGroups = null === (e = t[0]) || void 0 === e ? void 0 : e.group, h.hasSeriesGroups) {
                                var x = [],
                                    b = le(new Set(t.map(function(C) {
                                        return C.group
                                    })));
                                t.forEach(function(C, P) {
                                    var T = b.indexOf(C.group);
                                    x[T] || (x[T] = []), x[T].push(C.name)
                                }), h.seriesGroups = x
                            }
                            for (var v = function() {
                                    for (var C = 0; C < g.length; C++)
                                        if ("string" == typeof g[C]) {
                                            if (!d.isValidDate(g[C])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                                            i.twoDSeriesX.push(d.parseDate(g[C]))
                                        } else i.twoDSeriesX.push(g[C])
                                }, w = 0; w < t.length; w++) {
                                if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[w].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                                if ("rangeBar" !== l.chart.type && "rangeArea" !== l.chart.type && "rangeBar" !== t[w].type && "rangeArea" !== t[w].type || (h.isRangeData = !0, h.isComboCharts ? "rangeBar" !== t[w].type && "rangeArea" !== t[w].type || this.handleRangeData(t, w) : "rangeBar" !== l.chart.type && "rangeArea" !== l.chart.type || this.handleRangeData(t, w)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, w) : this.isFormatXY() && this.handleFormatXY(t, w), "candlestick" !== l.chart.type && "candlestick" !== t[w].type && "boxPlot" !== l.chart.type && "boxPlot" !== t[w].type || this.handleCandleStickBoxData(t, w), h.series.push(this.twoDSeries), h.labels.push(this.twoDSeriesX), h.seriesX.push(this.twoDSeriesX), h.seriesGoals = this.seriesGoals, w !== this.activeSeriesIndex || this.fallbackToCategory || (h.isXNumeric = !0);
                                else {
                                    "datetime" === l.xaxis.type ? (h.isXNumeric = !0, v(), h.seriesX.push(this.twoDSeriesX)) : "numeric" === l.xaxis.type && (h.isXNumeric = !0, g.length > 0 && (this.twoDSeriesX = g, h.seriesX.push(this.twoDSeriesX))), h.labels.push(this.twoDSeriesX);
                                    var S = t[w].data.map(function(C) {
                                        return q.parseNumber(C)
                                    });
                                    h.series.push(S)
                                }
                                h.seriesZ.push(this.threeDSeries), h.seriesNames.push(void 0 !== t[w].name ? t[w].name : "series-" + parseInt(w + 1, 10)), h.seriesColors.push(void 0 !== t[w].color ? t[w].color : void 0)
                            }
                            return this.w
                        }
                    }, {
                        key: "parseDataNonAxisCharts",
                        value: function(t) {
                            var e = this.w.globals,
                                i = this.w.config;
                            e.series = t.slice(), e.seriesNames = i.labels.slice();
                            for (var r = 0; r < e.series.length; r++) void 0 === e.seriesNames[r] && e.seriesNames.push("series-" + (r + 1));
                            return this.w
                        }
                    }, {
                        key: "handleExternalLabelsData",
                        value: function(t) {
                            var e = this.w.config,
                                i = this.w.globals;
                            e.xaxis.categories.length > 0 ? i.labels = e.xaxis.categories : e.labels.length > 0 ? i.labels = e.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(r) {
                                r.forEach(function(l) {
                                    i.labels.indexOf(l.x) < 0 && l.x && i.labels.push(l.x)
                                })
                            }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), e.xaxis.convertedCatToNumeric && (new Ze(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t)
                        }
                    }, {
                        key: "_generateExternalLabels",
                        value: function(t) {
                            var e = this.w.globals,
                                i = this.w.config,
                                r = [];
                            if (e.axisCharts) {
                                if (e.series.length > 0)
                                    if (this.isFormatXY())
                                        for (var l = i.series.map(function(v, w) {
                                                return v.data.filter(function(S, C, P) {
                                                    return P.findIndex(function(T) {
                                                        return T.x === S.x
                                                    }) === C
                                                })
                                            }), h = l.reduce(function(v, w, S, C) {
                                                return C[v].length > w.length ? v : S
                                            }, 0), d = 0; d < l[h].length; d++) r.push(d + 1);
                                    else
                                        for (var g = 0; g < e.series[e.maxValsInArrayIndex].length; g++) r.push(g + 1);
                                e.seriesX = [];
                                for (var x = 0; x < t.length; x++) e.seriesX.push(r);
                                this.w.globals.isBarHorizontal || (e.isXNumeric = !0)
                            }
                            if (0 === r.length) {
                                r = e.axisCharts ? [] : e.series.map(function(v, w) {
                                    return w + 1
                                });
                                for (var b = 0; b < t.length; b++) e.seriesX.push(r)
                            }
                            e.labels = r, i.xaxis.convertedCatToNumeric && (e.categoryLabels = r.map(function(v) {
                                return i.xaxis.labels.formatter(v)
                            })), e.noLabelsProvided = !0
                        }
                    }, {
                        key: "parseData",
                        value: function(t) {
                            var e = this.w,
                                i = e.config,
                                r = e.globals;
                            if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), r.axisCharts ? (this.parseDataAxisCharts(t), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t), i.chart.stacked) {
                                var l = new xe(this.ctx);
                                r.series = l.setNullSeriesToZeroValues(r.series)
                            }
                            this.coreUtils.getSeriesTotals(), r.axisCharts && (r.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()), this.coreUtils.getPercentSeries(), r.dataFormatXNumeric || r.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t);
                            for (var h = this.coreUtils.getCategoryLabels(r.labels), d = 0; d < h.length; d++)
                                if (Array.isArray(h[d])) {
                                    r.isMultiLineX = !0;
                                    break
                                }
                        }
                    }, {
                        key: "excludeCollapsedSeriesInYAxis",
                        value: function() {
                            var t = this,
                                e = this.w;
                            e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function(i, r) {
                                if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index
                            })
                        }
                    }]), _
                }(),
                Le = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "getLabel",
                        value: function(t, e, i, r) {
                            var T, I, l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
                                h = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
                                d = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6],
                                g = this.w,
                                x = void 0 === t[r] ? "" : t[r],
                                b = x,
                                v = g.globals.xLabelFormatter,
                                w = g.config.xaxis.labels.formatter,
                                S = !1,
                                C = new Be(this.ctx);
                            d && (b = C.xLabelFormat(v, x, x, {
                                i: r,
                                dateFormatter: new ne(this.ctx).formatDate,
                                w: g
                            }), void 0 !== w && (b = w(x, t[r], {
                                i: r,
                                dateFormatter: new ne(this.ctx).formatDate,
                                w: g
                            }))), e.length > 0 ? (T = e[r].unit, I = null, e.forEach(function(M) {
                                "month" === M.unit ? I = "year" : "day" === M.unit ? I = "month" : "hour" === M.unit ? I = "day" : "minute" === M.unit && (I = "hour")
                            }), S = I === T, i = e[r].position, b = e[r].value) : "datetime" === g.config.xaxis.type && void 0 === w && (b = ""), void 0 === b && (b = ""), b = Array.isArray(b) ? b : b.toString();
                            var p, R = new ot(this.ctx);
                            p = g.globals.rotateXLabels && d ? R.getTextRects(b, parseInt(h, 10), null, "rotate(".concat(g.config.xaxis.labels.rotate, " 0 0)"), !1) : R.getTextRects(b, parseInt(h, 10));
                            var k = !g.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                            return !Array.isArray(b) && (0 === b.indexOf("NaN") || 0 === b.toLowerCase().indexOf("invalid") || b.toLowerCase().indexOf("infinity") >= 0 || l.indexOf(b) >= 0 && k) && (b = ""), {
                                x: i,
                                text: b,
                                textRect: p,
                                isBold: S
                            }
                        }
                    }, {
                        key: "checkLabelBasedOnTickamount",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = r.config.xaxis.tickAmount;
                            return "dataPoints" === l && (l = Math.round(r.globals.gridWidth / 120)), l > i || t % Math.round(i / (l + 1)) == 0 || (e.text = ""), e
                        }
                    }, {
                        key: "checkForOverflowingLabels",
                        value: function(t, e, i, r, l) {
                            var h = this.w;
                            if (0 === t && h.globals.skipFirstTimelinelabel && (e.text = ""), t === i - 1 && h.globals.skipLastTimelinelabel && (e.text = ""), h.config.xaxis.labels.hideOverlappingLabels && r.length > 0) {
                                var d = l[l.length - 1];
                                e.x < d.textRect.width / (h.globals.rotateXLabels ? Math.abs(h.config.xaxis.labels.rotate) / 12 : 1.01) + d.x && (e.text = "")
                            }
                            return e
                        }
                    }, {
                        key: "checkForReversedLabels",
                        value: function(t, e) {
                            var i = this.w;
                            return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e
                        }
                    }, {
                        key: "isYAxisHidden",
                        value: function(t) {
                            var e = this.w,
                                i = new te(this.ctx);
                            return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t)
                        }
                    }, {
                        key: "getYAxisForeColor",
                        value: function(t, e) {
                            var i = this.w;
                            return Array.isArray(t) && i.globals.yAxisScale[e] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[e].result.length, !1), t
                        }
                    }, {
                        key: "drawYAxisTicks",
                        value: function(t, e, i, r, l, h, d) {
                            var g = this.w,
                                x = new ot(this.ctx),
                                b = g.globals.translateY;
                            if (r.show && e > 0) {
                                !0 === g.config.yaxis[l].opposite && (t += r.width);
                                for (var v = e; v >= 0; v--) {
                                    var w = b + e / 10 + g.config.yaxis[l].labels.offsetY - 1;
                                    g.globals.isBarHorizontal && (w = h * v), "heatmap" === g.config.chart.type && (w += h / 2);
                                    var S = x.drawLine(t + i.offsetX - r.width + r.offsetX, w + r.offsetY, t + i.offsetX + r.offsetX, w + r.offsetY, r.color);
                                    d.add(S), b += h
                                }
                            }
                        }
                    }]), _
                }(),
                ii = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "scaleSvgNode",
                        value: function(t, e) {
                            var i = parseFloat(t.getAttributeNS(null, "width")),
                                r = parseFloat(t.getAttributeNS(null, "height"));
                            t.setAttributeNS(null, "width", i * e), t.setAttributeNS(null, "height", r * e), t.setAttributeNS(null, "viewBox", "0 0 " + i + " " + r)
                        }
                    }, {
                        key: "fixSvgStringForIe11",
                        value: function(t) {
                            if (!q.isIE11()) return t.replace(/&nbsp;/g, "&#160;");
                            var e = 0,
                                i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(r) {
                                    return 2 == ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : r
                                });
                            return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
                        }
                    }, {
                        key: "getSvgString",
                        value: function(t) {
                            null == t && (t = 1);
                            var e = this.w.globals.dom.Paper.svg();
                            if (1 !== t) {
                                var i = this.w.globals.dom.Paper.node.cloneNode(!0);
                                this.scaleSvgNode(i, t), e = (new XMLSerializer).serializeToString(i)
                            }
                            return this.fixSvgStringForIe11(e)
                        }
                    }, {
                        key: "cleanup",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                                i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                                r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                            Array.prototype.forEach.call(r, function(l) {
                                l.setAttribute("width", 0)
                            }), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100))
                        }
                    }, {
                        key: "svgUrl",
                        value: function() {
                            this.cleanup();
                            var t = this.getSvgString(),
                                e = new Blob([t], {
                                    type: "image/svg+xml;charset=utf-8"
                                });
                            return URL.createObjectURL(e)
                        }
                    }, {
                        key: "dataURI",
                        value: function(t) {
                            var e = this;
                            return new Promise(function(i) {
                                var r = e.w,
                                    l = t ? t.scale || t.width / r.globals.svgWidth : 1;
                                e.cleanup();
                                var h = document.createElement("canvas");
                                h.width = r.globals.svgWidth * l, h.height = parseInt(r.globals.dom.elWrap.style.height, 10) * l;
                                var d = "transparent" === r.config.chart.background ? "#fff" : r.config.chart.background,
                                    g = h.getContext("2d");
                                g.fillStyle = d, g.fillRect(0, 0, h.width * l, h.height * l);
                                var x = e.getSvgString(l);
                                if (window.canvg && q.isIE11()) {
                                    var b = window.canvg.Canvg.fromString(g, x, {
                                        ignoreClear: !0,
                                        ignoreDimensions: !0
                                    });
                                    b.start();
                                    var v = h.msToBlob();
                                    b.stop(), i({
                                        blob: v
                                    })
                                } else {
                                    var w = "data:image/svg+xml," + encodeURIComponent(x),
                                        S = new Image;
                                    S.crossOrigin = "anonymous", S.onload = function() {
                                        if (g.drawImage(S, 0, 0), h.msToBlob) {
                                            var C = h.msToBlob();
                                            i({
                                                blob: C
                                            })
                                        } else {
                                            var P = h.toDataURL("image/png");
                                            i({
                                                imgURI: P
                                            })
                                        }
                                    }, S.src = w
                                }
                            })
                        }
                    }, {
                        key: "exportToSVG",
                        value: function() {
                            this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
                        }
                    }, {
                        key: "exportToPng",
                        value: function() {
                            var t = this;
                            this.dataURI().then(function(e) {
                                var i = e.imgURI,
                                    r = e.blob;
                                r ? navigator.msSaveOrOpenBlob(r, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png")
                            })
                        }
                    }, {
                        key: "exportToCSV",
                        value: function(t) {
                            var e = this,
                                i = t.series,
                                r = t.fileName,
                                l = t.columnDelimiter,
                                h = void 0 === l ? "," : l,
                                d = t.lineDelimiter,
                                g = void 0 === d ? "\n" : d,
                                x = this.w;
                            i || (i = x.config.series);
                            var b = [],
                                v = [],
                                w = "",
                                S = x.globals.series.map(function(p, k) {
                                    return -1 === x.globals.collapsedSeriesIndices.indexOf(k) ? p : []
                                }),
                                C = Math.max.apply(Math, le(i.map(function(p) {
                                    return p.data ? p.data.length : 0
                                }))),
                                P = new He(this.ctx),
                                T = new Le(this.ctx),
                                I = function(p) {
                                    var k = "";
                                    if (x.globals.axisCharts) {
                                        if ("category" === x.config.xaxis.type || x.config.xaxis.convertedCatToNumeric)
                                            if (x.globals.isBarHorizontal) {
                                                var M = x.globals.yLabelFormatters[0],
                                                    D = new xe(e.ctx).getActiveConfigSeriesIndex();
                                                k = M(x.globals.labels[p], {
                                                    seriesIndex: D,
                                                    dataPointIndex: p,
                                                    w: x
                                                })
                                            } else k = T.getLabel(x.globals.labels, x.globals.timescaleLabels, 0, p).text;
                                        "datetime" === x.config.xaxis.type && (x.config.xaxis.categories.length ? k = x.config.xaxis.categories[p] : x.config.labels.length && (k = x.config.labels[p]))
                                    } else k = x.config.labels[p];
                                    return Array.isArray(k) && (k = k.join(" ")), q.isNumber(k) ? k : k.split(h).join("")
                                };
                            b.push(x.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === x.config.chart.type ? (b.push("minimum"), b.push("q1"), b.push("median"), b.push("q3"), b.push("maximum")) : "candlestick" === x.config.chart.type ? (b.push("open"), b.push("high"), b.push("low"), b.push("close")) : "rangeBar" === x.config.chart.type ? (b.push("minimum"), b.push("maximum")) : i.map(function(p, k) {
                                var M = (p.name ? p.name : "series-".concat(k)) + "";
                                x.globals.axisCharts && b.push(M.split(h).join("") ? M.split(h).join("") : "series-".concat(k))
                            }), x.globals.axisCharts || (b.push(x.config.chart.toolbar.export.csv.headerValue), v.push(b.join(h))), i.map(function(p, k) {
                                x.globals.axisCharts ? function(p, k) {
                                    if (b.length && 0 === k && v.push(b.join(h)), p.data) {
                                        p.data = p.data.length && p.data || le(Array(C)).map(function() {
                                            return ""
                                        });
                                        for (var M = 0; M < p.data.length; M++) {
                                            b = [];
                                            var D = I(M);
                                            if (D || (P.isFormatXY() ? D = i[k].data[M].x : P.isFormat2DArray() && (D = i[k].data[M] ? i[k].data[M][0] : "")), 0 === k) {
                                                b.push("datetime" === x.config.xaxis.type && String(D).length >= 10 ? x.config.chart.toolbar.export.csv.dateFormatter(D) : q.isNumber(D) ? D : D.split(h).join(""));
                                                for (var X = 0; X < x.globals.series.length; X++) {
                                                    var H;
                                                    P.isFormatXY() ? b.push(null === (H = i[X].data[M]) || void 0 === H ? void 0 : H.y) : b.push(S[X][M])
                                                }
                                            }("candlestick" === x.config.chart.type || p.type && "candlestick" === p.type) && (b.pop(), b.push(x.globals.seriesCandleO[k][M]), b.push(x.globals.seriesCandleH[k][M]), b.push(x.globals.seriesCandleL[k][M]), b.push(x.globals.seriesCandleC[k][M])), ("boxPlot" === x.config.chart.type || p.type && "boxPlot" === p.type) && (b.pop(), b.push(x.globals.seriesCandleO[k][M]), b.push(x.globals.seriesCandleH[k][M]), b.push(x.globals.seriesCandleM[k][M]), b.push(x.globals.seriesCandleL[k][M]), b.push(x.globals.seriesCandleC[k][M])), "rangeBar" === x.config.chart.type && (b.pop(), b.push(x.globals.seriesRangeStart[k][M]), b.push(x.globals.seriesRangeEnd[k][M])), b.length && v.push(b.join(h))
                                        }
                                    }
                                }(p, k) : ((b = []).push(x.globals.labels[k].split(h).join("")), b.push(S[k]), v.push(b.join(h)))
                            }), w += v.join(g), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + w), r || x.config.chart.toolbar.export.csv.filename, ".csv")
                        }
                    }, {
                        key: "triggerDownload",
                        value: function(t, e, i) {
                            var r = document.createElement("a");
                            r.href = t, r.download = (e || this.w.globals.chartID) + i, document.body.appendChild(r), r.click(), document.body.removeChild(r)
                        }
                    }]), _
                }(),
                Ye = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.elgrid = e, this.w = t.w;
                        var i = this.w;
                        this.axesUtils = new Le(t), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], this.offY = "top" === i.config.xaxis.position ? 0 : i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth = this.xaxisBorderWidth.indexOf("%") > -1 ? i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0]
                    }
                    return ht(_, [{
                        key: "drawXaxis",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx),
                                i = e.group({
                                    class: "apexcharts-xaxis",
                                    transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")")
                                }),
                                r = e.group({
                                    class: "apexcharts-xaxis-texts-g",
                                    transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                                });
                            i.add(r);
                            for (var l = [], h = 0; h < this.xaxisLabels.length; h++) l.push(this.xaxisLabels[h]);
                            if (this.drawXAxisLabelAndGroup(!0, e, r, l, t.globals.isXNumeric, function(C, P) {
                                    return P
                                }), t.globals.hasXaxisGroups) {
                                var d = t.globals.groups;
                                l = [];
                                for (var g = 0; g < d.length; g++) l.push(d[g].title);
                                var x = {};
                                t.config.xaxis.group.style && (x.xaxisFontSize = t.config.xaxis.group.style.fontSize, x.xaxisFontFamily = t.config.xaxis.group.style.fontFamily, x.xaxisForeColors = t.config.xaxis.group.style.colors, x.fontWeight = t.config.xaxis.group.style.fontWeight, x.cssClass = t.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, e, r, l, !1, function(C, P) {
                                    return d[C].cols * P
                                }, x)
                            }
                            if (void 0 !== t.config.xaxis.title.text) {
                                var b = e.group({
                                        class: "apexcharts-xaxis-title"
                                    }),
                                    v = e.drawText({
                                        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                                        y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t.config.xaxis.position ? t.globals.xAxisLabelsHeight : -t.globals.xAxisLabelsHeight - 10) + t.config.xaxis.title.offsetY,
                                        text: t.config.xaxis.title.text,
                                        textAnchor: "middle",
                                        fontSize: t.config.xaxis.title.style.fontSize,
                                        fontFamily: t.config.xaxis.title.style.fontFamily,
                                        fontWeight: t.config.xaxis.title.style.fontWeight,
                                        foreColor: t.config.xaxis.title.style.color,
                                        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
                                    });
                                b.add(v), i.add(b)
                            }
                            if (t.config.xaxis.axisBorder.show) {
                                var w = t.globals.barPadForNumericAxis,
                                    S = e.drawLine(t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - w, this.offY, this.xaxisBorderWidth + w, this.offY, t.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                                this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(S) : i.add(S)
                            }
                            return i
                        }
                    }, {
                        key: "drawXAxisLabelAndGroup",
                        value: function(t, e, i, r, l, h) {
                            var d, g = this,
                                x = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {},
                                b = [],
                                v = [],
                                w = this.w,
                                S = x.xaxisFontSize || this.xaxisFontSize,
                                C = x.xaxisFontFamily || this.xaxisFontFamily,
                                P = x.xaxisForeColors || this.xaxisForeColors,
                                T = x.fontWeight || w.config.xaxis.labels.style.fontWeight,
                                I = x.cssClass || w.config.xaxis.labels.style.cssClass,
                                R = w.globals.padHorizontal,
                                p = r.length,
                                k = "category" === w.config.xaxis.type ? w.globals.dataPoints : p;
                            0 === k && p > k && (k = p), l ? (d = w.globals.gridWidth / Math.min(k > 1 ? k - 1 : k, p - 1), R = R + h(0, d) / 2 + w.config.xaxis.labels.offsetX) : R = R + h(0, d = w.globals.gridWidth / k) + w.config.xaxis.labels.offsetX;
                            for (var D = function(H) {
                                    var j = R - h(H, d) / 2 + w.config.xaxis.labels.offsetX;
                                    0 === H && 1 === p && d / 2 === R && 1 === k && (j = w.globals.gridWidth / 2);
                                    var U = g.axesUtils.getLabel(r, w.globals.timescaleLabels, j, H, b, S, t),
                                        Q = 28;
                                    if (w.globals.rotateXLabels && t && (Q = 22), w.config.xaxis.title.text && "top" === w.config.xaxis.position && (Q += parseFloat(w.config.xaxis.title.style.fontSize) + 2), t || (Q = Q + parseFloat(S) + (w.globals.xAxisLabelsHeight - w.globals.xAxisGroupLabelsHeight) + (w.globals.rotateXLabels ? 10 : 0)), U = void 0 !== w.config.xaxis.tickAmount && "dataPoints" !== w.config.xaxis.tickAmount && "datetime" !== w.config.xaxis.type ? g.axesUtils.checkLabelBasedOnTickamount(H, U, p) : g.axesUtils.checkForOverflowingLabels(H, U, p, b, v), w.config.xaxis.labels.show) {
                                        var at = e.drawText({
                                            x: U.x,
                                            y: g.offY + w.config.xaxis.labels.offsetY + Q - ("top" === w.config.xaxis.position ? w.globals.xAxisHeight + w.config.xaxis.axisTicks.height - 2 : 0),
                                            text: U.text,
                                            textAnchor: "middle",
                                            fontWeight: U.isBold ? 600 : T,
                                            fontSize: S,
                                            fontFamily: C,
                                            foreColor: Array.isArray(P) ? t && w.config.xaxis.convertedCatToNumeric ? P[w.globals.minX + H - 1] : P[H] : P,
                                            isPlainText: !1,
                                            cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + I
                                        });
                                        if (i.add(at), at.on("click", function(mt) {
                                                if ("function" == typeof w.config.chart.events.xAxisLabelClick) {
                                                    var yt = Object.assign({}, w, {
                                                        labelIndex: H
                                                    });
                                                    w.config.chart.events.xAxisLabelClick(mt, g.ctx, yt)
                                                }
                                            }), t) {
                                            var it = document.createElementNS(w.globals.SVGNS, "title");
                                            it.textContent = Array.isArray(U.text) ? U.text.join(" ") : U.text, at.node.appendChild(it), "" !== U.text && (b.push(U.text), v.push(U))
                                        }
                                    }
                                    H < p - 1 && (R += h(H + 1, d))
                                }, X = 0; X <= p - 1; X++) D(X)
                        }
                    }, {
                        key: "drawXaxisInversed",
                        value: function(t) {
                            var e, i, r = this,
                                l = this.w,
                                h = new ot(this.ctx),
                                d = l.config.yaxis[0].opposite ? l.globals.translateYAxisX[t] : 0,
                                g = h.group({
                                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                                    rel: t
                                }),
                                x = h.group({
                                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                                    transform: "translate(" + d + ", 0)"
                                });
                            g.add(x);
                            var b = [];
                            if (l.config.yaxis[t].show)
                                for (var v = 0; v < this.xaxisLabels.length; v++) b.push(this.xaxisLabels[v]);
                            i = -(e = l.globals.gridHeight / b.length) / 2.2;
                            var w = l.globals.yLabelFormatters[0],
                                S = l.config.yaxis[0].labels;
                            if (S.show)
                                for (var C = function(M) {
                                        var D = void 0 === b[M] ? "" : b[M];
                                        D = w(D, {
                                            seriesIndex: t,
                                            dataPointIndex: M,
                                            w: l
                                        });
                                        var X = r.axesUtils.getYAxisForeColor(S.style.colors, t),
                                            H = 0;
                                        Array.isArray(D) && (H = D.length / 2 * parseInt(S.style.fontSize, 10));
                                        var j = S.offsetX - 15,
                                            U = "end";
                                        r.yaxis.opposite && (U = "start"), "left" === l.config.yaxis[0].labels.align ? (j = S.offsetX, U = "start") : "center" === l.config.yaxis[0].labels.align ? (j = S.offsetX, U = "middle") : "right" === l.config.yaxis[0].labels.align && (U = "end");
                                        var Q = h.drawText({
                                            x: j,
                                            y: i + e + S.offsetY - H,
                                            text: D,
                                            textAnchor: U,
                                            foreColor: Array.isArray(X) ? X[M] : X,
                                            fontSize: S.style.fontSize,
                                            fontFamily: S.style.fontFamily,
                                            fontWeight: S.style.fontWeight,
                                            isPlainText: !1,
                                            cssClass: "apexcharts-yaxis-label " + S.style.cssClass,
                                            maxWidth: S.maxWidth
                                        });
                                        x.add(Q), Q.on("click", function(mt) {
                                            if ("function" == typeof l.config.chart.events.xAxisLabelClick) {
                                                var yt = Object.assign({}, l, {
                                                    labelIndex: M
                                                });
                                                l.config.chart.events.xAxisLabelClick(mt, r.ctx, yt)
                                            }
                                        });
                                        var at = document.createElementNS(l.globals.SVGNS, "title");
                                        if (at.textContent = Array.isArray(D) ? D.join(" ") : D, Q.node.appendChild(at), 0 !== l.config.yaxis[t].labels.rotate) {
                                            var it = h.rotateAroundCenter(Q.node);
                                            Q.node.setAttribute("transform", "rotate(".concat(l.config.yaxis[t].labels.rotate, " 0 ").concat(it.y, ")"))
                                        }
                                        i += e
                                    }, P = 0; P <= b.length - 1; P++) C(P);
                            if (void 0 !== l.config.yaxis[0].title.text) {
                                var T = h.group({
                                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                                        transform: "translate(" + d + ", 0)"
                                    }),
                                    I = h.drawText({
                                        x: l.config.yaxis[0].title.offsetX,
                                        y: l.globals.gridHeight / 2 + l.config.yaxis[0].title.offsetY,
                                        text: l.config.yaxis[0].title.text,
                                        textAnchor: "middle",
                                        foreColor: l.config.yaxis[0].title.style.color,
                                        fontSize: l.config.yaxis[0].title.style.fontSize,
                                        fontWeight: l.config.yaxis[0].title.style.fontWeight,
                                        fontFamily: l.config.yaxis[0].title.style.fontFamily,
                                        cssClass: "apexcharts-yaxis-title-text " + l.config.yaxis[0].title.style.cssClass
                                    });
                                T.add(I), g.add(T)
                            }
                            var R = 0;
                            this.isCategoryBarHorizontal && l.config.yaxis[0].opposite && (R = l.globals.gridWidth);
                            var p = l.config.xaxis.axisBorder;
                            if (p.show) {
                                var k = h.drawLine(l.globals.padHorizontal + p.offsetX + R, 1 + p.offsetY, l.globals.padHorizontal + p.offsetX + R, l.globals.gridHeight + p.offsetY, p.color, 0);
                                this.elgrid && this.elgrid.elGridBorders && l.config.grid.show ? this.elgrid.elGridBorders.add(k) : g.add(k)
                            }
                            return l.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(R, b.length, l.config.yaxis[0].axisBorder, l.config.yaxis[0].axisTicks, 0, e, g), g
                        }
                    }, {
                        key: "drawXaxisTicks",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = t;
                            if (!(t < 0 || t - 2 > r.globals.gridWidth)) {
                                var h = this.offY + r.config.xaxis.axisTicks.offsetY;
                                if (e = e + h + r.config.xaxis.axisTicks.height, "top" === r.config.xaxis.position && (e = h - r.config.xaxis.axisTicks.height), r.config.xaxis.axisTicks.show) {
                                    var d = new ot(this.ctx).drawLine(t + r.config.xaxis.axisTicks.offsetX, h + r.config.xaxis.offsetY, l + r.config.xaxis.axisTicks.offsetX, e + r.config.xaxis.offsetY, r.config.xaxis.axisTicks.color);
                                    i.add(d), d.node.classList.add("apexcharts-xaxis-tick")
                                }
                            }
                        }
                    }, {
                        key: "getXAxisTicksPositions",
                        value: function() {
                            var t = this.w,
                                e = [],
                                i = this.xaxisLabels.length,
                                r = t.globals.padHorizontal;
                            if (t.globals.timescaleLabels.length > 0)
                                for (var l = 0; l < i; l++) e.push(r = this.xaxisLabels[l].position);
                            else
                                for (var h = i, d = 0; d < h; d++) {
                                    var g = h;
                                    t.globals.isXNumeric && "bar" !== t.config.chart.type && (g -= 1), e.push(r += t.globals.gridWidth / g)
                                }
                            return e
                        }
                    }, {
                        key: "xAxisLabelCorrections",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx),
                                i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                                r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),
                                l = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                                h = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                            if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
                                for (var d = 0; d < r.length; d++) {
                                    var g = e.rotateAroundCenter(r[d]);
                                    g.y = g.y - 1, g.x = g.x + 1, r[d].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(g.x, " ").concat(g.y, ")")), r[d].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")")), t.config.xaxis.labels.trim && Array.prototype.forEach.call(r[d].childNodes, function(S) {
                                        e.placeTextWithEllipsis(S, S.textContent, t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10))
                                    })
                                } else ! function() {
                                    for (var S = t.globals.gridWidth / (t.globals.labels.length + 1), C = 0; C < r.length; C++) t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(r[C].childNodes, function(T) {
                                        e.placeTextWithEllipsis(T, T.textContent, S)
                                    })
                                }();
                            if (l.length > 0) {
                                var b = l[l.length - 1].getBBox(),
                                    v = l[0].getBBox();
                                b.x < -20 && l[l.length - 1].parentNode.removeChild(l[l.length - 1]), v.x + v.width > t.globals.gridWidth && !t.globals.isBarHorizontal && l[0].parentNode.removeChild(l[0]);
                                for (var w = 0; w < h.length; w++) e.placeTextWithEllipsis(h[w], h[w].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15)
                            }
                        }
                    }]), _
                }(),
                We = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w;
                        var e = this.w;
                        this.xaxisLabels = e.globals.labels.slice(), this.axesUtils = new Le(t), this.isRangeBar = e.globals.seriesRange.length && e.globals.isBarHorizontal, e.globals.timescaleLabels.length > 0 && (this.xaxisLabels = e.globals.timescaleLabels.slice())
                    }
                    return ht(_, [{
                        key: "drawGridArea",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                e = this.w,
                                i = new ot(this.ctx);
                            null === t && (t = i.group({
                                class: "apexcharts-grid"
                            }));
                            var r = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
                                l = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
                            return t.add(l), t.add(r), t
                        }
                    }, {
                        key: "drawGrid",
                        value: function() {
                            var t = null;
                            return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t
                        }
                    }, {
                        key: "createGridMask",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = new ot(this.ctx),
                                r = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
                            if (Array.isArray(t.config.stroke.width)) {
                                var l = 0;
                                t.config.stroke.width.forEach(function(v) {
                                    l = Math.max(l, v)
                                }), r = l
                            }
                            e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid)), e.dom.elForecastMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e.cuid)), e.dom.elNonForecastMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e.cuid));
                            var h = t.config.chart.type,
                                d = 0,
                                g = 0;
                            ("bar" === h || "rangeBar" === h || "candlestick" === h || "boxPlot" === h || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (g = t.config.grid.padding.right, e.barPadForNumericAxis > (d = t.config.grid.padding.left) && (d = e.barPadForNumericAxis, g = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-r / 2 - d - 2, -r / 2, e.gridWidth + r + g + d + 4, e.gridHeight + r, 0, "#fff");
                            var x = t.globals.markers.largestSize + 1;
                            e.dom.elGridRectMarker = i.drawRect(2 * -x, 2 * -x, e.gridWidth + 4 * x, e.gridHeight + 4 * x, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
                            var b = e.dom.baseEl.querySelector("defs");
                            b.appendChild(e.dom.elGridRectMask), b.appendChild(e.dom.elForecastMask), b.appendChild(e.dom.elNonForecastMask), b.appendChild(e.dom.elGridRectMarkerMask)
                        }
                    }, {
                        key: "_drawGridLines",
                        value: function(t) {
                            var e = t.i,
                                i = t.x1,
                                d = t.xCount,
                                x = this.w;
                            if (!(0 === e && x.globals.skipFirstTimelinelabel || e === d - 1 && x.globals.skipLastTimelinelabel && !x.config.xaxis.labels.formatter || "radar" === x.config.chart.type)) {
                                x.config.grid.xaxis.lines.show && this._drawGridLine({
                                    i: e,
                                    x1: i,
                                    y1: t.y1,
                                    x2: t.x2,
                                    y2: t.y2,
                                    xCount: d,
                                    parent: t.parent
                                });
                                var b = 0;
                                if (x.globals.hasXaxisGroups && "between" === x.config.xaxis.tickPlacement) {
                                    var v = x.globals.groups;
                                    if (v) {
                                        for (var w = 0, S = 0; w < e && S < v.length; S++) w += v[S].cols;
                                        w === e && (b = .6 * x.globals.xAxisLabelsHeight)
                                    }
                                }
                                new Ye(this.ctx).drawXaxisTicks(i, b, x.globals.dom.elGraphical)
                            }
                        }
                    }, {
                        key: "_drawGridLine",
                        value: function(t) {
                            var e = t.i,
                                i = t.x1,
                                r = t.y1,
                                l = t.x2,
                                h = t.y2,
                                d = t.xCount,
                                g = t.parent,
                                x = this.w,
                                b = !1,
                                v = g.node.classList.contains("apexcharts-gridlines-horizontal"),
                                w = x.config.grid.strokeDashArray,
                                S = x.globals.barPadForNumericAxis;
                            (0 === r && 0 === h || 0 === i && 0 === l) && (b = !0), r === x.globals.gridHeight && h === x.globals.gridHeight && (b = !0), !x.globals.isBarHorizontal || 0 !== e && e !== d - 1 || (b = !0);
                            var C = new ot(this).drawLine(i - (v ? S : 0), r, l + (v ? S : 0), h, x.config.grid.borderColor, w);
                            C.node.classList.add("apexcharts-gridline"), b && x.config.grid.show ? this.elGridBorders.add(C) : g.add(C)
                        }
                    }, {
                        key: "_drawGridBandRect",
                        value: function(t) {
                            var e = t.c,
                                i = t.x1,
                                r = t.y1,
                                l = t.x2,
                                h = t.y2,
                                d = t.type,
                                g = this.w,
                                x = new ot(this.ctx),
                                b = g.globals.barPadForNumericAxis;
                            if ("column" !== d || "datetime" !== g.config.xaxis.type) {
                                var w = x.drawRect(i - ("row" === d ? b : 0), r, l + ("row" === d ? 2 * b : 0), h, 0, g.config.grid[d].colors[e], g.config.grid[d].opacity);
                                this.elg.add(w), w.attr("clip-path", "url(#gridRectMask".concat(g.globals.cuid, ")")), w.node.classList.add("apexcharts-grid-".concat(d))
                            }
                        }
                    }, {
                        key: "_drawXYLines",
                        value: function(t) {
                            var e = this,
                                i = t.xCount,
                                r = t.tickAmount,
                                l = this.w;
                            if (l.config.grid.xaxis.lines.show || l.config.xaxis.axisTicks.show) {
                                var h, d = l.globals.padHorizontal,
                                    g = l.globals.gridHeight;
                                l.globals.timescaleLabels.length ? function(C) {
                                    for (var P = C.xC, I = C.y1, p = C.y2, k = 0; k < P; k++) e._drawGridLines({
                                        i: k,
                                        x1: e.xaxisLabels[k].position,
                                        y1: I,
                                        x2: e.xaxisLabels[k].position,
                                        y2: p,
                                        xCount: i,
                                        parent: e.elgridLinesV
                                    })
                                }({
                                    xC: i,
                                    x1: d,
                                    y1: 0,
                                    x2: h,
                                    y2: g
                                }) : (l.globals.isXNumeric && (i = l.globals.xAxisScale.result.length), function(C) {
                                    for (var P = C.xC, T = C.x1, I = C.y1, R = C.x2, p = C.y2, k = 0; k < P + (l.globals.isXNumeric ? 0 : 1); k++) 0 === k && 1 === P && 1 === l.globals.dataPoints && (R = T = l.globals.gridWidth / 2), e._drawGridLines({
                                        i: k,
                                        x1: T,
                                        y1: I,
                                        x2: R,
                                        y2: p,
                                        xCount: i,
                                        parent: e.elgridLinesV
                                    }), R = T += l.globals.gridWidth / (l.globals.isXNumeric ? P - 1 : P)
                                }({
                                    xC: i,
                                    x1: d,
                                    y1: 0,
                                    x2: h,
                                    y2: g
                                }))
                            }
                            if (l.config.grid.yaxis.lines.show) {
                                var x = 0,
                                    b = 0,
                                    v = l.globals.gridWidth,
                                    w = r + 1;
                                this.isRangeBar && (w = l.globals.labels.length);
                                for (var S = 0; S < w + (this.isRangeBar ? 1 : 0); S++) this._drawGridLine({
                                    i: S,
                                    xCount: w + (this.isRangeBar ? 1 : 0),
                                    x1: 0,
                                    y1: x,
                                    x2: v,
                                    y2: b,
                                    parent: this.elgridLinesH
                                }), b = x += l.globals.gridHeight / (this.isRangeBar ? w : r)
                            }
                        }
                    }, {
                        key: "_drawInvertedXYLines",
                        value: function(t) {
                            var e = t.xCount,
                                i = this.w;
                            if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                                for (var r, l = i.globals.padHorizontal, h = i.globals.gridHeight, d = 0; d < e + 1; d++) i.config.grid.xaxis.lines.show && this._drawGridLine({
                                    i: d,
                                    xCount: e + 1,
                                    x1: l,
                                    y1: 0,
                                    x2: r,
                                    y2: h,
                                    parent: this.elgridLinesV
                                }), new Ye(this.ctx).drawXaxisTicks(l, 0, i.globals.dom.elGraphical), r = l = l + i.globals.gridWidth / e + .3;
                            if (i.config.grid.yaxis.lines.show)
                                for (var g = 0, x = 0, b = i.globals.gridWidth, v = 0; v < i.globals.dataPoints + 1; v++) this._drawGridLine({
                                    i: v,
                                    xCount: i.globals.dataPoints + 1,
                                    x1: 0,
                                    y1: g,
                                    x2: b,
                                    y2: x,
                                    parent: this.elgridLinesH
                                }), x = g += i.globals.gridHeight / i.globals.dataPoints
                        }
                    }, {
                        key: "renderGrid",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx);
                            this.elg = e.group({
                                class: "apexcharts-grid"
                            }), this.elgridLinesH = e.group({
                                class: "apexcharts-gridlines-horizontal"
                            }), this.elgridLinesV = e.group({
                                class: "apexcharts-gridlines-vertical"
                            }), this.elGridBorders = e.group({
                                class: "apexcharts-grid-borders"
                            }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
                            for (var i, r = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, l = 0; l < t.globals.series.length && (void 0 !== t.globals.yAxisScale[l] && (r = t.globals.yAxisScale[l].result.length - 1), !(r > 2)); l++);
                            return !t.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length, this.isRangeBar && (i--, r = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({
                                xCount: i,
                                tickAmount: r
                            })) : this._drawInvertedXYLines({
                                xCount: i = r,
                                tickAmount: r = t.globals.xTickAmount
                            }), this.drawGridBands(i, r), {
                                el: this.elg,
                                elGridBorders: this.elGridBorders,
                                xAxisTickWidth: t.globals.gridWidth / i
                            }
                        }
                    }, {
                        key: "drawGridBands",
                        value: function(t, e) {
                            var i = this.w;
                            if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                                for (var r = 0, l = i.globals.gridHeight / e, h = i.globals.gridWidth, d = 0, g = 0; d < e; d++, g++) g >= i.config.grid.row.colors.length && (g = 0), this._drawGridBandRect({
                                    c: g,
                                    x1: 0,
                                    y1: r,
                                    x2: h,
                                    y2: l,
                                    type: "row"
                                }), r += i.globals.gridHeight / e;
                            if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                                for (var x = i.globals.isBarHorizontal || "on" !== i.config.xaxis.tickPlacement || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, b = i.globals.padHorizontal, v = i.globals.padHorizontal + i.globals.gridWidth / x, w = i.globals.gridHeight, S = 0, C = 0; S < t; S++, C++) C >= i.config.grid.column.colors.length && (C = 0), this._drawGridBandRect({
                                    c: C,
                                    x1: b,
                                    y1: 0,
                                    x2: v,
                                    y2: w,
                                    type: "column"
                                }), b += i.globals.gridWidth / x
                        }
                    }]), _
                }(),
                $e = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "niceScale",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                l = arguments.length > 4 ? arguments[4] : void 0,
                                h = this.w,
                                d = Math.abs(e - t);
                            if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, r, d)) && (i = h.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !q.isNumber(t) && !q.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) return this.linearScale(t = 0, e = i, i);
                            t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
                            var g = [];
                            d < 1 && l && ("candlestick" === h.config.chart.type || "candlestick" === h.config.series[r].type || "boxPlot" === h.config.chart.type || "boxPlot" === h.config.series[r].type || h.globals.isRangeData) && (e *= 1.01);
                            var x = i + 1;
                            x < 2 ? x = 2 : x > 2 && (x -= 2);
                            var b = d / x,
                                v = Math.floor(q.log10(b)),
                                w = Math.pow(10, v),
                                S = Math.round(b / w);
                            S < 1 && (S = 1);
                            var C = S * w,
                                P = C * Math.floor(t / C),
                                T = C * Math.ceil(e / C),
                                I = P;
                            if (l && d > 2) {
                                for (; g.push(q.stripNumber(I, 7)), !((I += C) > T););
                                return {
                                    result: g,
                                    niceMin: g[0],
                                    niceMax: g[g.length - 1]
                                }
                            }
                            var R = t;
                            (g = []).push(q.stripNumber(R, 7));
                            for (var p = Math.abs(e - t) / i, k = 0; k <= i; k++) g.push(R += p);
                            return g[g.length - 2] >= e && g.pop(), {
                                result: g,
                                niceMin: g[0],
                                niceMax: g[g.length - 1]
                            }
                        }
                    }, {
                        key: "linearScale",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                r = arguments.length > 3 ? arguments[3] : void 0,
                                l = Math.abs(e - t);
                            "dataPoints" === (i = this._adjustTicksForSmallRange(i, r, l)) && (i = this.w.globals.dataPoints - 1);
                            var h = l / i;
                            i === Number.MAX_VALUE && (i = 10, h = 1);
                            for (var d = [], g = t; i >= 0;) d.push(g), g += h, i -= 1;
                            return {
                                result: d,
                                niceMin: d[0],
                                niceMax: d[d.length - 1]
                            }
                        }
                    }, {
                        key: "logarithmicScaleNice",
                        value: function(t, e, i) {
                            e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                            for (var r = [], l = Math.ceil(Math.log(e) / Math.log(i) + 1), h = Math.floor(Math.log(t) / Math.log(i)); h < l; h++) r.push(Math.pow(i, h));
                            return {
                                result: r,
                                niceMin: r[0],
                                niceMax: r[r.length - 1]
                            }
                        }
                    }, {
                        key: "logarithmicScale",
                        value: function(t, e, i) {
                            e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                            for (var r = [], l = Math.log(e) / Math.log(i), h = Math.log(t) / Math.log(i), d = l - h, g = Math.round(d), x = d / g, b = 0, v = h; b < g; b++, v += x) r.push(Math.pow(i, v));
                            return r.push(Math.pow(i, l)), {
                                result: r,
                                niceMin: t,
                                niceMax: e
                            }
                        }
                    }, {
                        key: "_adjustTicksForSmallRange",
                        value: function(t, e, i) {
                            var r = t;
                            if (void 0 !== e && this.w.config.yaxis[e].labels.formatter && void 0 === this.w.config.yaxis[e].tickAmount) {
                                var l = Number(this.w.config.yaxis[e].labels.formatter(1));
                                q.isNumber(l) && 0 === this.w.globals.yValueDecimal && (r = Math.ceil(i))
                            }
                            return r < t ? r : t
                        }
                    }, {
                        key: "setYScaleForIndex",
                        value: function(t, e, i) {
                            var r = this.w.globals,
                                l = this.w.config,
                                h = r.isBarHorizontal ? l.xaxis : l.yaxis[t];
                            void 0 === r.yAxisScale[t] && (r.yAxisScale[t] = []);
                            var d = Math.abs(i - e);
                            h.logarithmic && d <= 5 && (r.invalidLogScale = !0), h.logarithmic && d > 5 ? (r.allSeriesCollapsed = !1, r.yAxisScale[t] = this.logarithmicScale(e, i, h.logBase), r.yAxisScale[t] = h.forceNiceScale ? this.logarithmicScaleNice(e, i, h.logBase) : this.logarithmicScale(e, i, h.logBase)) : i !== -Number.MAX_VALUE && q.isNumber(i) ? (r.allSeriesCollapsed = !1, r.yAxisScale[t] = void 0 === h.min && void 0 === h.max || h.forceNiceScale ? this.niceScale(e, i, h.tickAmount ? h.tickAmount : d < 5 && d > 1 ? d + 1 : 5, t, void 0 === l.yaxis[t].max && void 0 === l.yaxis[t].min || l.yaxis[t].forceNiceScale) : this.linearScale(e, i, h.tickAmount, t)) : r.yAxisScale[t] = this.linearScale(0, 5, 5)
                        }
                    }, {
                        key: "setXScale",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.globals,
                                l = i.config.xaxis,
                                h = Math.abs(e - t);
                            return r.xAxisScale = e !== -Number.MAX_VALUE && q.isNumber(e) ? this.linearScale(t, e, l.tickAmount ? l.tickAmount : h < 5 && h > 1 ? h + 1 : 5, 0) : this.linearScale(0, 5, 5), r.xAxisScale
                        }
                    }, {
                        key: "setMultipleYScales",
                        value: function() {
                            var t = this,
                                e = this.w.globals,
                                i = this.w.config,
                                r = e.minYArr.concat([]),
                                l = e.maxYArr.concat([]),
                                h = [];
                            i.yaxis.forEach(function(d, g) {
                                var x = g;
                                i.series.forEach(function(w, S) {
                                    w.name === d.seriesName && (x = S, h.push(g !== S ? {
                                        index: S,
                                        similarIndex: g,
                                        alreadyExists: !0
                                    } : {
                                        index: S
                                    }))
                                }), t.setYScaleForIndex(g, r[x], l[x])
                            }), this.sameScaleInMultipleAxes(r, l, h)
                        }
                    }, {
                        key: "sameScaleInMultipleAxes",
                        value: function(t, e, i) {
                            var r = this,
                                l = this.w.config,
                                h = this.w.globals,
                                d = [];
                            i.forEach(function(P) {
                                P.alreadyExists && (void 0 === d[P.index] && (d[P.index] = []), d[P.index].push(P.index), d[P.index].push(P.similarIndex))
                            }), h.yAxisSameScaleIndices = d, d.forEach(function(P, T) {
                                d.forEach(function(I, R) {
                                    var p, k;
                                    T !== R && (p = P, k = I, p.filter(function(M) {
                                        return -1 !== k.indexOf(M)
                                    })).length > 0 && (d[T] = d[T].concat(d[R]))
                                })
                            });
                            var g = d.map(function(P) {
                                return P.filter(function(T, I) {
                                    return P.indexOf(T) === I
                                })
                            }).map(function(P) {
                                return P.sort()
                            });
                            d = d.filter(function(P) {
                                return !!P
                            });
                            var x = g.slice(),
                                b = x.map(function(P) {
                                    return JSON.stringify(P)
                                });
                            x = x.filter(function(P, T) {
                                return b.indexOf(JSON.stringify(P)) === T
                            });
                            var v = [],
                                w = [];
                            t.forEach(function(P, T) {
                                x.forEach(function(I, R) {
                                    I.indexOf(T) > -1 && (void 0 === v[R] && (v[R] = [], w[R] = []), v[R].push({
                                        key: T,
                                        value: P
                                    }), w[R].push({
                                        key: T,
                                        value: e[T]
                                    }))
                                })
                            });
                            var S = Array.apply(null, Array(x.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
                                C = Array.apply(null, Array(x.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                            v.forEach(function(P, T) {
                                P.forEach(function(I, R) {
                                    S[T] = Math.min(I.value, S[T])
                                })
                            }), w.forEach(function(P, T) {
                                P.forEach(function(I, R) {
                                    C[T] = Math.max(I.value, C[T])
                                })
                            }), t.forEach(function(P, T) {
                                w.forEach(function(I, R) {
                                    var p = S[R],
                                        k = C[R];
                                    l.chart.stacked && (k = 0, I.forEach(function(M, D) {
                                        M.value !== -Number.MAX_VALUE && (k += M.value), p !== Number.MIN_VALUE && (p += v[R][D].value)
                                    })), I.forEach(function(M, D) {
                                        I[D].key === T && (void 0 !== l.yaxis[T].min && (p = "function" == typeof l.yaxis[T].min ? l.yaxis[T].min(h.minY) : l.yaxis[T].min), void 0 !== l.yaxis[T].max && (k = "function" == typeof l.yaxis[T].max ? l.yaxis[T].max(h.maxY) : l.yaxis[T].max), r.setYScaleForIndex(T, p, k))
                                    })
                                })
                            })
                        }
                    }, {
                        key: "autoScaleY",
                        value: function(t, e, i) {
                            t || (t = this);
                            var r = t.w;
                            if (r.globals.isMultipleYAxis || r.globals.collapsedSeries.length) return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."), e;
                            var l = r.globals.seriesX[0],
                                h = r.config.chart.stacked;
                            return e.forEach(function(d, g) {
                                for (var x = 0, b = 0; b < l.length; b++)
                                    if (l[b] >= i.xaxis.min) {
                                        x = b;
                                        break
                                    }
                                var v, w, S = r.globals.minYArr[g],
                                    C = r.globals.maxYArr[g],
                                    P = r.globals.stackedSeriesTotals;
                                r.globals.series.forEach(function(T, I) {
                                    var R = T[x];
                                    h ? (v = w = R = P[x], P.forEach(function(p, k) {
                                        l[k] <= i.xaxis.max && l[k] >= i.xaxis.min && (p > w && null !== p && (w = p), T[k] < v && null !== T[k] && (v = T[k]))
                                    })) : (v = w = R, T.forEach(function(p, k) {
                                        if (l[k] <= i.xaxis.max && l[k] >= i.xaxis.min) {
                                            var M = p,
                                                D = p;
                                            r.globals.series.forEach(function(X, H) {
                                                null !== p && (M = Math.min(X[k], M), D = Math.max(X[k], D))
                                            }), D > w && null !== D && (w = D), M < v && null !== M && (v = M)
                                        }
                                    })), void 0 === v && void 0 === w && (v = S, w = C), w *= w < 0 ? .9 : 1.1, 0 == (v *= v < 0 ? 1.1 : .9) && 0 === w && (v = -1, w = 1), w < 0 && w < C && (w = C), v < 0 && v > S && (v = S), e.length > 1 ? (e[I].min = void 0 === d.min ? v : d.min, e[I].max = void 0 === d.max ? w : d.max) : (e[0].min = void 0 === d.min ? v : d.min, e[0].max = void 0 === d.max ? w : d.max)
                                })
                            }), e
                        }
                    }]), _
                }(),
                Ae = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.scales = new $e(t)
                    }
                    return ht(_, [{
                        key: "init",
                        value: function() {
                            this.setYRange(), this.setXRange(), this.setZRange()
                        }
                    }, {
                        key: "getMinYMaxY",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                l = this.w.config,
                                h = this.w.globals,
                                d = -Number.MAX_VALUE,
                                g = Number.MIN_VALUE;
                            null === r && (r = t + 1);
                            var x = h.series,
                                b = x,
                                v = x;
                            "candlestick" === l.chart.type ? (b = h.seriesCandleL, v = h.seriesCandleH) : "boxPlot" === l.chart.type ? (b = h.seriesCandleO, v = h.seriesCandleC) : h.isRangeData && (b = h.seriesRangeStart, v = h.seriesRangeEnd);
                            for (var w = t; w < r; w++) {
                                h.dataPoints = Math.max(h.dataPoints, x[w].length), h.categoryLabels.length && (h.dataPoints = h.categoryLabels.filter(function(P) {
                                    return void 0 !== P
                                }).length), h.labels.length && "datetime" !== l.xaxis.type && 0 !== h.series.reduce(function(P, T) {
                                    return P + T.length
                                }, 0) && (h.dataPoints = Math.max(h.dataPoints, h.labels.length));
                                for (var S = 0; S < h.series[w].length; S++) {
                                    var C = x[w][S];
                                    null !== C && q.isNumber(C) ? (void 0 !== v[w][S] && (d = Math.max(d, v[w][S]), e = Math.min(e, v[w][S])), void 0 !== b[w][S] && (e = Math.min(e, b[w][S]), i = Math.max(i, b[w][S])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type && "rangeArea" === this.w.config.chart.type && "rangeBar" === this.w.config.chart.type || ("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || void 0 !== h.seriesCandleC[w][S] && (d = Math.max(d, h.seriesCandleO[w][S]), d = Math.max(d, h.seriesCandleH[w][S]), d = Math.max(d, h.seriesCandleL[w][S]), d = Math.max(d, h.seriesCandleC[w][S]), "boxPlot" === this.w.config.chart.type && (d = Math.max(d, h.seriesCandleM[w][S]))), !l.series[w].type || "candlestick" === l.series[w].type && "boxPlot" === l.series[w].type && "rangeArea" === l.series[w].type && "rangeBar" === l.series[w].type || (d = Math.max(d, h.series[w][S]), e = Math.min(e, h.series[w][S])), i = d), h.seriesGoals[w] && h.seriesGoals[w][S] && Array.isArray(h.seriesGoals[w][S]) && h.seriesGoals[w][S].forEach(function(P) {
                                        g !== Number.MIN_VALUE && (g = Math.min(g, P.value), e = g), d = Math.max(d, P.value), i = d
                                    }), q.isFloat(C) && (C = q.noExponents(C), h.yValueDecimal = Math.max(h.yValueDecimal, C.toString().split(".")[1].length)), g > b[w][S] && b[w][S] < 0 && (g = b[w][S])) : h.hasNullValues = !0
                                }
                            }
                            return "rangeBar" === l.chart.type && h.seriesRangeStart.length && h.isBarHorizontal && (g = e), "bar" === l.chart.type && (g < 0 && d < 0 && (d = 0), g === Number.MIN_VALUE && (g = 0)), {
                                minY: g,
                                maxY: d,
                                lowestY: e,
                                highestY: i
                            }
                        }
                    }, {
                        key: "setYRange",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
                            var i = Number.MAX_VALUE;
                            if (t.isMultipleYAxis)
                                for (var r = 0; r < t.series.length; r++) {
                                    var l = this.getMinYMaxY(r, i, null, r + 1);
                                    t.minYArr.push(l.minY), t.maxYArr.push(l.maxY), i = l.lowestY
                                }
                            var h = this.getMinYMaxY(0, i, null, t.series.length);
                            if (t.minY = h.minY, t.maxY = h.maxY, i = h.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "boxPlot" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
                                var d = t.maxY - i;
                                (i >= 0 && i <= 10 || void 0 !== e.yaxis[0].min || void 0 !== e.yaxis[0].max) && (d = 0), t.minY = i - 5 * d / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * d / 100
                            }
                            return e.yaxis.forEach(function(g, x) {
                                void 0 !== g.max && ("number" == typeof g.max ? t.maxYArr[x] = g.max : "function" == typeof g.max && (t.maxYArr[x] = g.max(t.isMultipleYAxis ? t.maxYArr[x] : t.maxY)), t.maxY = t.maxYArr[x]), void 0 !== g.min && ("number" == typeof g.min ? t.minYArr[x] = g.min : "function" == typeof g.min && (t.minYArr[x] = g.min(t.isMultipleYAxis ? t.minYArr[x] === Number.MIN_VALUE ? 0 : t.minYArr[x] : t.minY)), t.minY = t.minYArr[x])
                            }), t.isBarHorizontal && ["min", "max"].forEach(function(g) {
                                void 0 !== e.xaxis[g] && "number" == typeof e.xaxis[g] && ("min" === g ? t.minY = e.xaxis[g] : t.maxY = e.xaxis[g])
                            }), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function(g, x) {
                                t.minYArr[x] = g.niceMin, t.maxYArr[x] = g.niceMax
                            })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
                                minY: t.minY,
                                maxY: t.maxY,
                                minYArr: t.minYArr,
                                maxYArr: t.maxYArr,
                                yAxisScale: t.yAxisScale
                            }
                        }
                    }, {
                        key: "setXRange",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config,
                                i = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
                            if (t.isXNumeric && function() {
                                    for (var d = 0; d < t.series.length; d++)
                                        if (t.labels[d])
                                            for (var g = 0; g < t.labels[d].length; g++) null !== t.labels[d][g] && q.isNumber(t.labels[d][g]) && (t.maxX = Math.max(t.maxX, t.labels[d][g]), t.initialMaxX = Math.max(t.maxX, t.labels[d][g]), t.minX = Math.min(t.minX, t.labels[d][g]), t.initialMinX = Math.min(t.minX, t.labels[d][g]))
                                }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
                                var r;
                                if (void 0 === e.xaxis.tickAmount ? (r = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (r = t.dataPoints - 1), r > t.dataPoints && 0 !== t.dataPoints && (r = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (r = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (r = t.maxX - t.minX - 1)) : r = e.xaxis.tickAmount, t.xTickAmount = r, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
                                    if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
                                        for (var l = [], h = t.minX - 1; h < t.maxX; h++) l.push(h + 1);
                                        t.xAxisScale = {
                                            result: l,
                                            niceMin: l[0],
                                            niceMax: l[l.length - 1]
                                        }
                                    } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
                                else t.xAxisScale = this.scales.linearScale(0, r, r), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, r - 1), t.seriesX = t.labels.slice());
                                i && (t.labels = t.xAxisScale.result.slice())
                            }
                            return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                                minX: t.minX,
                                maxX: t.maxX
                            }
                        }
                    }, {
                        key: "setZRange",
                        value: function() {
                            var t = this.w.globals;
                            if (t.isDataXYZ)
                                for (var e = 0; e < t.series.length; e++)
                                    if (void 0 !== t.seriesZ[e])
                                        for (var i = 0; i < t.seriesZ[e].length; i++) null !== t.seriesZ[e][i] && q.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i]))
                        }
                    }, {
                        key: "_handleSingleDataPoint",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            if (t.minX === t.maxX) {
                                var i = new ne(this.ctx);
                                if ("datetime" === e.xaxis.type) {
                                    var r = i.getDate(t.minX);
                                    e.xaxis.labels.datetimeUTC ? r.setUTCDate(r.getUTCDate() - 2) : r.setDate(r.getDate() - 2), t.minX = new Date(r).getTime();
                                    var l = i.getDate(t.maxX);
                                    e.xaxis.labels.datetimeUTC ? l.setUTCDate(l.getUTCDate() + 2) : l.setDate(l.getDate() + 2), t.maxX = new Date(l).getTime()
                                } else("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX)
                            }
                        }
                    }, {
                        key: "_getMinXDiff",
                        value: function() {
                            var t = this.w.globals;
                            t.isXNumeric && t.seriesX.forEach(function(e, i) {
                                1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
                                var r = e.slice();
                                r.sort(function(l, h) {
                                    return l - h
                                }), r.forEach(function(l, h) {
                                    if (h > 0) {
                                        var d = l - r[h - 1];
                                        d > 0 && (t.minXDiff = Math.min(d, t.minXDiff))
                                    }
                                }), 1 !== t.dataPoints && t.minXDiff !== Number.MAX_VALUE || (t.minXDiff = .5)
                            })
                        }
                    }, {
                        key: "_setStackedMinMax",
                        value: function() {
                            var t = this,
                                e = this.w.globals;
                            if (e.series.length) {
                                var i = e.seriesGroups;
                                i.length || (i = [this.w.config.series.map(function(h) {
                                    return h.name
                                })]);
                                var r = {},
                                    l = {};
                                i.forEach(function(h) {
                                    r[h] = [], l[h] = [], t.w.config.series.map(function(d, g) {
                                        return h.indexOf(d.name) > -1 ? g : null
                                    }).filter(function(d) {
                                        return null !== d
                                    }).forEach(function(d) {
                                        for (var g = 0; g < e.series[e.maxValsInArrayIndex].length; g++) void 0 === r[h][g] && (r[h][g] = 0, l[h][g] = 0), null !== e.series[d][g] && q.isNumber(e.series[d][g]) && (e.series[d][g] > 0 ? r[h][g] += parseFloat(e.series[d][g]) + 1e-4 : l[h][g] += parseFloat(e.series[d][g]))
                                    })
                                }), Object.entries(r).forEach(function(h) {
                                    var d = ze(h, 1)[0];
                                    r[d].forEach(function(g, x) {
                                        e.maxY = Math.max(e.maxY, r[d][x]), e.minY = Math.min(e.minY, l[d][x])
                                    })
                                })
                            }
                        }
                    }]), _
                }(),
                pi = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.elgrid = e, this.w = t.w;
                        var i = this.w;
                        this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Le(t)
                    }
                    return ht(_, [{
                        key: "drawYaxis",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = new ot(this.ctx),
                                l = i.config.yaxis[t].labels.style,
                                h = l.fontSize,
                                d = l.fontFamily,
                                g = l.fontWeight,
                                x = r.group({
                                    class: "apexcharts-yaxis",
                                    rel: t,
                                    transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)"
                                });
                            if (this.axesUtils.isYAxisHidden(t)) return x;
                            var b = r.group({
                                class: "apexcharts-yaxis-texts-g"
                            });
                            x.add(b);
                            var v = i.globals.yAxisScale[t].result.length - 1,
                                w = i.globals.gridHeight / v,
                                S = i.globals.translateY,
                                C = i.globals.yLabelFormatters[t],
                                P = i.globals.yAxisScale[t].result.slice();
                            P = this.axesUtils.checkForReversedLabels(t, P);
                            var T = "";
                            if (i.config.yaxis[t].labels.show)
                                for (var I = function(j) {
                                        var U = P[j];
                                        U = C(U, j, i);
                                        var Q = i.config.yaxis[t].labels.padding;
                                        i.config.yaxis[t].opposite && 0 !== i.config.yaxis.length && (Q *= -1);
                                        var at = "end";
                                        i.config.yaxis[t].opposite && (at = "start"), "left" === i.config.yaxis[t].labels.align ? at = "start" : "center" === i.config.yaxis[t].labels.align ? at = "middle" : "right" === i.config.yaxis[t].labels.align && (at = "end");
                                        var it = e.axesUtils.getYAxisForeColor(l.colors, t),
                                            mt = i.config.yaxis[t].labels.offsetY;
                                        "heatmap" === i.config.chart.type && (mt -= (i.globals.gridHeight / i.globals.series.length - 1) / 2);
                                        var yt = r.drawText({
                                            x: Q,
                                            y: S + v / 10 + mt + 1,
                                            text: U,
                                            textAnchor: at,
                                            fontSize: h,
                                            fontFamily: d,
                                            fontWeight: g,
                                            maxWidth: i.config.yaxis[t].labels.maxWidth,
                                            foreColor: Array.isArray(it) ? it[j] : it,
                                            isPlainText: !1,
                                            cssClass: "apexcharts-yaxis-label " + l.cssClass
                                        });
                                        j === v && (T = yt), b.add(yt);
                                        var Pt = document.createElementNS(i.globals.SVGNS, "title");
                                        if (Pt.textContent = Array.isArray(U) ? U.join(" ") : U, yt.node.appendChild(Pt), 0 !== i.config.yaxis[t].labels.rotate) {
                                            var Dt = r.rotateAroundCenter(T.node),
                                                Vt = r.rotateAroundCenter(yt.node);
                                            yt.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(Dt.x, " ").concat(Vt.y, ")"))
                                        }
                                        S += w
                                    }, R = v; R >= 0; R--) I(R);
                            if (void 0 !== i.config.yaxis[t].title.text) {
                                var p = r.group({
                                        class: "apexcharts-yaxis-title"
                                    }),
                                    k = 0;
                                i.config.yaxis[t].opposite && (k = i.globals.translateYAxisX[t]);
                                var M = r.drawText({
                                    x: k,
                                    y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY,
                                    text: i.config.yaxis[t].title.text,
                                    textAnchor: "end",
                                    foreColor: i.config.yaxis[t].title.style.color,
                                    fontSize: i.config.yaxis[t].title.style.fontSize,
                                    fontWeight: i.config.yaxis[t].title.style.fontWeight,
                                    fontFamily: i.config.yaxis[t].title.style.fontFamily,
                                    cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass
                                });
                                p.add(M), x.add(p)
                            }
                            var D = i.config.yaxis[t].axisBorder,
                                X = 31 + D.offsetX;
                            if (i.config.yaxis[t].opposite && (X = -31 - D.offsetX), D.show) {
                                var H = r.drawLine(X, i.globals.translateY + D.offsetY - 2, X, i.globals.gridHeight + i.globals.translateY + D.offsetY + 2, D.color, 0, D.width);
                                x.add(H)
                            }
                            return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(X, v, D, i.config.yaxis[t].axisTicks, t, w, x), x
                        }
                    }, {
                        key: "drawYaxisInversed",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx),
                                r = i.group({
                                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                                }),
                                l = i.group({
                                    class: "apexcharts-xaxis-texts-g",
                                    transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                                });
                            r.add(l);
                            var h = e.globals.yAxisScale[t].result.length - 1,
                                d = e.globals.gridWidth / h + .1,
                                g = d + e.config.xaxis.labels.offsetX,
                                x = e.globals.xLabelFormatter,
                                b = e.globals.yAxisScale[t].result.slice(),
                                v = e.globals.timescaleLabels;
                            v.length > 0 && (this.xaxisLabels = v.slice(), h = (b = v.slice()).length), b = this.axesUtils.checkForReversedLabels(t, b);
                            var w = v.length;
                            if (e.config.xaxis.labels.show)
                                for (var S = w ? 0 : h; w ? S < w : S >= 0; w ? S++ : S--) {
                                    var C = b[S];
                                    C = x(C, S, e);
                                    var P = e.globals.gridWidth + e.globals.padHorizontal - (g - d + e.config.xaxis.labels.offsetX);
                                    if (v.length) {
                                        var T = this.axesUtils.getLabel(b, v, P, S, this.drawnLabels, this.xaxisFontSize);
                                        P = T.x, C = T.text, this.drawnLabels.push(T.text), 0 === S && e.globals.skipFirstTimelinelabel && (C = ""), S === b.length - 1 && e.globals.skipLastTimelinelabel && (C = "")
                                    }
                                    var I = i.drawText({
                                        x: P,
                                        y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
                                        text: C,
                                        textAnchor: "middle",
                                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
                                        fontSize: this.xaxisFontSize,
                                        fontFamily: this.xaxisFontFamily,
                                        fontWeight: e.config.xaxis.labels.style.fontWeight,
                                        isPlainText: !1,
                                        cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
                                    });
                                    l.add(I), I.tspan(C);
                                    var R = document.createElementNS(e.globals.SVGNS, "title");
                                    R.textContent = C, I.node.appendChild(R), g += d
                                }
                            return this.inversedYAxisTitleText(r), this.inversedYAxisBorder(r), r
                        }
                    }, {
                        key: "inversedYAxisBorder",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx),
                                r = e.config.xaxis.axisBorder;
                            if (r.show) {
                                var l = 0;
                                "bar" === e.config.chart.type && e.globals.isXNumeric && (l -= 15);
                                var h = i.drawLine(e.globals.padHorizontal + l + r.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, r.color, 0, r.height);
                                this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(h) : t.add(h)
                            }
                        }
                    }, {
                        key: "inversedYAxisTitleText",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx);
                            if (void 0 !== e.config.xaxis.title.text) {
                                var r = i.group({
                                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                                    }),
                                    l = i.drawText({
                                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
                                        text: e.config.xaxis.title.text,
                                        textAnchor: "middle",
                                        fontSize: e.config.xaxis.title.style.fontSize,
                                        fontFamily: e.config.xaxis.title.style.fontFamily,
                                        fontWeight: e.config.xaxis.title.style.fontWeight,
                                        foreColor: e.config.xaxis.title.style.color,
                                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                                    });
                                r.add(l), t.add(r)
                            }
                        }
                    }, {
                        key: "yAxisTitleRotate",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ot(this.ctx),
                                l = {
                                    width: 0,
                                    height: 0
                                },
                                h = {
                                    width: 0,
                                    height: 0
                                },
                                d = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
                            null !== d && (l = d.getBoundingClientRect());
                            var g = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
                            if (null !== g && (h = g.getBoundingClientRect()), null !== g) {
                                var x = this.xPaddingForYAxisTitle(t, l, h, e);
                                g.setAttribute("x", x.xPos - (e ? 10 : 0))
                            }
                            if (null !== g) {
                                var b = r.rotateAroundCenter(g);
                                g.setAttribute("transform", "rotate(".concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(b.x, " ").concat(b.y, ")"))
                            }
                        }
                    }, {
                        key: "xPaddingForYAxisTitle",
                        value: function(t, e, i, r) {
                            var l = this.w,
                                h = 0,
                                d = 0,
                                g = 10;
                            return void 0 === l.config.yaxis[t].title.text || t < 0 ? {
                                xPos: d,
                                padd: 0
                            } : (r ? (d = e.width + l.config.yaxis[t].title.offsetX + i.width / 2 + g / 2, 0 === (h += 1) && (d -= g / 2)) : (d = -1 * e.width + l.config.yaxis[t].title.offsetX + g / 2 + i.width / 2, l.globals.isBarHorizontal && (d = -1 * e.width - l.config.yaxis[t].title.offsetX - (g = 25))), {
                                xPos: d,
                                padd: g
                            })
                        }
                    }, {
                        key: "setYAxisXPosition",
                        value: function(t, e) {
                            var i = this.w,
                                r = 0,
                                l = 0,
                                h = 18,
                                d = 1;
                            i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function(g, x) {
                                var b = i.globals.ignoreYAxisIndexes.indexOf(x) > -1 || !g.show || g.floating || 0 === t[x].width,
                                    v = t[x].width + e[x].width;
                                g.opposite ? i.globals.isBarHorizontal ? i.globals.translateYAxisX[x] = (l = i.globals.gridWidth + i.globals.translateX - 1) - g.labels.offsetX : (l = i.globals.gridWidth + i.globals.translateX + d, b || (d = d + v + 20), i.globals.translateYAxisX[x] = l - g.labels.offsetX + 20) : (r = i.globals.translateX - h, b || (h = h + v + 20), i.globals.translateYAxisX[x] = r + g.labels.offsetX)
                            })
                        }
                    }, {
                        key: "setYAxisTextAlignments",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                            (e = q.listToArray(e)).forEach(function(i, r) {
                                var l = t.config.yaxis[r];
                                if (l && !l.floating && void 0 !== l.labels.align) {
                                    var h = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(r, "'] .apexcharts-yaxis-texts-g")),
                                        d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(r, "'] .apexcharts-yaxis-label"));
                                    d = q.listToArray(d);
                                    var g = h.getBoundingClientRect();
                                    "left" === l.labels.align ? (d.forEach(function(x, b) {
                                        x.setAttribute("text-anchor", "start")
                                    }), l.opposite || h.setAttribute("transform", "translate(-".concat(g.width, ", 0)"))) : "center" === l.labels.align ? (d.forEach(function(x, b) {
                                        x.setAttribute("text-anchor", "middle")
                                    }), h.setAttribute("transform", "translate(".concat(g.width / 2 * (l.opposite ? 1 : -1), ", 0)"))) : "right" === l.labels.align && (d.forEach(function(x, b) {
                                        x.setAttribute("text-anchor", "end")
                                    }), l.opposite && h.setAttribute("transform", "translate(".concat(g.width, ", 0)")))
                                }
                            })
                        }
                    }]), _
                }(),
                zt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.documentEvent = q.bind(this.documentEvent, this)
                    }
                    return ht(_, [{
                        key: "addEventListener",
                        value: function(t, e) {
                            var i = this.w;
                            i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e]
                        }
                    }, {
                        key: "removeEventListener",
                        value: function(t, e) {
                            var i = this.w;
                            if (i.globals.events.hasOwnProperty(t)) {
                                var r = i.globals.events[t].indexOf(e); - 1 !== r && i.globals.events[t].splice(r, 1)
                            }
                        }
                    }, {
                        key: "fireEvent",
                        value: function(t, e) {
                            var i = this.w;
                            if (i.globals.events.hasOwnProperty(t)) {
                                e && e.length || (e = []);
                                for (var r = i.globals.events[t], l = r.length, h = 0; h < l; h++) r[h].apply(null, e)
                            }
                        }
                    }, {
                        key: "setupEventHandlers",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.ctx,
                                r = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
                            this.ctx.eventList.forEach(function(l) {
                                r.addEventListener(l, function(h) {
                                    var d = Object.assign({}, e, {
                                        seriesIndex: e.globals.capturedSeriesIndex,
                                        dataPointIndex: e.globals.capturedDataPointIndex
                                    });
                                    "mousemove" === h.type || "touchmove" === h.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(h, i, d) : "mouseleave" === h.type || "touchleave" === h.type ? "function" == typeof e.config.chart.events.mouseLeave && e.config.chart.events.mouseLeave(h, i, d) : ("mouseup" === h.type && 1 === h.which || "touchend" === h.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(h, i, d), i.ctx.events.fireEvent("click", [h, i, d]))
                                }, {
                                    capture: !1,
                                    passive: !0
                                })
                            }), this.ctx.eventList.forEach(function(l) {
                                e.globals.dom.baseEl.addEventListener(l, t.documentEvent, {
                                    passive: !0
                                })
                            }), this.ctx.core.setupBrushHandler()
                        }
                    }, {
                        key: "documentEvent",
                        value: function(t) {
                            var e = this.w,
                                i = t.target.className;
                            if ("click" === t.type) {
                                var r = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
                                r && r.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && r.classList.remove("apexcharts-menu-open")
                            }
                            e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY
                        }
                    }]), _
                }(),
                Qt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "setCurrentLocaleValues",
                        value: function(t) {
                            var e = this.w.config.chart.locales;
                            window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                            var i = e.filter(function(l) {
                                return l.name === t
                            })[0];
                            if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                            var r = q.extend(Bi, i);
                            this.w.globals.locale = r.options
                        }
                    }]), _
                }(),
                Tt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "drawAxis",
                        value: function(t, e) {
                            var i, r, l = this,
                                h = this.w.globals,
                                d = this.w.config,
                                g = new Ye(this.ctx, e),
                                x = new pi(this.ctx, e);
                            h.axisCharts && "radar" !== t && (h.isBarHorizontal ? (r = x.drawYaxisInversed(0), i = g.drawXaxisInversed(0), h.dom.elGraphical.add(i), h.dom.elGraphical.add(r)) : (i = g.drawXaxis(), h.dom.elGraphical.add(i), d.yaxis.map(function(b, v) {
                                if (-1 === h.ignoreYAxisIndexes.indexOf(v) && (r = x.drawYaxis(v), h.dom.Paper.add(r), "back" === l.w.config.grid.position)) {
                                    var w = h.dom.Paper.children()[1];
                                    w.remove(), h.dom.Paper.add(w)
                                }
                            })))
                        }
                    }]), _
                }(),
                $t = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "drawXCrosshairs",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx),
                                i = new ae(this.ctx),
                                r = t.config.xaxis.crosshairs.fill.gradient,
                                l = t.config.xaxis.crosshairs.dropShadow,
                                w = l.enabled,
                                S = l.left,
                                C = l.top,
                                P = l.blur,
                                T = l.color,
                                I = l.opacity,
                                R = t.config.xaxis.crosshairs.fill.color;
                            if (t.config.xaxis.crosshairs.show) {
                                "gradient" === t.config.xaxis.crosshairs.fill.type && (R = e.drawGradient("vertical", r.colorFrom, r.colorTo, r.opacityFrom, r.opacityTo, null, r.stops, null));
                                var p = e.drawRect();
                                1 === t.config.xaxis.crosshairs.width && (p = e.drawLine());
                                var k = t.globals.gridHeight;
                                (!q.isNumber(k) || k < 0) && (k = 0);
                                var M = t.config.xaxis.crosshairs.width;
                                (!q.isNumber(M) || M < 0) && (M = 0), p.attr({
                                    class: "apexcharts-xcrosshairs",
                                    x: 0,
                                    y: 0,
                                    y2: k,
                                    width: M,
                                    height: k,
                                    fill: R,
                                    filter: "none",
                                    "fill-opacity": t.config.xaxis.crosshairs.opacity,
                                    stroke: t.config.xaxis.crosshairs.stroke.color,
                                    "stroke-width": t.config.xaxis.crosshairs.stroke.width,
                                    "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
                                }), w && (p = i.dropShadow(p, {
                                    left: S,
                                    top: C,
                                    blur: P,
                                    color: T,
                                    opacity: I
                                })), t.globals.dom.elGraphical.add(p)
                            }
                        }
                    }, {
                        key: "drawYCrosshairs",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx),
                                i = t.config.yaxis[0].crosshairs,
                                r = t.globals.barPadForNumericAxis;
                            if (t.config.yaxis[0].crosshairs.show) {
                                var l = e.drawLine(-r, 0, t.globals.gridWidth + r, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
                                l.attr({
                                    class: "apexcharts-ycrosshairs"
                                }), t.globals.dom.elGraphical.add(l)
                            }
                            var h = e.drawLine(-r, 0, t.globals.gridWidth + r, 0, i.stroke.color, 0, 0);
                            h.attr({
                                class: "apexcharts-ycrosshairs-hidden"
                            }), t.globals.dom.elGraphical.add(h)
                        }
                    }]), _
                }(),
                Jt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "checkResponsiveConfig",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = i.config;
                            if (0 !== r.responsive.length) {
                                var l = r.responsive.slice();
                                l.sort(function(x, b) {
                                    return x.breakpoint > b.breakpoint ? 1 : b.breakpoint > x.breakpoint ? -1 : 0
                                }).reverse();
                                var h = new Pe({}),
                                    d = function() {
                                        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                            v = window.innerWidth > 0 ? window.innerWidth : screen.width;
                                        if (v > l[0].breakpoint) {
                                            var w = te.extendArrayProps(h, i.globals.initialConfig, i);
                                            x = q.extend(w, x), x = q.extend(i.config, x), e.overrideResponsiveOptions(x)
                                        } else
                                            for (var S = 0; S < l.length; S++) v < l[S].breakpoint && (x = te.extendArrayProps(h, l[S].options, i), x = q.extend(i.config, x), e.overrideResponsiveOptions(x))
                                    };
                                if (t) {
                                    var g = te.extendArrayProps(h, t, i);
                                    g = q.extend(i.config, g), d(g = q.extend(g, t))
                                } else d({})
                            }
                        }
                    }, {
                        key: "overrideResponsiveOptions",
                        value: function(t) {
                            var e = new Pe(t).init({
                                responsiveOverride: !0
                            });
                            this.w.config = e
                        }
                    }]), _
                }(),
                Ct = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.colors = [], this.w = t.w;
                        var e = this.w;
                        this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === e.config.chart.type && e.config.plotOptions.treemap.distributed || "heatmap" === e.config.chart.type && e.config.plotOptions.heatmap.distributed, this.isBarDistributed = e.config.plotOptions.bar.distributed && ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type)
                    }
                    return ht(_, [{
                        key: "init",
                        value: function() {
                            this.setDefaultColors()
                        }
                    }, {
                        key: "setDefaultColors",
                        value: function() {
                            var t, e = this,
                                i = this.w,
                                r = new q;
                            if (i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)), void 0 === i.config.colors || 0 === (null === (t = i.config.colors) || void 0 === t ? void 0 : t.length) ? i.globals.colors = this.predefined() : (i.globals.colors = i.config.colors, Array.isArray(i.config.colors) && i.config.colors.length > 0 && "function" == typeof i.config.colors[0] && (i.globals.colors = i.config.series.map(function(C, P) {
                                    var T = i.config.colors[P];
                                    return T || (T = i.config.colors[0]), "function" == typeof T ? (e.isColorFn = !0, T({
                                        value: i.globals.axisCharts ? i.globals.series[P][0] ? i.globals.series[P][0] : 0 : i.globals.series[P],
                                        seriesIndex: P,
                                        dataPointIndex: P,
                                        w: i
                                    })) : T
                                }))), i.globals.seriesColors.map(function(C, P) {
                                    C && (i.globals.colors[P] = C)
                                }), i.config.theme.monochrome.enabled) {
                                var l = [],
                                    h = i.globals.series.length;
                                (this.isBarDistributed || this.isHeatmapDistributed) && (h = i.globals.series[0].length * i.globals.series.length);
                                for (var d = i.config.theme.monochrome.color, g = 1 / (h / i.config.theme.monochrome.shadeIntensity), x = i.config.theme.monochrome.shadeTo, b = 0, v = 0; v < h; v++) {
                                    var w = void 0;
                                    "dark" === x ? (w = r.shadeColor(-1 * b, d), b += g) : (w = r.shadeColor(b, d), b += g), l.push(w)
                                }
                                i.globals.colors = l.slice()
                            }
                            var S = i.globals.colors.slice();
                            this.pushExtraColors(i.globals.colors), ["fill", "stroke"].forEach(function(C) {
                                i.globals[C].colors = void 0 === i.config[C].colors ? e.isColorFn ? i.config.colors : S : i.config[C].colors.slice(), e.pushExtraColors(i.globals[C].colors)
                            }), i.globals.dataLabels.style.colors = void 0 === i.config.dataLabels.style.colors ? S : i.config.dataLabels.style.colors.slice(), this.pushExtraColors(i.globals.dataLabels.style.colors, 50), i.globals.radarPolygons.fill.colors = void 0 === i.config.plotOptions.radar.polygons.fill.colors ? ["dark" === i.config.theme.mode ? "#424242" : "none"] : i.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i.globals.radarPolygons.fill.colors, 20), i.globals.markers.colors = void 0 === i.config.markers.colors ? S : i.config.markers.colors.slice(), this.pushExtraColors(i.globals.markers.colors)
                        }
                    }, {
                        key: "pushExtraColors",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                r = this.w,
                                l = e || r.globals.series.length;
                            if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === r.config.chart.type && r.config.plotOptions.heatmap.colorScale.inverse), i && r.globals.series.length && (l = r.globals.series[r.globals.maxValsInArrayIndex].length * r.globals.series.length), t.length < l)
                                for (var h = l - t.length, d = 0; d < h; d++) t.push(t[d])
                        }
                    }, {
                        key: "updateThemeOptions",
                        value: function(t) {
                            t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
                            var e = t.theme.mode || "light",
                                i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
                                r = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
                            return t.tooltip.theme = e, t.chart.foreColor = r, t.theme.palette = i, t
                        }
                    }, {
                        key: "predefined",
                        value: function() {
                            switch (this.w.config.theme.palette) {
                                case "palette1":
                                default:
                                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                                    break;
                                case "palette2":
                                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                                    break;
                                case "palette3":
                                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                                    break;
                                case "palette4":
                                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                                    break;
                                case "palette5":
                                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                                    break;
                                case "palette6":
                                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                                    break;
                                case "palette7":
                                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                                    break;
                                case "palette8":
                                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                                    break;
                                case "palette9":
                                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                                    break;
                                case "palette10":
                                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
                            }
                            return this.colors
                        }
                    }]), _
                }(),
                Qi = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function() {
                            this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
                        }
                    }, {
                        key: "drawTitleSubtitle",
                        value: function(t) {
                            var e = this.w,
                                i = "title" === t ? e.config.title : e.config.subtitle,
                                r = e.globals.svgWidth / 2,
                                l = i.offsetY,
                                h = "middle";
                            if ("left" === i.align ? (r = 10, h = "start") : "right" === i.align && (r = e.globals.svgWidth - 10, h = "end"), r += i.offsetX, l = l + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
                                var d = new ot(this.ctx).drawText({
                                    x: r,
                                    y: l,
                                    text: i.text,
                                    textAnchor: h,
                                    fontSize: i.style.fontSize,
                                    fontFamily: i.style.fontFamily,
                                    fontWeight: i.style.fontWeight,
                                    foreColor: i.style.color,
                                    opacity: 1
                                });
                                d.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(d)
                            }
                        }
                    }]), _
                }(),
                Wi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.dCtx = t
                    }
                    return ht(_, [{
                        key: "getTitleSubtitleCoords",
                        value: function(t) {
                            var e = this.w,
                                i = 0,
                                r = 0,
                                l = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
                                h = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
                            if (null !== h && !l) {
                                var d = h.getBoundingClientRect();
                                i = d.width, r = e.globals.axisCharts ? d.height + 5 : d.height
                            }
                            return {
                                width: i,
                                height: r
                            }
                        }
                    }, {
                        key: "getLegendsRect",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.elLegendWrap;
                            t.config.legend.height || "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
                            var i = Object.assign({}, q.getBoundingClientRect(e));
                            return this.dCtx.lgRect = null !== e && !t.config.legend.floating && t.config.legend.show ? {
                                x: i.x,
                                y: i.y,
                                height: i.height,
                                width: 0 === i.height ? 0 : i.width
                            } : {
                                x: 0,
                                y: 0,
                                height: 0,
                                width: 0
                            }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect
                        }
                    }, {
                        key: "getLargestStringFromMultiArr",
                        value: function(t, e) {
                            var i = t;
                            if (this.w.globals.isMultiLineX) {
                                var r = e.map(function(h, d) {
                                        return Array.isArray(h) ? h.length : 1
                                    }),
                                    l = Math.max.apply(Math, le(r));
                                i = e[r.indexOf(l)]
                            }
                            return i
                        }
                    }]), _
                }(),
                qt = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.dCtx = t
                    }
                    return ht(_, [{
                        key: "getxAxisLabelsCoords",
                        value: function() {
                            var t, e = this.w,
                                i = e.globals.labels.slice();
                            if (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
                                var r = this.getxAxisTimeScaleLabelsCoords();
                                t = {
                                    width: r.width,
                                    height: r.height
                                }, e.globals.rotateXLabels = !1
                            } else {
                                this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                                var l = e.globals.xLabelFormatter,
                                    h = q.getLargestStringFromArr(i),
                                    d = this.dCtx.dimHelpers.getLargestStringFromMultiArr(h, i);
                                e.globals.isBarHorizontal && (d = h = e.globals.yAxisScale[0].result.reduce(function(C, P) {
                                    return C.length > P.length ? C : P
                                }, 0));
                                var g = new Be(this.dCtx.ctx),
                                    x = h;
                                h = g.xLabelFormat(l, h, x, {
                                    i: void 0,
                                    dateFormatter: new ne(this.dCtx.ctx).formatDate,
                                    w: e
                                }), d = g.xLabelFormat(l, d, x, {
                                    i: void 0,
                                    dateFormatter: new ne(this.dCtx.ctx).formatDate,
                                    w: e
                                }), (e.config.xaxis.convertedCatToNumeric && void 0 === h || "" === String(h).trim()) && (d = h = "1");
                                var b = new ot(this.dCtx.ctx),
                                    v = b.getTextRects(h, e.config.xaxis.labels.style.fontSize),
                                    w = v;
                                if (h !== d && (w = b.getTextRects(d, e.config.xaxis.labels.style.fontSize)), (t = {
                                        width: v.width >= w.width ? v.width : w.width,
                                        height: v.height >= w.height ? v.height : w.height
                                    }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
                                    if (!e.globals.isBarHorizontal) {
                                        e.globals.rotateXLabels = !0;
                                        var S = function(C) {
                                            return b.getTextRects(C, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1)
                                        };
                                        v = S(h), h !== d && (w = S(d)), t.height = (v.height > w.height ? v.height : w.height) / 1.5, t.width = v.width > w.width ? v.width : w.width
                                    }
                                } else e.globals.rotateXLabels = !1
                            }
                            return e.config.xaxis.labels.show || (t = {
                                width: 0,
                                height: 0
                            }), {
                                width: t.width,
                                height: t.height
                            }
                        }
                    }, {
                        key: "getxAxisGroupLabelsCoords",
                        value: function() {
                            var t, e = this.w;
                            if (!e.globals.hasXaxisGroups) return {
                                width: 0,
                                height: 0
                            };
                            var i, r = (null === (t = e.config.xaxis.group.style) || void 0 === t ? void 0 : t.fontSize) || e.config.xaxis.labels.style.fontSize,
                                l = e.globals.groups.map(function(v) {
                                    return v.title
                                }),
                                h = q.getLargestStringFromArr(l),
                                d = this.dCtx.dimHelpers.getLargestStringFromMultiArr(h, l),
                                g = new ot(this.dCtx.ctx),
                                x = g.getTextRects(h, r),
                                b = x;
                            return h !== d && (b = g.getTextRects(d, r)), i = {
                                width: x.width >= b.width ? x.width : b.width,
                                height: x.height >= b.height ? x.height : b.height
                            }, e.config.xaxis.labels.show || (i = {
                                width: 0,
                                height: 0
                            }), {
                                width: i.width,
                                height: i.height
                            }
                        }
                    }, {
                        key: "getxAxisTitleCoords",
                        value: function() {
                            var t = this.w,
                                e = 0,
                                i = 0;
                            if (void 0 !== t.config.xaxis.title.text) {
                                var r = new ot(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
                                e = r.width, i = r.height
                            }
                            return {
                                width: e,
                                height: i
                            }
                        }
                    }, {
                        key: "getxAxisTimeScaleLabelsCoords",
                        value: function() {
                            var t, e = this.w;
                            this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
                            var i = this.dCtx.timescaleLabels.map(function(l) {
                                    return l.value
                                }),
                                r = i.reduce(function(l, h) {
                                    return void 0 === l ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : l.length > h.length ? l : h
                                }, 0);
                            return 1.05 * (t = new ot(this.dCtx.ctx).getTextRects(r, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t
                        }
                    }, {
                        key: "additionalPaddingXLabels",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = i.globals,
                                l = i.config,
                                h = l.xaxis.type,
                                d = t.width;
                            r.skipLastTimelinelabel = !1, r.skipFirstTimelinelabel = !1;
                            var g = i.config.yaxis[0].opposite && i.globals.isBarHorizontal;
                            l.yaxis.forEach(function(b, v) {
                                g ? (e.dCtx.gridPad.left < d && (e.dCtx.xPadLeft = d / 2 + 1), e.dCtx.xPadRight = d / 2 + 1) : function(b, v) {
                                    l.yaxis.length > 1 && -1 !== r.collapsedSeriesIndices.indexOf(v) || function(w) {
                                        if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
                                            var P = e.dCtx.timescaleLabels[0].position - d / 1.75 + e.dCtx.yAxisWidthLeft;
                                            e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + d / 1.75 - e.dCtx.yAxisWidthRight > r.svgWidth - r.translateX - ("right" === i.config.legend.position && e.dCtx.lgRect.width > 0 ? e.dCtx.lgRect.width : 0) && (r.skipLastTimelinelabel = !0), P < -(w.show && !w.floating || "bar" !== l.chart.type && "candlestick" !== l.chart.type && "rangeBar" !== l.chart.type && "boxPlot" !== l.chart.type ? 10 : d / 1.75) && (r.skipFirstTimelinelabel = !0)
                                        } else "datetime" === h ? e.dCtx.gridPad.right < d && !r.rotateXLabels && (r.skipLastTimelinelabel = !0) : "datetime" !== h && e.dCtx.gridPad.right < d / 2 - e.dCtx.yAxisWidthRight && !r.rotateXLabels && !i.config.xaxis.labels.trim && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = d / 2 + 1)
                                    }(b)
                                }(b, v)
                            })
                        }
                    }]), _
                }(),
                Yt = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.dCtx = t
                    }
                    return ht(_, [{
                        key: "getyAxisLabelsCoords",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = [],
                                r = 10,
                                l = new Le(this.dCtx.ctx);
                            return e.config.yaxis.map(function(h, d) {
                                var g = {
                                        seriesIndex: d,
                                        dataPointIndex: -1,
                                        w: e
                                    },
                                    x = e.globals.yAxisScale[d],
                                    b = 0;
                                if (!l.isYAxisHidden(d) && h.labels.show && void 0 !== h.labels.minWidth && (b = h.labels.minWidth), !l.isYAxisHidden(d) && h.labels.show && x.result.length) {
                                    var v = e.globals.yLabelFormatters[d],
                                        S = x.result.reduce(function(k, M) {
                                            var D, X;
                                            return (null === (D = String(v(k, g))) || void 0 === D ? void 0 : D.length) > (null === (X = String(v(M, g))) || void 0 === X ? void 0 : X.length) ? k : M
                                        }, x.niceMin === Number.MIN_VALUE ? 0 : x.niceMin),
                                        C = S = v(S, g);
                                    if (void 0 !== S && 0 !== S.length || (S = x.niceMax), e.globals.isBarHorizontal) {
                                        r = 0;
                                        var P = e.globals.labels.slice();
                                        S = q.getLargestStringFromArr(P), S = v(S, {
                                            seriesIndex: d,
                                            dataPointIndex: -1,
                                            w: e
                                        }), C = t.dCtx.dimHelpers.getLargestStringFromMultiArr(S, P)
                                    }
                                    var T = new ot(t.dCtx.ctx),
                                        I = "rotate(".concat(h.labels.rotate, " 0 0)"),
                                        R = T.getTextRects(S, h.labels.style.fontSize, h.labels.style.fontFamily, I, !1),
                                        p = R;
                                    S !== C && (p = T.getTextRects(C, h.labels.style.fontSize, h.labels.style.fontFamily, I, !1)), i.push({
                                        width: (b > p.width || b > R.width ? b : p.width > R.width ? p.width : R.width) + r,
                                        height: p.height > R.height ? p.height : R.height
                                    })
                                } else i.push({
                                    width: 0,
                                    height: 0
                                })
                            }), i
                        }
                    }, {
                        key: "getyAxisTitleCoords",
                        value: function() {
                            var t = this,
                                i = [];
                            return this.w.config.yaxis.map(function(r, l) {
                                if (r.show && void 0 !== r.title.text) {
                                    var h = new ot(t.dCtx.ctx),
                                        d = "rotate(".concat(r.title.rotate, " 0 0)"),
                                        g = h.getTextRects(r.title.text, r.title.style.fontSize, r.title.style.fontFamily, d, !1);
                                    i.push({
                                        width: g.width,
                                        height: g.height
                                    })
                                } else i.push({
                                    width: 0,
                                    height: 0
                                })
                            }), i
                        }
                    }, {
                        key: "getTotalYAxisWidth",
                        value: function() {
                            var t = this.w,
                                e = 0,
                                i = 0,
                                r = 0,
                                l = t.globals.yAxisScale.length > 1 ? 10 : 0,
                                h = new Le(this.dCtx.ctx),
                                d = function(g, x) {
                                    var b = t.config.yaxis[x].floating,
                                        v = 0;
                                    g.width > 0 && !b ? (v = g.width + l, t.globals.ignoreYAxisIndexes.indexOf(x) > -1 && (v = v - g.width - l)) : v = b || h.isYAxisHidden(x) ? 0 : 5, t.config.yaxis[x].opposite ? r += v : i += v, e += v
                                };
                            return t.globals.yLabelsCoords.map(function(g, x) {
                                d(g, x)
                            }), t.globals.yTitleCoords.map(function(g, x) {
                                d(g, x)
                            }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = r, e
                        }
                    }]), _
                }(),
                xi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.dCtx = t
                    }
                    return ht(_, [{
                        key: "gridPadForColumnsInNumericAxis",
                        value: function(t) {
                            var e = this.w;
                            if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
                            var i = function(b) {
                                    return "bar" === b || "rangeBar" === b || "candlestick" === b || "boxPlot" === b
                                },
                                r = e.config.chart.type,
                                l = 0,
                                h = i(r) ? e.config.series.length : 1;
                            if (e.globals.comboBarCount > 0 && (h = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(function(b) {
                                    i(b.type) && (h -= 1)
                                }), e.config.chart.stacked && (h = 1), (i(r) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && h > 0) {
                                var d, g, x = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
                                x <= 3 && (x = e.globals.dataPoints), d = x / t, e.globals.minXDiff && e.globals.minXDiff / d > 0 && (g = e.globals.minXDiff / d), g > t / 2 && (g /= 2), (l = g / h * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (l = 1), e.globals.barPadForNumericAxis = l = l / (h > 1 ? 1 : 1.5) + 5
                            }
                            return l
                        }
                    }, {
                        key: "gridPadFortitleSubtitle",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.globals,
                                r = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
                            ["title", "subtitle"].forEach(function(d) {
                                r += void 0 !== e.config[d].text ? e.config[d].margin : t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5
                            }), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (r += 10);
                            var l = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
                                h = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                            i.gridHeight = i.gridHeight - l.height - h.height - r, i.translateY = i.translateY + l.height + h.height + r
                        }
                    }, {
                        key: "setGridXPosForDualYAxis",
                        value: function(t, e) {
                            var i = this.w,
                                r = new Le(this.dCtx.ctx);
                            i.config.yaxis.map(function(l, h) {
                                -1 !== i.globals.ignoreYAxisIndexes.indexOf(h) || l.floating || r.isYAxisHidden(h) || (l.opposite && (i.globals.translateX = i.globals.translateX - (e[h].width + t[h].width) - parseInt(i.config.yaxis[h].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2))
                            })
                        }
                    }]), _
                }(),
                Ve = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Wi(this), this.dimYAxis = new Yt(this), this.dimXAxis = new qt(this), this.dimGrid = new xi(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
                    }
                    return ht(_, [{
                        key: "plotCoords",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.globals;
                            this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (e.config.markers.discrete.length > 0 || e.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(l) {
                                var h = ze(l, 2);
                                t.gridPad[h[0]] = Math.max(h[1], t.w.globals.markers.largestSize / 1.5)
                            }), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                            var r = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
                            i.gridWidth = i.gridWidth - 2 * r, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (r > 0 ? r + 4 : 0), i.translateY = i.translateY + this.gridPad.top
                        }
                    }, {
                        key: "setDimensionsForAxisCharts",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.globals,
                                r = this.dimYAxis.getyAxisLabelsCoords(),
                                l = this.dimYAxis.getyAxisTitleCoords();
                            e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(function(S, C) {
                                e.globals.yLabelsCoords.push({
                                    width: r[C].width,
                                    index: C
                                }), e.globals.yTitleCoords.push({
                                    width: l[C].width,
                                    index: C
                                })
                            }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                            var h = this.dimXAxis.getxAxisLabelsCoords(),
                                d = this.dimXAxis.getxAxisGroupLabelsCoords(),
                                g = this.dimXAxis.getxAxisTitleCoords();
                            this.conditionalChecksForAxisCoords(h, g, d), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
                            var x = this.yAxisWidth,
                                b = this.xAxisHeight;
                            i.xAxisLabelsHeight = this.xAxisHeight - g.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - h.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
                            var v = 10;
                            ("radar" === e.config.chart.type || this.isSparkline) && (x = 0, b = i.goldenPadding), this.isSparkline && (this.lgRect = {
                                height: 0,
                                width: 0
                            }), (this.isSparkline || "treemap" === e.config.chart.type) && (x = 0, b = 0, v = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(h);
                            var w = function() {
                                i.translateX = x, i.gridHeight = i.svgHeight - t.lgRect.height - b - (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - x
                            };
                            switch ("top" === e.config.xaxis.position && (v = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
                                case "bottom":
                                    i.translateY = v, w();
                                    break;
                                case "top":
                                    i.translateY = this.lgRect.height + v, w();
                                    break;
                                case "left":
                                    i.translateY = v, i.translateX = this.lgRect.width + x, i.gridHeight = i.svgHeight - b - 12, i.gridWidth = i.svgWidth - this.lgRect.width - x;
                                    break;
                                case "right":
                                    i.translateY = v, i.translateX = x, i.gridHeight = i.svgHeight - b - 12, i.gridWidth = i.svgWidth - this.lgRect.width - x - 5;
                                    break;
                                default:
                                    throw new Error("Legend position not supported")
                            }
                            this.dimGrid.setGridXPosForDualYAxis(l, r), new pi(this.ctx).setYAxisXPosition(r, l)
                        }
                    }, {
                        key: "setDimensionsForNonAxisCharts",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = t.config,
                                r = 0;
                            t.config.legend.show && !t.config.legend.floating && (r = 20);
                            var l = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar",
                                h = i.plotOptions[l].offsetY,
                                d = i.plotOptions[l].offsetX;
                            if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = h, void(e.translateX = d + (e.svgWidth - e.gridWidth) / 2);
                            switch (i.legend.position) {
                                case "bottom":
                                    e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = h - 10, e.translateX = d + (e.svgWidth - e.gridWidth) / 2;
                                    break;
                                case "top":
                                    e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = this.lgRect.height + h + 10, e.translateX = d + (e.svgWidth - e.gridWidth) / 2;
                                    break;
                                case "left":
                                    e.gridWidth = e.svgWidth - this.lgRect.width - r, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = h, e.translateX = d + this.lgRect.width + r;
                                    break;
                                case "right":
                                    e.gridWidth = e.svgWidth - this.lgRect.width - r - 5, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = h, e.translateX = d + 10;
                                    break;
                                default:
                                    throw new Error("Legend position not supported")
                            }
                        }
                    }, {
                        key: "conditionalChecksForAxisCoords",
                        value: function(t, e, i) {
                            var r = this.w;
                            this.xAxisHeight = (i.height + t.height + e.height) * (r.globals.isMultiLineX ? 1.2 : r.globals.LINE_HEIGHT_RATIO) + (r.globals.hasXaxisGroups ? 2 : 1) * (r.globals.rotateXLabels ? 22 : 10) + (r.globals.rotateXLabels && "bottom" === r.config.legend.position ? 10 : 0), this.xAxisWidth = t.width, this.xAxisHeight - e.height > r.config.xaxis.labels.maxHeight && (this.xAxisHeight = r.config.xaxis.labels.maxHeight), r.config.xaxis.labels.minHeight && this.xAxisHeight < r.config.xaxis.labels.minHeight && (this.xAxisHeight = r.config.xaxis.labels.minHeight), r.config.xaxis.floating && (this.xAxisHeight = 0);
                            var b = 0,
                                v = 0;
                            r.config.yaxis.forEach(function(w) {
                                b += w.labels.minWidth, v += w.labels.maxWidth
                            }), this.yAxisWidth < b && (this.yAxisWidth = b), this.yAxisWidth > v && (this.yAxisWidth = v)
                        }
                    }]), _
                }(),
                mi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.lgCtx = t
                    }
                    return ht(_, [{
                        key: "getLegendStyles",
                        value: function() {
                            var t = document.createElement("style");
                            t.setAttribute("type", "text/css");
                            var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                            return t.appendChild(e), t
                        }
                    }, {
                        key: "getLegendBBox",
                        value: function() {
                            var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect();
                            return {
                                clwh: t.height,
                                clww: t.width
                            }
                        }
                    }, {
                        key: "appendToForeignObject",
                        value: function() {
                            this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())
                        }
                    }, {
                        key: "toggleDataSeries",
                        value: function(t, e) {
                            var i = this,
                                r = this.w;
                            if (r.globals.axisCharts || "radialBar" === r.config.chart.type) {
                                r.globals.resized = !0;
                                var l = null,
                                    h = null;
                                r.globals.risingSeries = [], r.globals.axisCharts ? (l = r.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), h = parseInt(l.getAttribute("data:realIndex"), 10)) : (l = r.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), h = parseInt(l.getAttribute("rel"), 10) - 1), e ? [{
                                    cs: r.globals.collapsedSeries,
                                    csi: r.globals.collapsedSeriesIndices
                                }, {
                                    cs: r.globals.ancillaryCollapsedSeries,
                                    csi: r.globals.ancillaryCollapsedSeriesIndices
                                }].forEach(function(b) {
                                    i.riseCollapsedSeries(b.cs, b.csi, h)
                                }) : this.hideSeries({
                                    seriesEl: l,
                                    realIndex: h
                                })
                            } else {
                                var d = r.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
                                    g = r.config.chart.type;
                                if ("pie" === g || "polarArea" === g || "donut" === g) {
                                    var x = r.config.plotOptions.pie.donut.labels;
                                    new ot(this.lgCtx.ctx).pathMouseDown(d.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(d.members[0].node, x)
                                }
                                d.fire("click")
                            }
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            var e = t.seriesEl,
                                i = t.realIndex,
                                r = this.w,
                                l = q.clone(r.config.series);
                            if (r.globals.axisCharts) {
                                var h = !1;
                                if (r.config.yaxis[i] && r.config.yaxis[i].show && r.config.yaxis[i].showAlways && (h = !0, r.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (r.globals.ancillaryCollapsedSeries.push({
                                        index: i,
                                        data: l[i].data.slice(),
                                        type: e.parentNode.className.baseVal.split("-")[1]
                                    }), r.globals.ancillaryCollapsedSeriesIndices.push(i))), !h) {
                                    r.globals.collapsedSeries.push({
                                        index: i,
                                        data: l[i].data.slice(),
                                        type: e.parentNode.className.baseVal.split("-")[1]
                                    }), r.globals.collapsedSeriesIndices.push(i);
                                    var d = r.globals.risingSeries.indexOf(i);
                                    r.globals.risingSeries.splice(d, 1)
                                }
                            } else r.globals.collapsedSeries.push({
                                index: i,
                                data: l[i]
                            }), r.globals.collapsedSeriesIndices.push(i);
                            for (var g = e.childNodes, x = 0; x < g.length; x++) g[x].classList.contains("apexcharts-series-markers-wrap") && (g[x].classList.contains("apexcharts-hide") ? g[x].classList.remove("apexcharts-hide") : g[x].classList.add("apexcharts-hide"));
                            r.globals.allSeriesCollapsed = r.globals.collapsedSeries.length === r.config.series.length, l = this._getSeriesBasedOnCollapsedState(l), this.lgCtx.ctx.updateHelpers._updateSeries(l, r.config.chart.animations.dynamicAnimation.enabled)
                        }
                    }, {
                        key: "riseCollapsedSeries",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = q.clone(r.config.series);
                            if (t.length > 0) {
                                for (var h = 0; h < t.length; h++) t[h].index === i && (r.globals.axisCharts ? (l[i].data = t[h].data.slice(), t.splice(h, 1), e.splice(h, 1), r.globals.risingSeries.push(i)) : (l[i] = t[h].data, t.splice(h, 1), e.splice(h, 1), r.globals.risingSeries.push(i)));
                                l = this._getSeriesBasedOnCollapsedState(l), this.lgCtx.ctx.updateHelpers._updateSeries(l, r.config.chart.animations.dynamicAnimation.enabled)
                            }
                        }
                    }, {
                        key: "_getSeriesBasedOnCollapsedState",
                        value: function(t) {
                            var e = this.w;
                            return t.forEach(e.globals.axisCharts ? function(i, r) {
                                e.globals.collapsedSeriesIndices.indexOf(r) > -1 && (t[r].data = [])
                            } : function(i, r) {
                                e.globals.collapsedSeriesIndices.indexOf(r) > -1 && (t[r] = 0)
                            }), t
                        }
                    }]), _
                }(),
                bi = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new mi(this)
                    }
                    return ht(_, [{
                        key: "init",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = t.config;
                            if ((i.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
                                for (; e.dom.elLegendWrap.firstChild;) e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
                                this.drawLegends(), q.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical()
                            }
                        }
                    }, {
                        key: "drawLegends",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.config.legend.fontFamily,
                                r = e.globals.seriesNames,
                                l = e.globals.colors.slice();
                            if ("heatmap" === e.config.chart.type) {
                                var h = e.config.plotOptions.heatmap.colorScale.ranges;
                                r = h.map(function(it) {
                                    return it.name ? it.name : it.from + " - " + it.to
                                }), l = h.map(function(it) {
                                    return it.color
                                })
                            } else this.isBarsDistributed && (r = e.globals.labels.slice());
                            e.config.legend.customLegendItems.length && (r = e.config.legend.customLegendItems);
                            for (var d = e.globals.legendFormatter, g = e.config.legend.inverseOrder, x = g ? r.length - 1 : 0; g ? x >= 0 : x <= r.length - 1; g ? x-- : x++) {
                                var b, v = d(r[x], {
                                        seriesIndex: x,
                                        w: e
                                    }),
                                    w = !1,
                                    S = !1;
                                if (e.globals.collapsedSeries.length > 0)
                                    for (var C = 0; C < e.globals.collapsedSeries.length; C++) e.globals.collapsedSeries[C].index === x && (w = !0);
                                if (e.globals.ancillaryCollapsedSeriesIndices.length > 0)
                                    for (var P = 0; P < e.globals.ancillaryCollapsedSeriesIndices.length; P++) e.globals.ancillaryCollapsedSeriesIndices[P] === x && (S = !0);
                                var T = document.createElement("span");
                                T.classList.add("apexcharts-legend-marker");
                                var I = e.config.legend.markers.offsetX,
                                    R = e.config.legend.markers.offsetY,
                                    p = e.config.legend.markers.height,
                                    k = e.config.legend.markers.width,
                                    M = e.config.legend.markers.strokeWidth,
                                    D = e.config.legend.markers.strokeColor,
                                    X = e.config.legend.markers.radius,
                                    H = T.style;
                                H.background = l[x], H.color = l[x], H.setProperty("background", l[x], "important"), e.config.legend.markers.fillColors && e.config.legend.markers.fillColors[x] && (H.background = e.config.legend.markers.fillColors[x]), void 0 !== e.globals.seriesColors[x] && (H.background = e.globals.seriesColors[x], H.color = e.globals.seriesColors[x]), H.height = Array.isArray(p) ? parseFloat(p[x]) + "px" : parseFloat(p) + "px", H.width = Array.isArray(k) ? parseFloat(k[x]) + "px" : parseFloat(k) + "px", H.left = (Array.isArray(I) ? parseFloat(I[x]) : parseFloat(I)) + "px", H.top = (Array.isArray(R) ? parseFloat(R[x]) : parseFloat(R)) + "px", H.borderWidth = Array.isArray(M) ? M[x] : M, H.borderColor = Array.isArray(D) ? D[x] : D, H.borderRadius = Array.isArray(X) ? parseFloat(X[x]) + "px" : parseFloat(X) + "px", e.config.legend.markers.customHTML && (Array.isArray(e.config.legend.markers.customHTML) ? e.config.legend.markers.customHTML[x] && (T.innerHTML = e.config.legend.markers.customHTML[x]()) : T.innerHTML = e.config.legend.markers.customHTML()), ot.setAttrs(T, {
                                    rel: x + 1,
                                    "data:collapsed": w || S
                                }), (w || S) && T.classList.add("apexcharts-inactive-legend");
                                var j = document.createElement("div"),
                                    U = document.createElement("span");
                                U.classList.add("apexcharts-legend-text"), U.innerHTML = Array.isArray(v) ? v.join(" ") : v;
                                var Q = e.config.legend.labels.useSeriesColors ? e.globals.colors[x] : Array.isArray(e.config.legend.labels.colors) ? null === (b = e.config.legend.labels.colors) || void 0 === b ? void 0 : b[x] : e.config.legend.labels.colors;
                                Q || (Q = e.config.chart.foreColor), U.style.color = Q, U.style.fontSize = parseFloat(e.config.legend.fontSize) + "px", U.style.fontWeight = e.config.legend.fontWeight, U.style.fontFamily = i || e.config.chart.fontFamily, ot.setAttrs(U, {
                                    rel: x + 1,
                                    i: x,
                                    "data:default-text": encodeURIComponent(v),
                                    "data:collapsed": w || S
                                }), j.appendChild(T), j.appendChild(U);
                                var at = new te(this.ctx);
                                e.config.legend.showForZeroSeries || 0 === at.getSeriesTotalByIndex(x) && at.seriesHaveSameValues(x) && !at.isSeriesNull(x) && -1 === e.globals.collapsedSeriesIndices.indexOf(x) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(x) && j.classList.add("apexcharts-hidden-zero-series"), e.config.legend.showForNullSeries || at.isSeriesNull(x) && -1 === e.globals.collapsedSeriesIndices.indexOf(x) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(x) && j.classList.add("apexcharts-hidden-null-series"), e.globals.dom.elLegendWrap.appendChild(j), e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)), e.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e.config.legend.position), j.classList.add("apexcharts-legend-series"), j.style.margin = "".concat(e.config.legend.itemMargin.vertical, "px ").concat(e.config.legend.itemMargin.horizontal, "px"), e.globals.dom.elLegendWrap.style.width = e.config.legend.width ? e.config.legend.width + "px" : "", e.globals.dom.elLegendWrap.style.height = e.config.legend.height ? e.config.legend.height + "px" : "", ot.setAttrs(j, {
                                    rel: x + 1,
                                    seriesName: q.escapeString(r[x]),
                                    "data:collapsed": w || S
                                }), (w || S) && j.classList.add("apexcharts-inactive-legend"), e.config.legend.onItemClick.toggleDataSeries || j.classList.add("apexcharts-no-click")
                            }
                            e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), e.config.legend.onItemHover.highlightDataSeries && 0 === e.config.legend.customLegendItems.length && (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0))
                        }
                    }, {
                        key: "setLegendWrapXY",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.globals.dom.elLegendWrap,
                                l = r.getBoundingClientRect(),
                                h = 0,
                                d = 0;
                            if ("bottom" === i.config.legend.position) d += i.globals.svgHeight - l.height / 2;
                            else if ("top" === i.config.legend.position) {
                                var g = new Ve(this.ctx),
                                    x = g.dimHelpers.getTitleSubtitleCoords("title").height,
                                    b = g.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                                d = d + (x > 0 ? x - 10 : 0) + (b > 0 ? b - 10 : 0)
                            }
                            r.style.position = "absolute", d = d + e + i.config.legend.offsetY, r.style.left = (h = h + t + i.config.legend.offsetX) + "px", r.style.top = d + "px", "bottom" === i.config.legend.position ? (r.style.top = "auto", r.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (r.style.left = "auto", r.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(v) {
                                r.style[v] && (r.style[v] = parseInt(i.config.legend[v], 10) + "px")
                            })
                        }
                    }, {
                        key: "legendAlignHorizontal",
                        value: function() {
                            var t = this.w;
                            t.globals.dom.elLegendWrap.style.right = 0;
                            var e = this.legendHelpers.getLegendBBox(),
                                i = new Ve(this.ctx),
                                r = i.dimHelpers.getTitleSubtitleCoords("title"),
                                l = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
                                h = 0;
                            "bottom" === t.config.legend.position ? h = -e.clwh / 1.8 : "top" === t.config.legend.position && (h = r.height + l.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, h)
                        }
                    }, {
                        key: "legendAlignVertical",
                        value: function() {
                            var t = this.w,
                                e = this.legendHelpers.getLegendBBox(),
                                i = 0;
                            "left" === t.config.legend.position && (i = 20), "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20)
                        }
                    }, {
                        key: "onLegendHovered",
                        value: function(t) {
                            var e = this.w,
                                i = t.target.classList.contains("apexcharts-legend-series") || t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
                            if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
                                if (i) {
                                    var r = parseInt(t.target.getAttribute("rel"), 10) - 1;
                                    this.ctx.events.fireEvent("legendHover", [this.ctx, r, this.w]), new xe(this.ctx).highlightRangeInSeries(t, t.target)
                                }
                            } else !t.target.classList.contains("apexcharts-inactive-legend") && i && new xe(this.ctx).toggleSeriesOnHover(t, t.target)
                        }
                    }, {
                        key: "onLegendClick",
                        value: function(t) {
                            var e = this.w;
                            if (!e.config.legend.customLegendItems.length && (t.target.classList.contains("apexcharts-legend-series") || t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker"))) {
                                var i = parseInt(t.target.getAttribute("rel"), 10) - 1,
                                    r = "true" === t.target.getAttribute("data:collapsed"),
                                    l = this.w.config.chart.events.legendClick;
                                "function" == typeof l && l(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                                var h = this.w.config.legend.markers.onClick;
                                "function" == typeof h && t.target.classList.contains("apexcharts-legend-marker") && (h(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), "treemap" !== e.config.chart.type && "heatmap" !== e.config.chart.type && !this.isBarsDistributed && e.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, r)
                            }
                        }
                    }]), _
                }(),
                re = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w;
                        var e = this.w;
                        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = e.globals.minX, this.maxX = e.globals.maxX
                    }
                    return ht(_, [{
                        key: "createToolbar",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = function() {
                                    return document.createElement("div")
                                },
                                r = i();
                            if (r.setAttribute("class", "apexcharts-toolbar"), r.style.top = e.config.chart.toolbar.offsetY + "px", r.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(r), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
                                for (var l = 0; l < this.t.customIcons.length; l++) this.elCustomIcons.push(i());
                            var h = [],
                                d = function(v, w, S) {
                                    var C = v.toLowerCase();
                                    t.t[C] && e.config.chart.zoom.enabled && h.push({
                                        el: w,
                                        icon: "string" == typeof t.t[C] ? t.t[C] : S,
                                        title: t.localeValues[v],
                                        class: "apexcharts-".concat(C, "-icon")
                                    })
                                };
                            d("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), d("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                            var g = function(v) {
                                t.t[v] && e.config.chart[v].enabled && h.push({
                                    el: "zoom" === v ? t.elZoom : t.elSelection,
                                    icon: "string" == typeof t.t[v] ? t.t[v] : "zoom" === v ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                                    title: t.localeValues["zoom" === v ? "selectionZoom" : "selection"],
                                    class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(v, "-icon")
                                })
                            };
                            g("zoom"), g("selection"), this.t.pan && e.config.chart.zoom.enabled && h.push({
                                el: this.elPan,
                                icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                                title: this.localeValues.pan,
                                class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                            }), d("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && h.push({
                                el: this.elMenuIcon,
                                icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                                title: this.localeValues.menu,
                                class: "apexcharts-menu-icon"
                            });
                            for (var x = 0; x < this.elCustomIcons.length; x++) h.push({
                                el: this.elCustomIcons[x],
                                icon: this.t.customIcons[x].icon,
                                title: this.t.customIcons[x].title,
                                index: this.t.customIcons[x].index,
                                class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[x].class
                            });
                            h.forEach(function(v, w) {
                                v.index && q.moveIndexInArray(h, w, v.index)
                            });
                            for (var b = 0; b < h.length; b++) ot.setAttrs(h[b].el, {
                                class: h[b].class,
                                title: h[b].title
                            }), h[b].el.innerHTML = h[b].icon, r.appendChild(h[b].el);
                            this._createHamburgerMenu(r), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
                        }
                    }, {
                        key: "_createHamburgerMenu",
                        value: function(t) {
                            this.elMenuItems = [], t.appendChild(this.elMenu), ot.setAttrs(this.elMenu, {
                                class: "apexcharts-menu"
                            });
                            var e = [{
                                name: "exportSVG",
                                title: this.localeValues.exportToSVG
                            }, {
                                name: "exportPNG",
                                title: this.localeValues.exportToPNG
                            }, {
                                name: "exportCSV",
                                title: this.localeValues.exportToCSV
                            }];
                            this.w.globals.allSeriesHasEqualX || e.splice(2, 1);
                            for (var i = 0; i < e.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e[i].title, ot.setAttrs(this.elMenuItems[i], {
                                class: "apexcharts-menu-item ".concat(e[i].name),
                                title: e[i].title
                            }), this.elMenu.appendChild(this.elMenuItems[i])
                        }
                    }, {
                        key: "addToolbarEventListeners",
                        value: function() {
                            var t = this;
                            this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
                                i.classList.contains("exportSVG") ? i.addEventListener("click", t.handleDownload.bind(t, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", t.handleDownload.bind(t, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", t.handleDownload.bind(t, "csv"))
                            });
                            for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w))
                        }
                    }, {
                        key: "toggleZoomSelection",
                        value: function(t) {
                            this.ctx.getSyncedCharts().forEach(function(e) {
                                e.ctx.toolbar.toggleOtherControls();
                                var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                                    r = "selection" === t ? "selectionEnabled" : "zoomEnabled";
                                e.w.globals[r] = !e.w.globals[r], i.classList.contains(e.ctx.toolbar.selectedClass) ? i.classList.remove(e.ctx.toolbar.selectedClass) : i.classList.add(e.ctx.toolbar.selectedClass)
                            })
                        }
                    }, {
                        key: "getToolbarIconsReference",
                        value: function() {
                            var t = this.w;
                            this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
                        }
                    }, {
                        key: "enableZoomPanFromToolbar",
                        value: function(t) {
                            this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                            var e = "pan" === t ? this.elPan : this.elZoom,
                                i = "pan" === t ? this.elZoom : this.elPan;
                            e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass)
                        }
                    }, {
                        key: "togglePanning",
                        value: function() {
                            this.ctx.getSyncedCharts().forEach(function(t) {
                                t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)
                            })
                        }
                    }, {
                        key: "toggleOtherControls",
                        value: function() {
                            var t = this,
                                e = this.w;
                            e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
                                i && i.classList.remove(t.selectedClass)
                            })
                        }
                    }, {
                        key: "handleZoomIn",
                        value: function() {
                            var t = this.w;
                            t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
                            var e = (this.minX + this.maxX) / 2,
                                l = this._getNewMinXMaxX((this.minX + e) / 2, (this.maxX + e) / 2);
                            t.globals.disableZoomIn || this.zoomUpdateOptions(l.minX, l.maxX)
                        }
                    }, {
                        key: "handleZoomOut",
                        value: function() {
                            var t = this.w;
                            if (t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !("datetime" === t.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                                var e = (this.minX + this.maxX) / 2,
                                    l = this._getNewMinXMaxX(this.minX - (e - this.minX), this.maxX - (e - this.maxX));
                                t.globals.disableZoomOut || this.zoomUpdateOptions(l.minX, l.maxX)
                            }
                        }
                    }, {
                        key: "_getNewMinXMaxX",
                        value: function(t, e) {
                            var i = this.w.config.xaxis.convertedCatToNumeric;
                            return {
                                minX: i ? Math.floor(t) : t,
                                maxX: i ? Math.floor(e) : e
                            }
                        }
                    }, {
                        key: "zoomUpdateOptions",
                        value: function(t, e) {
                            var i = this.w;
                            if (void 0 !== t || void 0 !== e) {
                                if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) {
                                    var r = {
                                            min: t,
                                            max: e
                                        },
                                        l = this.getBeforeZoomRange(r);
                                    l && (r = l.xaxis);
                                    var h = {
                                            xaxis: r
                                        },
                                        d = q.clone(i.globals.initialConfig.yaxis);
                                    i.config.chart.zoom.autoScaleYaxis && (d = new $e(this.ctx).autoScaleY(this.ctx, d, {
                                        xaxis: r
                                    })), i.config.chart.group || (h.yaxis = d), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(h, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(r, d)
                                }
                            } else this.handleZoomReset()
                        }
                    }, {
                        key: "zoomCallback",
                        value: function(t, e) {
                            "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                                xaxis: t,
                                yaxis: e
                            })
                        }
                    }, {
                        key: "getBeforeZoomRange",
                        value: function(t, e) {
                            var i = null;
                            return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
                                xaxis: t,
                                yaxis: e
                            })), i
                        }
                    }, {
                        key: "toggleMenu",
                        value: function() {
                            var t = this;
                            window.setTimeout(function() {
                                t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open")
                            }, 0)
                        }
                    }, {
                        key: "handleDownload",
                        value: function(t) {
                            var e = this.w,
                                i = new ii(this.ctx);
                            switch (t) {
                                case "svg":
                                    i.exportToSVG(this.ctx);
                                    break;
                                case "png":
                                    i.exportToPng(this.ctx);
                                    break;
                                case "csv":
                                    i.exportToCSV({
                                        series: e.config.series,
                                        columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter
                                    })
                            }
                        }
                    }, {
                        key: "handleZoomReset",
                        value: function(t) {
                            this.ctx.getSyncedCharts().forEach(function(e) {
                                var i = e.w;
                                if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min, i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max, e.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof i.config.chart.events.beforeResetZoom) {
                                    var r = i.config.chart.events.beforeResetZoom(e, i);
                                    r && e.updateHelpers.revertDefaultAxisMinMax(r)
                                }
                                "function" == typeof i.config.chart.events.zoomed && e.ctx.toolbar.zoomCallback({
                                    min: i.config.xaxis.min,
                                    max: i.config.xaxis.max
                                }), i.globals.zoomed = !1;
                                var l = e.ctx.series.emptyCollapsedSeries(q.clone(i.globals.initialSeries));
                                e.updateHelpers._updateSeries(l, i.config.chart.animations.dynamicAnimation.enabled)
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
                        }
                    }]), _
                }(),
                qe = function(_) {
                    Rt(e, re);
                    var t = Me(e);

                    function e(i) {
                        var r;
                        return xt(this, e), (r = t.call(this, i)).ctx = i, r.w = i.w, r.dragged = !1, r.graphics = new ot(r.ctx), r.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], r.clientX = 0, r.clientY = 0, r.startX = 0, r.endX = 0, r.dragX = 0, r.startY = 0, r.endY = 0, r.dragY = 0, r.moveDirection = "none", r
                    }
                    return ht(e, [{
                        key: "init",
                        value: function(i) {
                            var r = this,
                                l = i.xyRatios,
                                h = this.w,
                                d = this;
                            this.xyRatios = l, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = h.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), h.globals.dom.elGraphical.add(this.zoomRect), h.globals.dom.elGraphical.add(this.selectionRect), this.slDraggableRect = "x" === h.config.chart.selection.type ? this.selectionRect.draggable({
                                minX: 0,
                                minY: 0,
                                maxX: h.globals.gridWidth,
                                maxY: h.globals.gridHeight
                            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === h.config.chart.selection.type ? this.selectionRect.draggable({
                                minX: 0,
                                maxX: h.globals.gridWidth
                            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = h.globals.dom.baseEl.querySelector("".concat(h.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(g) {
                                r.hoverArea.addEventListener(g, d.svgMouseEvents.bind(d, l), {
                                    capture: !1,
                                    passive: !0
                                })
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
                        }
                    }, {
                        key: "svgMouseEvents",
                        value: function(i, r) {
                            var l = this.w,
                                h = this,
                                d = this.ctx.toolbar,
                                g = l.globals.zoomEnabled ? l.config.chart.zoom.type : l.config.chart.selection.type,
                                x = l.config.chart.toolbar.autoSelected;
                            if (r.shiftKey ? (this.shiftWasPressed = !0, d.enableZoomPanFromToolbar("pan" === x ? "zoom" : "pan")) : this.shiftWasPressed && (d.enableZoomPanFromToolbar(x), this.shiftWasPressed = !1), r.target) {
                                var b, v = r.target.classList;
                                if (r.target.parentNode && null !== r.target.parentNode && (b = r.target.parentNode.classList), !(v.contains("apexcharts-selection-rect") || v.contains("apexcharts-legend-marker") || v.contains("apexcharts-legend-text") || b && b.contains("apexcharts-toolbar"))) {
                                    if (h.clientX = "touchmove" === r.type || "touchstart" === r.type ? r.touches[0].clientX : "touchend" === r.type ? r.changedTouches[0].clientX : r.clientX, h.clientY = "touchmove" === r.type || "touchstart" === r.type ? r.touches[0].clientY : "touchend" === r.type ? r.changedTouches[0].clientY : r.clientY, "mousedown" === r.type && 1 === r.which) {
                                        var w = h.gridRect.getBoundingClientRect();
                                        h.startX = h.clientX - w.left, h.startY = h.clientY - w.top, h.dragged = !1, h.w.globals.mousedown = !0
                                    }
                                    if (("mousemove" === r.type && 1 === r.which || "touchmove" === r.type) && (h.dragged = !0, l.globals.panEnabled ? (l.globals.selection = null, h.w.globals.mousedown && h.panDragging({
                                            context: h,
                                            zoomtype: g,
                                            xyRatios: i
                                        })) : (h.w.globals.mousedown && l.globals.zoomEnabled || h.w.globals.mousedown && l.globals.selectionEnabled) && (h.selection = h.selectionDrawing({
                                            context: h,
                                            zoomtype: g
                                        }))), "mouseup" === r.type || "touchend" === r.type || "mouseleave" === r.type) {
                                        var S = h.gridRect.getBoundingClientRect();
                                        h.w.globals.mousedown && (h.endX = h.clientX - S.left, h.endY = h.clientY - S.top, h.dragX = Math.abs(h.endX - h.startX), h.dragY = Math.abs(h.endY - h.startY), (l.globals.zoomEnabled || l.globals.selectionEnabled) && h.selectionDrawn({
                                            context: h,
                                            zoomtype: g
                                        }), l.globals.panEnabled && l.config.xaxis.convertedCatToNumeric && h.delayedPanScrolled()), l.globals.zoomEnabled && h.hideSelectionRect(this.selectionRect), h.dragged = !1, h.w.globals.mousedown = !1
                                    }
                                    this.makeSelectionRectDraggable()
                                }
                            }
                        }
                    }, {
                        key: "makeSelectionRectDraggable",
                        value: function() {
                            var i = this.w;
                            if (this.selectionRect) {
                                var r = this.selectionRect.node.getBoundingClientRect();
                                r.width > 0 && r.height > 0 && this.slDraggableRect.selectize({
                                    points: "l, r",
                                    pointSize: 8,
                                    pointType: "rect"
                                }).resize({
                                    constraint: {
                                        minX: 0,
                                        minY: 0,
                                        maxX: i.globals.gridWidth,
                                        maxY: i.globals.gridHeight
                                    }
                                }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                            }
                        }
                    }, {
                        key: "preselectedSelection",
                        value: function() {
                            var i = this.w,
                                r = this.xyRatios;
                            if (!i.globals.zoomEnabled)
                                if (null != i.globals.selection) this.drawSelectionRect(i.globals.selection);
                                else if (void 0 !== i.config.chart.selection.xaxis.min && void 0 !== i.config.chart.selection.xaxis.max) {
                                var l = (i.config.chart.selection.xaxis.min - i.globals.minX) / r.xRatio;
                                this.drawSelectionRect({
                                    x: l,
                                    y: 0,
                                    width: i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / r.xRatio - l,
                                    height: i.globals.gridHeight,
                                    translateX: 0,
                                    translateY: 0,
                                    selectionEnabled: !0
                                }), this.makeSelectionRectDraggable(), "function" == typeof i.config.chart.events.selection && i.config.chart.events.selection(this.ctx, {
                                    xaxis: {
                                        min: i.config.chart.selection.xaxis.min,
                                        max: i.config.chart.selection.xaxis.max
                                    },
                                    yaxis: {}
                                })
                            }
                        }
                    }, {
                        key: "drawSelectionRect",
                        value: function(i) {
                            var r = i.x,
                                l = i.y,
                                h = i.width,
                                d = i.height,
                                g = i.translateX,
                                b = i.translateY,
                                w = this.w,
                                S = this.zoomRect,
                                C = this.selectionRect;
                            if (this.dragged || null !== w.globals.selection) {
                                var P = {
                                    transform: "translate(" + (void 0 === g ? 0 : g) + ", " + (void 0 === b ? 0 : b) + ")"
                                };
                                w.globals.zoomEnabled && this.dragged && (h < 0 && (h = 1), S.attr({
                                    x: r,
                                    y: l,
                                    width: h,
                                    height: d,
                                    fill: w.config.chart.zoom.zoomedArea.fill.color,
                                    "fill-opacity": w.config.chart.zoom.zoomedArea.fill.opacity,
                                    stroke: w.config.chart.zoom.zoomedArea.stroke.color,
                                    "stroke-width": w.config.chart.zoom.zoomedArea.stroke.width,
                                    "stroke-opacity": w.config.chart.zoom.zoomedArea.stroke.opacity
                                }), ot.setAttrs(S.node, P)), w.globals.selectionEnabled && (C.attr({
                                    x: r,
                                    y: l,
                                    width: h > 0 ? h : 0,
                                    height: d > 0 ? d : 0,
                                    fill: w.config.chart.selection.fill.color,
                                    "fill-opacity": w.config.chart.selection.fill.opacity,
                                    stroke: w.config.chart.selection.stroke.color,
                                    "stroke-width": w.config.chart.selection.stroke.width,
                                    "stroke-dasharray": w.config.chart.selection.stroke.dashArray,
                                    "stroke-opacity": w.config.chart.selection.stroke.opacity
                                }), ot.setAttrs(C.node, P))
                            }
                        }
                    }, {
                        key: "hideSelectionRect",
                        value: function(i) {
                            i && i.attr({
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            })
                        }
                    }, {
                        key: "selectionDrawing",
                        value: function(i) {
                            var P, l = i.zoomtype,
                                h = this.w,
                                d = i.context,
                                g = this.gridRect.getBoundingClientRect(),
                                x = d.startX - 1,
                                b = d.startY,
                                v = !1,
                                w = !1,
                                S = d.clientX - g.left - x,
                                C = d.clientY - g.top - b;
                            return Math.abs(S + x) > h.globals.gridWidth ? S = h.globals.gridWidth - x : d.clientX - g.left < 0 && (S = x), x > d.clientX - g.left && (v = !0, S = Math.abs(S)), b > d.clientY - g.top && (w = !0, C = Math.abs(C)), d.drawSelectionRect(P = "x" === l ? {
                                x: v ? x - S : x,
                                y: 0,
                                width: S,
                                height: h.globals.gridHeight
                            } : "y" === l ? {
                                x: 0,
                                y: w ? b - C : b,
                                width: h.globals.gridWidth,
                                height: C
                            } : {
                                x: v ? x - S : x,
                                y: w ? b - C : b,
                                width: S,
                                height: C
                            }), d.selectionDragging("resizing"), P
                        }
                    }, {
                        key: "selectionDragging",
                        value: function(i, r) {
                            var l = this,
                                h = this.w,
                                d = this.xyRatios,
                                g = this.selectionRect,
                                x = 0;
                            "resizing" === i && (x = 30);
                            var b = function(w) {
                                    return parseFloat(g.node.getAttribute(w))
                                },
                                v = {
                                    x: b("x"),
                                    y: b("y"),
                                    width: b("width"),
                                    height: b("height")
                                };
                            h.globals.selection = v, "function" == typeof h.config.chart.events.selection && h.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
                                var w = l.gridRect.getBoundingClientRect(),
                                    S = g.node.getBoundingClientRect(),
                                    C = {
                                        xaxis: {
                                            min: h.globals.xAxisScale.niceMin + (S.left - w.left) * d.xRatio,
                                            max: h.globals.xAxisScale.niceMin + (S.right - w.left) * d.xRatio
                                        },
                                        yaxis: {
                                            min: h.globals.yAxisScale[0].niceMin + (w.bottom - S.bottom) * d.yRatio[0],
                                            max: h.globals.yAxisScale[0].niceMax - (S.top - w.top) * d.yRatio[0]
                                        }
                                    };
                                h.config.chart.events.selection(l.ctx, C), h.config.chart.brush.enabled && void 0 !== h.config.chart.events.brushScrolled && h.config.chart.events.brushScrolled(l.ctx, C)
                            }, x))
                        }
                    }, {
                        key: "selectionDrawn",
                        value: function(i) {
                            var l = i.zoomtype,
                                h = this.w,
                                d = i.context,
                                g = this.xyRatios,
                                x = this.ctx.toolbar;
                            if (d.startX > d.endX) {
                                var b = d.startX;
                                d.startX = d.endX, d.endX = b
                            }
                            if (d.startY > d.endY) {
                                var v = d.startY;
                                d.startY = d.endY, d.endY = v
                            }
                            var w = void 0,
                                S = void 0;
                            h.globals.isRangeBar ? (w = h.globals.yAxisScale[0].niceMin + d.startX * g.invertedYRatio, S = h.globals.yAxisScale[0].niceMin + d.endX * g.invertedYRatio) : (w = h.globals.xAxisScale.niceMin + d.startX * g.xRatio, S = h.globals.xAxisScale.niceMin + d.endX * g.xRatio);
                            var C = [],
                                P = [];
                            if (h.config.yaxis.forEach(function(X, H) {
                                    C.push(h.globals.yAxisScale[H].niceMax - g.yRatio[H] * d.startY), P.push(h.globals.yAxisScale[H].niceMax - g.yRatio[H] * d.endY)
                                }), d.dragged && (d.dragX > 10 || d.dragY > 10) && w !== S)
                                if (h.globals.zoomEnabled) {
                                    var T = q.clone(h.globals.initialConfig.yaxis),
                                        I = q.clone(h.globals.initialConfig.xaxis);
                                    if (h.globals.zoomed = !0, h.config.xaxis.convertedCatToNumeric && (w = Math.floor(w), S = Math.floor(S), w < 1 && (w = 1, S = h.globals.dataPoints), S - w < 2 && (S = w + 1)), "xy" !== l && "x" !== l || (I = {
                                            min: w,
                                            max: S
                                        }), "xy" !== l && "y" !== l || T.forEach(function(X, H) {
                                            T[H].min = P[H], T[H].max = C[H]
                                        }), h.config.chart.zoom.autoScaleYaxis) {
                                        var R = new $e(d.ctx);
                                        T = R.autoScaleY(d.ctx, T, {
                                            xaxis: I
                                        })
                                    }
                                    if (x) {
                                        var p = x.getBeforeZoomRange(I, T);
                                        p && (I = p.xaxis ? p.xaxis : I, T = p.yaxis ? p.yaxis : T)
                                    }
                                    var k = {
                                        xaxis: I
                                    };
                                    h.config.chart.group || (k.yaxis = T), d.ctx.updateHelpers._updateOptions(k, !1, d.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof h.config.chart.events.zoomed && x.zoomCallback(I, T)
                                } else if (h.globals.selectionEnabled) {
                                var M, D = null;
                                M = {
                                    min: w,
                                    max: S
                                }, "xy" !== l && "y" !== l || (D = q.clone(h.config.yaxis)).forEach(function(X, H) {
                                    D[H].min = P[H], D[H].max = C[H]
                                }), h.globals.selection = d.selection, "function" == typeof h.config.chart.events.selection && h.config.chart.events.selection(d.ctx, {
                                    xaxis: M,
                                    yaxis: D
                                })
                            }
                        }
                    }, {
                        key: "panDragging",
                        value: function(i) {
                            var l = this.w,
                                h = i.context;
                            if (void 0 !== l.globals.lastClientPosition.x) {
                                var d = l.globals.lastClientPosition.x - h.clientX,
                                    g = l.globals.lastClientPosition.y - h.clientY;
                                Math.abs(d) > Math.abs(g) && d > 0 ? this.moveDirection = "left" : Math.abs(d) > Math.abs(g) && d < 0 ? this.moveDirection = "right" : Math.abs(g) > Math.abs(d) && g > 0 ? this.moveDirection = "up" : Math.abs(g) > Math.abs(d) && g < 0 && (this.moveDirection = "down")
                            }
                            l.globals.lastClientPosition = {
                                x: h.clientX,
                                y: h.clientY
                            }, l.config.xaxis.convertedCatToNumeric || h.panScrolled(l.globals.isRangeBar ? l.globals.minY : l.globals.minX, l.globals.isRangeBar ? l.globals.maxY : l.globals.maxX)
                        }
                    }, {
                        key: "delayedPanScrolled",
                        value: function() {
                            var i = this.w,
                                r = i.globals.minX,
                                l = i.globals.maxX,
                                h = (i.globals.maxX - i.globals.minX) / 2;
                            "left" === this.moveDirection ? (r = i.globals.minX + h, l = i.globals.maxX + h) : "right" === this.moveDirection && (r = i.globals.minX - h, l = i.globals.maxX - h), r = Math.floor(r), l = Math.floor(l), this.updateScrolledChart({
                                xaxis: {
                                    min: r,
                                    max: l
                                }
                            }, r, l)
                        }
                    }, {
                        key: "panScrolled",
                        value: function(i, r) {
                            var l = this.w,
                                h = this.xyRatios,
                                d = q.clone(l.globals.initialConfig.yaxis),
                                g = h.xRatio,
                                x = l.globals.minX,
                                b = l.globals.maxX;
                            l.globals.isRangeBar && (g = h.invertedYRatio, x = l.globals.minY, b = l.globals.maxY), "left" === this.moveDirection ? (i = x + l.globals.gridWidth / 15 * g, r = b + l.globals.gridWidth / 15 * g) : "right" === this.moveDirection && (i = x - l.globals.gridWidth / 15 * g, r = b - l.globals.gridWidth / 15 * g), l.globals.isRangeBar || (i < l.globals.initialMinX || r > l.globals.initialMaxX) && (i = x, r = b);
                            var v = {
                                min: i,
                                max: r
                            };
                            l.config.chart.zoom.autoScaleYaxis && (d = new $e(this.ctx).autoScaleY(this.ctx, d, {
                                xaxis: v
                            }));
                            var w = {
                                xaxis: {
                                    min: i,
                                    max: r
                                }
                            };
                            l.config.chart.group || (w.yaxis = d), this.updateScrolledChart(w, i, r)
                        }
                    }, {
                        key: "updateScrolledChart",
                        value: function(i, r, l) {
                            var h = this.w;
                            this.ctx.updateHelpers._updateOptions(i, !1, !1), "function" == typeof h.config.chart.events.scrolled && h.config.chart.events.scrolled(this.ctx, {
                                xaxis: {
                                    min: r,
                                    max: l
                                }
                            })
                        }
                    }]), e
                }(),
                vi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx
                    }
                    return ht(_, [{
                        key: "getNearestValues",
                        value: function(t) {
                            var e = t.hoverArea,
                                r = t.clientX,
                                l = t.clientY,
                                h = this.w,
                                d = t.elGrid.getBoundingClientRect(),
                                g = d.width,
                                x = d.height,
                                b = g / (h.globals.dataPoints - 1),
                                v = x / h.globals.dataPoints,
                                w = this.hasBars();
                            !h.globals.comboCharts && !w || h.config.xaxis.convertedCatToNumeric || (b = g / h.globals.dataPoints);
                            var S = r - d.left - h.globals.barPadForNumericAxis,
                                C = l - d.top;
                            S < 0 || C < 0 || S > g || C > x ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : h.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : h.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
                            var P = Math.round(S / b),
                                T = Math.floor(C / v);
                            w && !h.config.xaxis.convertedCatToNumeric && (P = Math.ceil(S / b), P -= 1);
                            var I = null,
                                R = null,
                                p = h.globals.seriesXvalues.map(function(H) {
                                    return H.filter(function(j) {
                                        return q.isNumber(j)
                                    })
                                }),
                                k = h.globals.seriesYvalues.map(function(H) {
                                    return H.filter(function(j) {
                                        return q.isNumber(j)
                                    })
                                });
                            if (h.globals.isXNumeric) {
                                var M = this.ttCtx.getElGrid().getBoundingClientRect(),
                                    D = S * (M.width / g);
                                I = (R = this.closestInMultiArray(D, C * (M.height / x), p, k)).index, P = R.j, null !== I && (P = (R = this.closestInArray(D, p = h.globals.seriesXvalues[I])).index)
                            }
                            return h.globals.capturedSeriesIndex = null === I ? -1 : I, (!P || P < 1) && (P = 0), h.globals.capturedDataPointIndex = h.globals.isBarHorizontal ? T : P, {
                                capturedSeries: I,
                                j: h.globals.isBarHorizontal ? T : P,
                                hoverX: S,
                                hoverY: C
                            }
                        }
                    }, {
                        key: "closestInMultiArray",
                        value: function(t, e, i, r) {
                            var h = 0,
                                d = null,
                                g = -1;
                            this.w.globals.series.length > 1 ? h = this.getFirstActiveXArray(i) : d = 0;
                            var b = Math.abs(t - i[h][0]);
                            if (i.forEach(function(S) {
                                    S.forEach(function(C, P) {
                                        var T = Math.abs(t - C);
                                        T <= b && (b = T, g = P)
                                    })
                                }), -1 !== g) {
                                var w = Math.abs(e - r[h][g]);
                                d = h, r.forEach(function(S, C) {
                                    var P = Math.abs(e - S[g]);
                                    P <= w && (w = P, d = C)
                                })
                            }
                            return {
                                index: d,
                                j: g
                            }
                        }
                    }, {
                        key: "getFirstActiveXArray",
                        value: function(t) {
                            for (var e = this.w, i = 0, r = t.map(function(h, d) {
                                    return h.length > 0 ? d : -1
                                }), l = 0; l < r.length; l++)
                                if (-1 !== r[l] && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l)) {
                                    i = r[l];
                                    break
                                }
                            return i
                        }
                    }, {
                        key: "closestInArray",
                        value: function(t, e) {
                            for (var r = null, l = Math.abs(t - e[0]), h = 0; h < e.length; h++) {
                                var d = Math.abs(t - e[h]);
                                d < l && (l = d, r = h)
                            }
                            return {
                                index: r
                            }
                        }
                    }, {
                        key: "isXoverlap",
                        value: function(t) {
                            var e = [],
                                i = this.w.globals.seriesX.filter(function(l) {
                                    return void 0 !== l[0]
                                });
                            if (i.length > 0)
                                for (var r = 0; r < i.length - 1; r++) void 0 !== i[r][t] && void 0 !== i[r + 1][t] && i[r][t] !== i[r + 1][t] && e.push("unEqual");
                            return 0 === e.length
                        }
                    }, {
                        key: "isInitialSeriesSameLen",
                        value: function() {
                            for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++)
                                if (e[i].data.length !== e[i + 1].data.length) {
                                    t = !1;
                                    break
                                }
                            return t
                        }
                    }, {
                        key: "getBarsHeight",
                        value: function(t) {
                            return le(t).reduce(function(e, i) {
                                return e + i.getBBox().height
                            }, 0)
                        }
                    }, {
                        key: "getElMarkers",
                        value: function(t) {
                            return this.w.globals.dom.baseEl.querySelectorAll("number" == typeof t ? ".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers-wrap > *") : ".apexcharts-series-markers-wrap > *")
                        }
                    }, {
                        key: "getAllMarkers",
                        value: function() {
                            var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                            (t = le(t)).sort(function(i, r) {
                                var l = Number(i.getAttribute("data:realIndex")),
                                    h = Number(r.getAttribute("data:realIndex"));
                                return h < l ? 1 : h > l ? -1 : 0
                            });
                            var e = [];
                            return t.forEach(function(i) {
                                e.push(i.querySelector(".apexcharts-marker"))
                            }), e
                        }
                    }, {
                        key: "hasMarkers",
                        value: function(t) {
                            return this.getElMarkers(t).length > 0
                        }
                    }, {
                        key: "getElBars",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
                        }
                    }, {
                        key: "hasBars",
                        value: function() {
                            return this.getElBars().length > 0
                        }
                    }, {
                        key: "getHoverMarkerSize",
                        value: function(t) {
                            var e = this.w,
                                i = e.config.markers.hover.size;
                            return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i
                        }
                    }, {
                        key: "toggleAllTooltipSeriesGroups",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                            for (var r = i.allTooltipSeriesGroups, l = 0; l < r.length; l++) "enable" === t ? (r[l].classList.add("apexcharts-active"), r[l].style.display = e.config.tooltip.items.display) : (r[l].classList.remove("apexcharts-active"), r[l].style.display = "none")
                        }
                    }]), _
                }(),
                Ns = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.ctx = t.ctx, this.ttCtx = t, this.tooltipUtil = new vi(t)
                    }
                    return ht(_, [{
                        key: "drawSeriesTexts",
                        value: function(t) {
                            var e = t.shared,
                                i = void 0 === e || e,
                                r = t.ttItems,
                                l = t.i,
                                h = void 0 === l ? 0 : l,
                                d = t.j,
                                g = void 0 === d ? null : d,
                                v = t.e,
                                w = this.w;
                            void 0 !== w.config.tooltip.custom ? this.handleCustomTooltip({
                                i: h,
                                j: g,
                                y1: t.y1,
                                y2: t.y2,
                                w
                            }) : this.toggleActiveInactiveSeries(i);
                            var S = this.getValuesToPrint({
                                i: h,
                                j: g
                            });
                            this.printLabels({
                                i: h,
                                j: g,
                                values: S,
                                ttItems: r,
                                shared: i,
                                e: v
                            });
                            var C = this.ttCtx.getElTooltip();
                            this.ttCtx.tooltipRect.ttWidth = C.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = C.getBoundingClientRect().height
                        }
                    }, {
                        key: "printLabels",
                        value: function(t) {
                            var e, i = this,
                                r = t.i,
                                l = t.j,
                                h = t.values,
                                d = t.ttItems,
                                g = t.shared,
                                x = t.e,
                                b = this.w,
                                v = [],
                                w = function(M) {
                                    return b.globals.seriesGoals[M] && b.globals.seriesGoals[M][l] && Array.isArray(b.globals.seriesGoals[M][l])
                                },
                                S = h.xVal,
                                C = h.zVal,
                                P = h.xAxisTTVal,
                                T = "",
                                I = b.globals.colors[r];
                            null !== l && b.config.plotOptions.bar.distributed && (I = b.globals.colors[l]);
                            for (var R = function(M, D) {
                                    var X = i.getFormatters(r);
                                    T = i.getSeriesName({
                                        fn: X.yLbTitleFormatter,
                                        index: r,
                                        seriesIndex: r,
                                        j: l
                                    }), "treemap" === b.config.chart.type && (T = X.yLbTitleFormatter(String(b.config.series[r].data[l].x), {
                                        series: b.globals.series,
                                        seriesIndex: r,
                                        dataPointIndex: l,
                                        w: b
                                    }));
                                    var H = b.config.tooltip.inverseOrder ? D : M;
                                    if (b.globals.axisCharts) {
                                        var j = function(at) {
                                            var it, mt, yt, Pt;
                                            return b.globals.isRangeData ? X.yLbFormatter(null === (it = b.globals.seriesRangeStart) || void 0 === it || null === (mt = it[at]) || void 0 === mt ? void 0 : mt[l], {
                                                series: b.globals.seriesRangeStart,
                                                seriesIndex: at,
                                                dataPointIndex: l,
                                                w: b
                                            }) + " - " + X.yLbFormatter(null === (yt = b.globals.seriesRangeEnd) || void 0 === yt || null === (Pt = yt[at]) || void 0 === Pt ? void 0 : Pt[l], {
                                                series: b.globals.seriesRangeEnd,
                                                seriesIndex: at,
                                                dataPointIndex: l,
                                                w: b
                                            }) : X.yLbFormatter(b.globals.series[at][l], {
                                                series: b.globals.series,
                                                seriesIndex: at,
                                                dataPointIndex: l,
                                                w: b
                                            })
                                        };
                                        if (g) X = i.getFormatters(H), T = i.getSeriesName({
                                            fn: X.yLbTitleFormatter,
                                            index: H,
                                            seriesIndex: r,
                                            j: l
                                        }), I = b.globals.colors[H], e = j(H), w(H) && (v = b.globals.seriesGoals[H][l].map(function(at) {
                                            return {
                                                attrs: at,
                                                val: X.yLbFormatter(at.value, {
                                                    seriesIndex: H,
                                                    dataPointIndex: l,
                                                    w: b
                                                })
                                            }
                                        }));
                                        else {
                                            var U, Q = null == x || null === (U = x.target) || void 0 === U ? void 0 : U.getAttribute("fill");
                                            Q && (I = -1 !== Q.indexOf("url") ? document.querySelector(Q.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : Q), e = j(r), w(r) && Array.isArray(b.globals.seriesGoals[r][l]) && (v = b.globals.seriesGoals[r][l].map(function(at) {
                                                return {
                                                    attrs: at,
                                                    val: X.yLbFormatter(at.value, {
                                                        seriesIndex: r,
                                                        dataPointIndex: l,
                                                        w: b
                                                    })
                                                }
                                            }))
                                        }
                                    }
                                    null === l && (e = X.yLbFormatter(b.globals.series[r], ut(ut({}, b), {}, {
                                        seriesIndex: r,
                                        dataPointIndex: r
                                    }))), i.DOMHandling({
                                        i: r,
                                        t: H,
                                        j: l,
                                        ttItems: d,
                                        values: {
                                            val: e,
                                            goalVals: v,
                                            xVal: S,
                                            xAxisTTVal: P,
                                            zVal: C
                                        },
                                        seriesName: T,
                                        shared: g,
                                        pColor: I
                                    })
                                }, p = 0, k = b.globals.series.length - 1; p < b.globals.series.length; p++, k--) R(p, k)
                        }
                    }, {
                        key: "getFormatters",
                        value: function(t) {
                            var e, i = this.w,
                                r = i.globals.yLabelFormatters[t];
                            return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (r = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (r = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof r && (r = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(l) {
                                return l
                            }), "function" != typeof e && (e = function(l) {
                                return l
                            }), {
                                yLbFormatter: r,
                                yLbTitleFormatter: e
                            }
                        }
                    }, {
                        key: "getSeriesName",
                        value: function(t) {
                            var r = t.seriesIndex,
                                l = t.j,
                                h = this.w;
                            return (0, t.fn)(String(h.globals.seriesNames[t.index]), {
                                series: h.globals.series,
                                seriesIndex: r,
                                dataPointIndex: l,
                                w: h
                            })
                        }
                    }, {
                        key: "DOMHandling",
                        value: function(t) {
                            var e = t.t,
                                i = t.j,
                                r = t.ttItems,
                                l = t.values,
                                h = t.seriesName,
                                d = t.shared,
                                g = t.pColor,
                                x = this.w,
                                b = this.ttCtx,
                                v = l.val,
                                w = l.goalVals,
                                S = l.xVal,
                                C = l.xAxisTTVal,
                                P = l.zVal,
                                T = null;
                            T = r[e].children, x.config.tooltip.fillSeriesColor && (r[e].style.backgroundColor = g, T[0].style.display = "none"), b.showTooltipTitle && (null === b.tooltipTitle && (b.tooltipTitle = x.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), b.tooltipTitle.innerHTML = S), b.isXAxisTooltipEnabled && (b.xaxisTooltipText.innerHTML = "" !== C ? C : S);
                            var I = r[e].querySelector(".apexcharts-tooltip-text-y-label");
                            I && (I.innerHTML = h || "");
                            var R = r[e].querySelector(".apexcharts-tooltip-text-y-value");
                            R && (R.innerHTML = void 0 !== v ? v : ""), T[0] && T[0].classList.contains("apexcharts-tooltip-marker") && (x.config.tooltip.marker.fillColors && Array.isArray(x.config.tooltip.marker.fillColors) && (g = x.config.tooltip.marker.fillColors[e]), T[0].style.backgroundColor = g), x.config.tooltip.marker.show || (T[0].style.display = "none");
                            var p = r[e].querySelector(".apexcharts-tooltip-text-goals-label"),
                                k = r[e].querySelector(".apexcharts-tooltip-text-goals-value");
                            if (w.length && x.globals.seriesGoals[e]) {
                                var M = function() {
                                    var D = "<div >",
                                        X = "<div>";
                                    w.forEach(function(H, j) {
                                        D += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(H.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(H.attrs.name, "</div>"), X += "<div>".concat(H.val, "</div>")
                                    }), p.innerHTML = D + "</div>", k.innerHTML = X + "</div>"
                                };
                                d ? x.globals.seriesGoals[e][i] && Array.isArray(x.globals.seriesGoals[e][i]) ? M() : (p.innerHTML = "", k.innerHTML = "") : M()
                            } else p.innerHTML = "", k.innerHTML = "";
                            null !== P && (r[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = x.config.tooltip.z.title, r[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== P ? P : ""), d && T[0] && (T[0].parentNode.style.display = null == v || x.globals.ancillaryCollapsedSeriesIndices.indexOf(e) > -1 || x.globals.collapsedSeriesIndices.indexOf(e) > -1 ? "none" : x.config.tooltip.items.display)
                        }
                    }, {
                        key: "toggleActiveInactiveSeries",
                        value: function(t) {
                            var e = this.w;
                            if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                            else {
                                this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                                var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                                i && (i.classList.add("apexcharts-active"), i.style.display = e.config.tooltip.items.display)
                            }
                        }
                    }, {
                        key: "getValuesToPrint",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                r = this.w,
                                l = this.ctx.series.filteredSeriesX(),
                                h = "",
                                d = "",
                                g = null,
                                x = null,
                                b = {
                                    series: r.globals.series,
                                    seriesIndex: e,
                                    dataPointIndex: i,
                                    w: r
                                },
                                v = r.globals.ttZFormatter;
                            null === i ? x = r.globals.series[e] : r.globals.isXNumeric && "treemap" !== r.config.chart.type ? (h = l[e][i], 0 === l[e].length && (h = l[this.tooltipUtil.getFirstActiveXArray(l)][i])) : h = void 0 !== r.globals.labels[i] ? r.globals.labels[i] : "";
                            var w = h;
                            return h = r.globals.isXNumeric && "datetime" === r.config.xaxis.type ? new Be(this.ctx).xLabelFormat(r.globals.ttKeyFormatter, w, w, {
                                i: void 0,
                                dateFormatter: new ne(this.ctx).formatDate,
                                w: this.w
                            }) : r.globals.isBarHorizontal ? r.globals.yLabelFormatters[0](w, b) : r.globals.xLabelFormatter(w, b), void 0 !== r.config.tooltip.x.formatter && (h = r.globals.ttKeyFormatter(w, b)), r.globals.seriesZ.length > 0 && r.globals.seriesZ[e].length > 0 && (g = v(r.globals.seriesZ[e][i], r)), d = "function" == typeof r.config.xaxis.tooltip.formatter ? r.globals.xaxisTooltipFormatter(w, b) : h, {
                                val: Array.isArray(x) ? x.join(" ") : x,
                                xVal: Array.isArray(h) ? h.join(" ") : h,
                                xAxisTTVal: Array.isArray(d) ? d.join(" ") : d,
                                zVal: g
                            }
                        }
                    }, {
                        key: "handleCustomTooltip",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                r = t.y1,
                                l = t.y2,
                                h = t.w,
                                d = this.ttCtx.getElTooltip(),
                                g = h.config.tooltip.custom;
                            Array.isArray(g) && g[e] && (g = g[e]), d.innerHTML = g({
                                ctx: this.ctx,
                                series: h.globals.series,
                                seriesIndex: e,
                                dataPointIndex: i,
                                y1: r,
                                y2: l,
                                w: h
                            })
                        }
                    }]), _
                }(),
                Ke = function() {
                    function _(t) {
                        xt(this, _), this.ttCtx = t, this.ctx = t.ctx, this.w = t.w
                    }
                    return ht(_, [{
                        key: "moveXCrosshairs",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                i = this.ttCtx,
                                r = this.w,
                                l = i.getElXCrosshairs(),
                                h = t - i.xcrosshairsWidth / 2,
                                d = r.globals.labels.slice().length;
                            if (null !== e && (h = r.globals.gridWidth / d * e), null === l || r.globals.isBarHorizontal || (l.setAttribute("x", h), l.setAttribute("x1", h), l.setAttribute("x2", h), l.setAttribute("y2", r.globals.gridHeight), l.classList.add("apexcharts-active")), h < 0 && (h = 0), h > r.globals.gridWidth && (h = r.globals.gridWidth), i.isXAxisTooltipEnabled) {
                                var g = h;
                                "tickWidth" !== r.config.xaxis.crosshairs.width && "barWidth" !== r.config.xaxis.crosshairs.width || (g = h + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(g)
                            }
                        }
                    }, {
                        key: "moveYCrosshairs",
                        value: function(t) {
                            var e = this.ttCtx;
                            null !== e.ycrosshairs && ot.setAttrs(e.ycrosshairs, {
                                y1: t,
                                y2: t
                            }), null !== e.ycrosshairsHidden && ot.setAttrs(e.ycrosshairsHidden, {
                                y1: t,
                                y2: t
                            })
                        }
                    }, {
                        key: "moveXAxisTooltip",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
                                i.xaxisTooltip.classList.add("apexcharts-active");
                                var l, r = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;
                                t -= i.xaxisTooltip.getBoundingClientRect().width / 2, isNaN(t) || (t += e.globals.translateX, l = new ot(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = l.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = r + "px")
                            }
                        }
                    }, {
                        key: "moveYAxisTooltip",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                            var r = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
                                l = e.globals.translateY + r,
                                h = i.yaxisTTEls[t].getBoundingClientRect().height,
                                d = e.globals.translateYAxisX[t] - 2;
                            e.config.yaxis[t].opposite && (d -= 26), l -= h / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = l + "px", i.yaxisTTEls[t].style.left = d + e.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active")
                        }
                    }, {
                        key: "moveTooltip",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                r = this.w,
                                l = this.ttCtx,
                                h = l.getElTooltip(),
                                d = l.tooltipRect,
                                g = null !== i ? parseFloat(i) : 1,
                                x = parseFloat(t) + g + 5,
                                b = parseFloat(e) + g / 2;
                            if (x > r.globals.gridWidth / 2 && (x = x - d.ttWidth - g - 10), x > r.globals.gridWidth - d.ttWidth - 10 && (x = r.globals.gridWidth - d.ttWidth), x < -20 && (x = -20), r.config.tooltip.followCursor) {
                                var v = l.getElGrid().getBoundingClientRect();
                                (x = l.e.clientX - v.left) > r.globals.gridWidth / 2 && (x -= l.tooltipRect.ttWidth), (b = l.e.clientY + r.globals.translateY - v.top) > r.globals.gridHeight / 2 && (b -= l.tooltipRect.ttHeight)
                            } else r.globals.isBarHorizontal || d.ttHeight / 2 + b > r.globals.gridHeight && (b = r.globals.gridHeight - d.ttHeight + r.globals.translateY);
                            isNaN(x) || (h.style.left = (x += r.globals.translateX) + "px", h.style.top = b + "px")
                        }
                    }, {
                        key: "moveMarkers",
                        value: function(t, e) {
                            var i = this.w,
                                r = this.ttCtx;
                            if (i.globals.markers.size[t] > 0)
                                for (var l = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), h = 0; h < l.length; h++) parseInt(l[h].getAttribute("rel"), 10) === e && (r.marker.resetPointsSize(), r.marker.enlargeCurrentPoint(e, l[h]));
                            else r.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t)
                        }
                    }, {
                        key: "moveDynamicPointOnHover",
                        value: function(t, e) {
                            var i, r, l = this.w,
                                h = this.ttCtx,
                                d = l.globals.pointsArray,
                                g = h.tooltipUtil.getHoverMarkerSize(e),
                                x = l.config.series[e].type;
                            if (!x || "column" !== x && "candlestick" !== x && "boxPlot" !== x) {
                                i = d[e][t][0], r = d[e][t][1] ? d[e][t][1] : 0;
                                var b = l.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
                                b && r < l.globals.gridHeight && r > 0 && (b.setAttribute("r", g), b.setAttribute("cx", i), b.setAttribute("cy", r)), this.moveXCrosshairs(i), h.fixedTooltip || this.moveTooltip(i, r, g)
                            }
                        }
                    }, {
                        key: "moveDynamicPointsOnHover",
                        value: function(t) {
                            var e, i = this.ttCtx,
                                r = i.w,
                                l = 0,
                                h = 0,
                                d = r.globals.pointsArray;
                            e = new xe(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
                            var g = i.tooltipUtil.getHoverMarkerSize(e);
                            d[e] && (l = d[e][t][0], h = d[e][t][1]);
                            var x = i.tooltipUtil.getAllMarkers();
                            if (null !== x)
                                for (var b = 0; b < r.globals.series.length; b++) {
                                    var v = d[b];
                                    if (r.globals.comboCharts && void 0 === v && x.splice(b, 0, null), v && v.length) {
                                        var w = d[b][t][1];
                                        x[b].setAttribute("cx", l), "rangeArea" !== r.config.chart.type || r.globals.comboCharts || (w -= Math.abs(w - d[b][t + r.globals.series[b].length][1]) / 2), null !== w && !isNaN(w) && w < r.globals.gridHeight + g && w + g > 0 ? (x[b] && x[b].setAttribute("r", g), x[b] && x[b].setAttribute("cy", w)) : x[b] && x[b].setAttribute("r", 0)
                                    }
                                }
                            this.moveXCrosshairs(l), i.fixedTooltip || this.moveTooltip(l, h || r.globals.gridHeight, g)
                        }
                    }, {
                        key: "moveStickyTooltipOverBars",
                        value: function(t, e) {
                            var i = this.w,
                                r = this.ttCtx,
                                l = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length,
                                h = l >= 2 && l % 2 == 0 ? Math.floor(l / 2) : Math.floor(l / 2) + 1;
                            i.globals.isBarHorizontal && (h = new xe(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
                            var d = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(h, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(h, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(h, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(h, "'] path[j='").concat(t, "']"));
                            d || "number" != typeof e || (d = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e, "'] path[j='").concat(t, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e, "'] path[j='").concat(t, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e, "'] path[j='").concat(t, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e, "'] path[j='").concat(t, "']")));
                            var g = d ? parseFloat(d.getAttribute("cx")) : 0,
                                x = d ? parseFloat(d.getAttribute("cy")) : 0,
                                b = d ? parseFloat(d.getAttribute("barWidth")) : 0,
                                v = r.getElGrid().getBoundingClientRect(),
                                w = d && (d.classList.contains("apexcharts-candlestick-area") || d.classList.contains("apexcharts-boxPlot-area"));
                            i.globals.isXNumeric ? (d && !w && (g -= l % 2 != 0 ? b / 2 : 0), d && w && i.globals.comboCharts && (g -= b / 2)) : i.globals.isBarHorizontal || (g = r.xAxisTicksPositions[t - 1] + r.dataPointsDividedWidth / 2, isNaN(g) && (g = r.xAxisTicksPositions[t] - r.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? x -= r.tooltipRect.ttHeight : i.config.tooltip.followCursor ? x = r.e.clientY - v.top - r.tooltipRect.ttHeight / 2 : x + r.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (x = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(g), r.fixedTooltip || this.moveTooltip(g, x || i.globals.gridHeight)
                        }
                    }]), _
                }(),
                si = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx, this.tooltipPosition = new Ke(t)
                    }
                    return ht(_, [{
                        key: "drawDynamicPoints",
                        value: function() {
                            var t = this.w,
                                e = new ot(this.ctx),
                                i = new gi(this.ctx),
                                r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                            r = le(r), t.config.chart.stacked && r.sort(function(v, w) {
                                return parseFloat(v.getAttribute("data:realIndex")) - parseFloat(w.getAttribute("data:realIndex"))
                            });
                            for (var l = 0; l < r.length; l++) {
                                var h = r[l].querySelector(".apexcharts-series-markers-wrap");
                                if (null !== h) {
                                    var d = void 0,
                                        g = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                                    "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (g += " no-pointer-events");
                                    var x = i.getMarkerConfig({
                                        cssClass: g,
                                        seriesIndex: Number(h.getAttribute("data:realIndex"))
                                    });
                                    (d = e.drawMarker(0, 0, x)).node.setAttribute("default-marker-size", 0);
                                    var b = document.createElementNS(t.globals.SVGNS, "g");
                                    b.classList.add("apexcharts-series-markers"), b.appendChild(d.node), h.appendChild(b)
                                }
                            }
                        }
                    }, {
                        key: "enlargeCurrentPoint",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                l = this.w;
                            "bubble" !== l.config.chart.type && this.newPointSize(t, e);
                            var h = e.getAttribute("cx"),
                                d = e.getAttribute("cy");
                            if (null !== i && null !== r && (h = i, d = r), this.tooltipPosition.moveXCrosshairs(h), !this.fixedTooltip) {
                                if ("radar" === l.config.chart.type) {
                                    var g = this.ttCtx.getElGrid().getBoundingClientRect();
                                    h = this.ttCtx.e.clientX - g.left
                                }
                                this.tooltipPosition.moveTooltip(h, d, l.config.markers.hover.size)
                            }
                        }
                    }, {
                        key: "enlargePoints",
                        value: function(t) {
                            for (var e = this.w, i = this, r = this.ttCtx, l = t, h = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), d = e.config.markers.hover.size, g = 0; g < h.length; g++) {
                                var x = h[g].getAttribute("rel"),
                                    b = h[g].getAttribute("index");
                                if (void 0 === d && (d = e.globals.markers.size[b] + e.config.markers.hover.sizeOffset), l === parseInt(x, 10)) {
                                    i.newPointSize(l, h[g]);
                                    var v = h[g].getAttribute("cx"),
                                        w = h[g].getAttribute("cy");
                                    i.tooltipPosition.moveXCrosshairs(v), r.fixedTooltip || i.tooltipPosition.moveTooltip(v, w, d)
                                } else i.oldPointSize(h[g])
                            }
                        }
                    }, {
                        key: "newPointSize",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.config.markers.hover.size,
                                l = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;
                            if ("0" !== l.getAttribute("default-marker-size")) {
                                var h = parseInt(l.getAttribute("index"), 10);
                                void 0 === r && (r = i.globals.markers.size[h] + i.config.markers.hover.sizeOffset), r < 0 && (r = 0), l.setAttribute("r", r)
                            }
                        }
                    }, {
                        key: "oldPointSize",
                        value: function(t) {
                            var e = parseFloat(t.getAttribute("default-marker-size"));
                            t.setAttribute("r", e)
                        }
                    }, {
                        key: "resetPointsSize",
                        value: function() {
                            for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
                                var i = parseFloat(t[e].getAttribute("default-marker-size"));
                                q.isNumber(i) && i >= 0 ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0)
                            }
                        }
                    }]), _
                }(),
                Vi = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w;
                        var e = this.w;
                        this.ttCtx = t, this.isVerticalGroupedRangeBar = !e.globals.isBarHorizontal && "rangeBar" === e.config.chart.type && e.config.plotOptions.bar.rangeBarGroupRows
                    }
                    return ht(_, [{
                        key: "getAttr",
                        value: function(t, e) {
                            return parseFloat(t.target.getAttribute(e))
                        }
                    }, {
                        key: "handleHeatTreeTooltip",
                        value: function(t) {
                            var e = t.e,
                                i = t.opt,
                                r = t.x,
                                l = t.y,
                                d = this.ttCtx,
                                g = this.w;
                            if (e.target.classList.contains("apexcharts-".concat(t.type, "-rect"))) {
                                var x = this.getAttr(e, "i"),
                                    b = this.getAttr(e, "j"),
                                    v = this.getAttr(e, "cx"),
                                    w = this.getAttr(e, "cy"),
                                    S = this.getAttr(e, "width"),
                                    C = this.getAttr(e, "height");
                                if (d.tooltipLabels.drawSeriesTexts({
                                        ttItems: i.ttItems,
                                        i: x,
                                        j: b,
                                        shared: !1,
                                        e
                                    }), g.globals.capturedSeriesIndex = x, g.globals.capturedDataPointIndex = b, r = v + d.tooltipRect.ttWidth / 2 + S, l = w + d.tooltipRect.ttHeight / 2 - C / 2, d.tooltipPosition.moveXCrosshairs(v + S / 2), r > g.globals.gridWidth / 2 && (r = v - d.tooltipRect.ttWidth / 2 + S), d.w.config.tooltip.followCursor) {
                                    var P = g.globals.dom.elWrap.getBoundingClientRect();
                                    r = g.globals.clientX - P.left - (r > g.globals.gridWidth / 2 ? d.tooltipRect.ttWidth : 0), l = g.globals.clientY - P.top - (l > g.globals.gridHeight / 2 ? d.tooltipRect.ttHeight : 0)
                                }
                            }
                            return {
                                x: r,
                                y: l
                            }
                        }
                    }, {
                        key: "handleMarkerTooltip",
                        value: function(t) {
                            var e, i, r = t.e,
                                l = t.opt,
                                h = t.x,
                                d = t.y,
                                g = this.w,
                                x = this.ttCtx;
                            if (r.target.classList.contains("apexcharts-marker")) {
                                var b = parseInt(l.paths.getAttribute("cx"), 10),
                                    v = parseInt(l.paths.getAttribute("cy"), 10),
                                    w = parseFloat(l.paths.getAttribute("val"));
                                if (i = parseInt(l.paths.getAttribute("rel"), 10), e = parseInt(l.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, x.intersect) {
                                    var S = q.findAncestor(l.paths, "apexcharts-series");
                                    S && (e = parseInt(S.getAttribute("data:realIndex"), 10))
                                }
                                if (x.tooltipLabels.drawSeriesTexts({
                                        ttItems: l.ttItems,
                                        i: e,
                                        j: i,
                                        shared: !x.showOnIntersect && g.config.tooltip.shared,
                                        e: r
                                    }), "mouseup" === r.type && x.markerClick(r, e, i), g.globals.capturedSeriesIndex = e, g.globals.capturedDataPointIndex = i, h = b, d = v + g.globals.translateY - 1.4 * x.tooltipRect.ttHeight, x.w.config.tooltip.followCursor) {
                                    var C = x.getElGrid().getBoundingClientRect();
                                    d = x.e.clientY + g.globals.translateY - C.top
                                }
                                w < 0 && (d = v), x.marker.enlargeCurrentPoint(i, l.paths, h, d)
                            }
                            return {
                                x: h,
                                y: d
                            }
                        }
                    }, {
                        key: "handleBarTooltip",
                        value: function(t) {
                            var e, i, r = t.e,
                                l = t.opt,
                                h = this.w,
                                d = this.ttCtx,
                                g = d.getElTooltip(),
                                x = 0,
                                b = 0,
                                v = 0,
                                w = this.getBarTooltipXY({
                                    e: r,
                                    opt: l
                                }),
                                S = w.barHeight,
                                C = w.j;
                            h.globals.capturedSeriesIndex = e = w.i, h.globals.capturedDataPointIndex = C, h.globals.isBarHorizontal && d.tooltipUtil.hasBars() || !h.config.tooltip.shared ? (b = w.x, v = w.y, i = Array.isArray(h.config.stroke.width) ? h.config.stroke.width[e] : h.config.stroke.width, x = b) : h.globals.comboCharts || h.config.tooltip.shared || (x /= 2), isNaN(v) && (v = h.globals.svgHeight - d.tooltipRect.ttHeight);
                            var P = parseInt(l.paths.parentNode.getAttribute("data:realIndex"), 10),
                                T = h.globals.isMultipleYAxis ? h.config.yaxis[P] && h.config.yaxis[P].reversed : h.config.yaxis[0].reversed;
                            if (b + d.tooltipRect.ttWidth > h.globals.gridWidth && !T ? b -= d.tooltipRect.ttWidth : b < 0 && (b = 0), d.w.config.tooltip.followCursor) {
                                var I = d.getElGrid().getBoundingClientRect();
                                v = d.e.clientY - I.top
                            }
                            null === d.tooltip && (d.tooltip = h.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), h.config.tooltip.shared || d.tooltipPosition.moveXCrosshairs(h.globals.comboBarCount > 0 ? x + i / 2 : x), !d.fixedTooltip && (!h.config.tooltip.shared || h.globals.isBarHorizontal && d.tooltipUtil.hasBars()) && (T && (b -= d.tooltipRect.ttWidth) < 0 && (b = 0), !T || h.globals.isBarHorizontal && d.tooltipUtil.hasBars() || (v = v + S - 2 * (h.globals.series[e][C] < 0 ? S : 0)), v = v + h.globals.translateY - d.tooltipRect.ttHeight / 2, g.style.left = b + h.globals.translateX + "px", g.style.top = v + "px")
                        }
                    }, {
                        key: "getBarTooltipXY",
                        value: function(t) {
                            var e = this,
                                i = t.e,
                                r = t.opt,
                                l = this.w,
                                h = null,
                                d = this.ttCtx,
                                g = 0,
                                x = 0,
                                b = 0,
                                v = 0,
                                w = 0,
                                S = i.target.classList;
                            if (S.contains("apexcharts-bar-area") || S.contains("apexcharts-candlestick-area") || S.contains("apexcharts-boxPlot-area") || S.contains("apexcharts-rangebar-area")) {
                                var C = i.target,
                                    P = C.getBoundingClientRect(),
                                    T = r.elGrid.getBoundingClientRect(),
                                    I = P.height;
                                w = P.height;
                                var R = P.width,
                                    p = parseInt(C.getAttribute("cx"), 10),
                                    k = parseInt(C.getAttribute("cy"), 10);
                                v = parseFloat(C.getAttribute("barWidth"));
                                var M = "touchmove" === i.type ? i.touches[0].clientX : i.clientX;
                                h = parseInt(C.getAttribute("j"), 10), g = parseInt(C.parentNode.getAttribute("rel"), 10) - 1;
                                var D = C.getAttribute("data-range-y1"),
                                    X = C.getAttribute("data-range-y2");
                                l.globals.comboCharts && (g = parseInt(C.parentNode.getAttribute("data:realIndex"), 10));
                                var H = function(U) {
                                        return l.globals.isXNumeric ? p - R / 2 : e.isVerticalGroupedRangeBar ? p + R / 2 : p - d.dataPointsDividedWidth + R / 2
                                    },
                                    j = function() {
                                        return k - d.dataPointsDividedHeight + I / 2 - d.tooltipRect.ttHeight / 2
                                    };
                                d.tooltipLabels.drawSeriesTexts({
                                    ttItems: r.ttItems,
                                    i: g,
                                    j: h,
                                    y1: D ? parseInt(D, 10) : null,
                                    y2: X ? parseInt(X, 10) : null,
                                    shared: !d.showOnIntersect && l.config.tooltip.shared,
                                    e: i
                                }), l.config.tooltip.followCursor ? l.globals.isBarHorizontal ? (x = M - T.left + 15, b = j()) : (x = H(), b = i.clientY - T.top - d.tooltipRect.ttHeight / 2 - 15) : l.globals.isBarHorizontal ? ((x = p) < d.xyRatios.baseLineInvertedY && (x = p - d.tooltipRect.ttWidth), b = j()) : (x = H(), b = k)
                            }
                            return {
                                x,
                                y: b,
                                barHeight: w,
                                barWidth: v,
                                i: g,
                                j: h
                            }
                        }
                    }]), _
                }(),
                Fe = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.ttCtx = t
                    }
                    return ht(_, [{
                        key: "drawXaxisTooltip",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx,
                                i = "bottom" === t.config.xaxis.position;
                            e.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
                            var r = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
                                l = t.globals.dom.elWrap;
                            e.isXAxisTooltipEnabled && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", r + " apexcharts-theme-" + t.config.tooltip.theme), l.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText))
                        }
                    }, {
                        key: "drawYaxisTooltip",
                        value: function() {
                            for (var t = this.w, e = this.ttCtx, i = function(l) {
                                    var h = t.config.yaxis[l].opposite || t.config.yaxis[l].crosshairs.opposite;
                                    e.yaxisOffX = h ? t.globals.gridWidth + 1 : 1;
                                    var d = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(l, h ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                                    t.globals.yAxisSameScaleIndices.map(function(x, b) {
                                        x.map(function(v, w) {
                                            w === l && (d += t.config.yaxis[w].show ? " " : " apexcharts-yaxistooltip-hidden")
                                        })
                                    });
                                    var g = t.globals.dom.elWrap;
                                    null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(l)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", d + " apexcharts-theme-" + t.config.tooltip.theme), g.appendChild(e.yaxisTooltip), 0 === l && (e.yaxisTooltipText = []), e.yaxisTooltipText[l] = document.createElement("div"), e.yaxisTooltipText[l].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[l]))
                                }, r = 0; r < t.config.yaxis.length; r++) i(r)
                        }
                    }, {
                        key: "setXCrosshairWidth",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx,
                                i = e.getElXCrosshairs();
                            if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
                                var r = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                if (null !== r && "barWidth" === t.config.xaxis.crosshairs.width) {
                                    var l = parseFloat(r.getAttribute("barWidth"));
                                    e.xcrosshairsWidth = l
                                } else "tickWidth" === t.config.xaxis.crosshairs.width && (e.xcrosshairsWidth = t.globals.gridWidth / t.globals.labels.length)
                            } else if ("tickWidth" === t.config.xaxis.crosshairs.width) e.xcrosshairsWidth = t.globals.gridWidth / t.globals.labels.length;
                            else if ("barWidth" === t.config.xaxis.crosshairs.width) {
                                var g = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                if (null !== g) {
                                    var x = parseFloat(g.getAttribute("barWidth"));
                                    e.xcrosshairsWidth = x
                                } else e.xcrosshairsWidth = 1
                            }
                            t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth)
                        }
                    }, {
                        key: "handleYCrosshair",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx;
                            e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
                        }
                    }, {
                        key: "drawYaxisTooltipText",
                        value: function(t, e, i) {
                            var r = this.ttCtx,
                                l = this.w,
                                h = l.globals.yLabelFormatters[t];
                            if (r.yaxisTooltips[t]) {
                                var d = r.getElGrid().getBoundingClientRect(),
                                    b = l.globals.minYArr[t] + (l.globals.maxYArr[t] - l.globals.minYArr[t] - (e - d.top) * i.yRatio[t]);
                                r.tooltipPosition.moveYCrosshairs(e - d.top), r.yaxisTooltipText[t].innerHTML = h(b), r.tooltipPosition.moveYAxisTooltip(t)
                            }
                        }
                    }]), _
                }(),
                yi = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w;
                        var e = this.w;
                        this.tConfig = e.config.tooltip, this.tooltipUtil = new vi(this), this.tooltipLabels = new Ns(this), this.tooltipPosition = new Ke(this), this.marker = new si(this), this.intersect = new Vi(this), this.axesTooltip = new Fe(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !e.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now()
                    }
                    return ht(_, [{
                        key: "getElTooltip",
                        value: function(t) {
                            return t || (t = this), t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
                        }
                    }, {
                        key: "getElXCrosshairs",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
                        }
                    }, {
                        key: "getElGrid",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
                        }
                    }, {
                        key: "drawTooltip",
                        value: function(t) {
                            var e = this.w;
                            this.xyRatios = t, this.isXAxisTooltipEnabled = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map(function(h, d) {
                                return !!(h.show && h.tooltip.enabled && e.globals.axisCharts)
                            }), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
                            var i = document.createElement("div");
                            if (i.classList.add("apexcharts-tooltip"), e.config.tooltip.cssClass && i.classList.add(e.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
                                this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
                                var r = new Ye(this.ctx);
                                this.xAxisTicksPositions = r.getXAxisTicksPositions()
                            }
                            if (!e.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
                                this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
                                var l = e.globals.series.length;
                                (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (l = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(l), this.addSVGEvents()
                            }
                        }
                    }, {
                        key: "createTTElements",
                        value: function(t) {
                            for (var e = this, i = this.w, r = [], l = this.getElTooltip(), h = function(g) {
                                    var x = document.createElement("div");
                                    x.classList.add("apexcharts-tooltip-series-group"), x.style.order = i.config.tooltip.inverseOrder ? t - g : g + 1, e.tConfig.shared && e.tConfig.enabledOnSeries && Array.isArray(e.tConfig.enabledOnSeries) && e.tConfig.enabledOnSeries.indexOf(g) < 0 && x.classList.add("apexcharts-tooltip-series-group-hidden");
                                    var b = document.createElement("span");
                                    b.classList.add("apexcharts-tooltip-marker"), b.style.backgroundColor = i.globals.colors[g], x.appendChild(b);
                                    var v = document.createElement("div");
                                    v.classList.add("apexcharts-tooltip-text"), v.style.fontFamily = e.tConfig.style.fontFamily || i.config.chart.fontFamily, v.style.fontSize = e.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(w) {
                                        var S = document.createElement("div");
                                        S.classList.add("apexcharts-tooltip-".concat(w, "-group"));
                                        var C = document.createElement("span");
                                        C.classList.add("apexcharts-tooltip-text-".concat(w, "-label")), S.appendChild(C);
                                        var P = document.createElement("span");
                                        P.classList.add("apexcharts-tooltip-text-".concat(w, "-value")), S.appendChild(P), v.appendChild(S)
                                    }), x.appendChild(v), l.appendChild(x), r.push(x)
                                }, d = 0; d < t; d++) h(d);
                            return r
                        }
                    }, {
                        key: "addSVGEvents",
                        value: function() {
                            var t = this.w,
                                e = t.config.chart.type,
                                i = this.getElTooltip(),
                                r = !("bar" !== e && "candlestick" !== e && "boxPlot" !== e && "rangeBar" !== e),
                                l = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
                                h = t.globals.dom.Paper.node,
                                d = this.getElGrid();
                            d && (this.seriesBound = d.getBoundingClientRect());
                            var g, x = [],
                                b = [],
                                v = {
                                    hoverArea: h,
                                    elGrid: d,
                                    tooltipEl: i,
                                    tooltipY: x,
                                    tooltipX: b,
                                    ttItems: this.ttItems
                                };
                            if (t.globals.axisCharts && (l ? g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : r ? g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e && "treemap" !== e || (g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), g && g.length))
                                for (var w = 0; w < g.length; w++) x.push(g[w].getAttribute("cy")), b.push(g[w].getAttribute("cx"));
                            if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || r && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([h], v);
                            else if (r && !t.globals.comboCharts || l && this.showOnIntersect) this.addDatapointEventsListeners(v);
                            else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
                                var S = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                                this.addPathsEventListeners(S, v)
                            }
                            if (this.showOnIntersect) {
                                var C = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                                C.length > 0 && this.addPathsEventListeners(C, v), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(v)
                            }
                        }
                    }, {
                        key: "drawFixedTooltipRect",
                        value: function() {
                            var t = this.w,
                                e = this.getElTooltip(),
                                i = e.getBoundingClientRect(),
                                r = i.width + 10,
                                l = i.height + 10,
                                h = this.tConfig.fixed.offsetX,
                                d = this.tConfig.fixed.offsetY,
                                g = this.tConfig.fixed.position.toLowerCase();
                            return g.indexOf("right") > -1 && (h = h + t.globals.svgWidth - r + 10), g.indexOf("bottom") > -1 && (d = d + t.globals.svgHeight - l - 10), e.style.left = h + "px", e.style.top = d + "px", {
                                x: h,
                                y: d,
                                ttWidth: r,
                                ttHeight: l
                            }
                        }
                    }, {
                        key: "addDatapointEventsListeners",
                        value: function(t) {
                            var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                            this.addPathsEventListeners(e, t)
                        }
                    }, {
                        key: "addPathsEventListeners",
                        value: function(t, e) {
                            for (var i = this, r = function(h) {
                                    var d = {
                                        paths: t[h],
                                        tooltipEl: e.tooltipEl,
                                        tooltipY: e.tooltipY,
                                        tooltipX: e.tooltipX,
                                        elGrid: e.elGrid,
                                        hoverArea: e.hoverArea,
                                        ttItems: e.ttItems
                                    };
                                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(g) {
                                        return t[h].addEventListener(g, i.onSeriesHover.bind(i, d), {
                                            capture: !1,
                                            passive: !0
                                        })
                                    })
                                }, l = 0; l < t.length; l++) r(l)
                        }
                    }, {
                        key: "onSeriesHover",
                        value: function(t, e) {
                            var i = this,
                                r = Date.now() - this.lastHoverTime;
                            r >= 100 ? this.seriesHover(t, e) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
                                i.seriesHover(t, e)
                            }, 100 - r))
                        }
                    }, {
                        key: "seriesHover",
                        value: function(t, e) {
                            var i = this;
                            this.lastHoverTime = Date.now();
                            var r = [],
                                l = this.w;
                            l.config.chart.group && (r = this.ctx.getGroupedCharts()), l.globals.axisCharts && (l.globals.minX === -1 / 0 && l.globals.maxX === 1 / 0 || 0 === l.globals.dataPoints) || (r.length ? r.forEach(function(h) {
                                var d = i.getElTooltip(h);
                                h.w.globals.minX === i.w.globals.minX && h.w.globals.maxX === i.w.globals.maxX && h.w.globals.tooltip.seriesHoverByContext({
                                    chartCtx: h,
                                    ttCtx: h.w.globals.tooltip,
                                    opt: {
                                        paths: t.paths,
                                        tooltipEl: d,
                                        tooltipY: t.tooltipY,
                                        tooltipX: t.tooltipX,
                                        elGrid: t.elGrid,
                                        hoverArea: t.hoverArea,
                                        ttItems: h.w.globals.tooltip.ttItems
                                    },
                                    e
                                })
                            }) : this.seriesHoverByContext({
                                chartCtx: this.ctx,
                                ttCtx: this.w.globals.tooltip,
                                opt: t,
                                e
                            }))
                        }
                    }, {
                        key: "seriesHoverByContext",
                        value: function(t) {
                            var e = t.chartCtx,
                                i = t.ttCtx,
                                r = t.opt,
                                l = t.e,
                                h = e.w,
                                d = this.getElTooltip();
                            d && (i.tooltipRect = {
                                x: 0,
                                y: 0,
                                ttWidth: d.getBoundingClientRect().width,
                                ttHeight: d.getBoundingClientRect().height
                            }, i.e = l, i.tooltipUtil.hasBars() && !h.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new xe(e).toggleSeriesOnHover(l, l.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), h.globals.axisCharts ? i.axisChartsTooltips({
                                e: l,
                                opt: r,
                                tooltipRect: i.tooltipRect
                            }) : i.nonAxisChartsTooltips({
                                e: l,
                                opt: r,
                                tooltipRect: i.tooltipRect
                            }))
                        }
                    }, {
                        key: "axisChartsTooltips",
                        value: function(t) {
                            var e, i, r = t.e,
                                l = t.opt,
                                h = this.w,
                                d = l.elGrid.getBoundingClientRect(),
                                g = "touchmove" === r.type ? r.touches[0].clientX : r.clientX,
                                x = "touchmove" === r.type ? r.touches[0].clientY : r.clientY;
                            if (this.clientY = x, this.clientX = g, h.globals.capturedSeriesIndex = -1, h.globals.capturedDataPointIndex = -1, x < d.top || x > d.top + d.height) this.handleMouseOut(l);
                            else {
                                if (Array.isArray(this.tConfig.enabledOnSeries) && !h.config.tooltip.shared) {
                                    var b = parseInt(l.paths.getAttribute("index"), 10);
                                    if (this.tConfig.enabledOnSeries.indexOf(b) < 0) return void this.handleMouseOut(l)
                                }
                                var v = this.getElTooltip(),
                                    w = this.getElXCrosshairs(),
                                    S = h.globals.xyCharts || "bar" === h.config.chart.type && !h.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || h.globals.comboCharts && this.tooltipUtil.hasBars();
                                if ("mousemove" === r.type || "touchmove" === r.type || "mouseup" === r.type) {
                                    if (h.globals.collapsedSeries.length + h.globals.ancillaryCollapsedSeries.length === h.globals.series.length) return;
                                    null !== w && w.classList.add("apexcharts-active");
                                    var C = this.yaxisTooltips.filter(function(I) {
                                        return !0 === I
                                    });
                                    if (null !== this.ycrosshairs && C.length && this.ycrosshairs.classList.add("apexcharts-active"), S && !this.showOnIntersect) this.handleStickyTooltip(r, g, x, l);
                                    else if ("heatmap" === h.config.chart.type || "treemap" === h.config.chart.type) {
                                        var P = this.intersect.handleHeatTreeTooltip({
                                            e: r,
                                            opt: l,
                                            x: e,
                                            y: i,
                                            type: h.config.chart.type
                                        });
                                        i = P.y, v.style.left = (e = P.x) + "px", v.style.top = i + "px"
                                    } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                        e: r,
                                        opt: l
                                    }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                        e: r,
                                        opt: l,
                                        x: e,
                                        y: i
                                    });
                                    if (this.yaxisTooltips.length)
                                        for (var T = 0; T < h.config.yaxis.length; T++) this.axesTooltip.drawYaxisTooltipText(T, x, this.xyRatios);
                                    l.tooltipEl.classList.add("apexcharts-active")
                                } else "mouseout" !== r.type && "touchend" !== r.type || this.handleMouseOut(l)
                            }
                        }
                    }, {
                        key: "nonAxisChartsTooltips",
                        value: function(t) {
                            var e = t.e,
                                i = t.opt,
                                r = t.tooltipRect,
                                l = this.w,
                                h = i.paths.getAttribute("rel"),
                                d = this.getElTooltip(),
                                g = l.globals.dom.elWrap.getBoundingClientRect();
                            if ("mousemove" === e.type || "touchmove" === e.type) {
                                d.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                                    ttItems: i.ttItems,
                                    i: parseInt(h, 10) - 1,
                                    shared: !1
                                });
                                var b = l.globals.clientY - g.top - r.ttHeight - 10;
                                if (d.style.left = l.globals.clientX - g.left - r.ttWidth / 2 + "px", d.style.top = b + "px", l.config.legend.tooltipHoverFormatter) {
                                    var v = h - 1,
                                        w = (0, l.config.legend.tooltipHoverFormatter)(this.legendLabels[v].getAttribute("data:default-text"), {
                                            seriesIndex: v,
                                            dataPointIndex: v,
                                            w: l
                                        });
                                    this.legendLabels[v].innerHTML = w
                                }
                            } else "mouseout" !== e.type && "touchend" !== e.type || (d.classList.remove("apexcharts-active"), l.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(S) {
                                var C = S.getAttribute("data:default-text");
                                S.innerHTML = decodeURIComponent(C)
                            }))
                        }
                    }, {
                        key: "handleStickyTooltip",
                        value: function(t, e, i, r) {
                            var l = this.w,
                                h = this.tooltipUtil.getNearestValues({
                                    context: this,
                                    hoverArea: r.hoverArea,
                                    elGrid: r.elGrid,
                                    clientX: e,
                                    clientY: i
                                }),
                                d = h.j,
                                g = h.capturedSeries;
                            l.globals.collapsedSeriesIndices.includes(g) && (g = null);
                            var x = r.elGrid.getBoundingClientRect();
                            if (h.hoverX < 0 || h.hoverX > x.width) this.handleMouseOut(r);
                            else if (null !== g) this.handleStickyCapturedSeries(t, g, r, d);
                            else if (this.tooltipUtil.isXoverlap(d) || l.globals.isBarHorizontal) {
                                var b = l.globals.series.findIndex(function(v, w) {
                                    return !l.globals.collapsedSeriesIndices.includes(w)
                                });
                                this.create(t, this, b, d, r.ttItems)
                            }
                        }
                    }, {
                        key: "handleStickyCapturedSeries",
                        value: function(t, e, i, r) {
                            var l = this.w;
                            if (this.tConfig.shared || null !== l.globals.series[e][r]) {
                                if (void 0 !== l.globals.series[e][r]) this.tConfig.shared && this.tooltipUtil.isXoverlap(r) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, r, i.ttItems) : this.create(t, this, e, r, i.ttItems, !1);
                                else if (this.tooltipUtil.isXoverlap(r)) {
                                    var h = l.globals.series.findIndex(function(d, g) {
                                        return !l.globals.collapsedSeriesIndices.includes(g)
                                    });
                                    this.create(t, this, h, r, i.ttItems)
                                }
                            } else this.handleMouseOut(i)
                        }
                    }, {
                        key: "deactivateHoverFilter",
                        value: function() {
                            for (var t = this.w, e = new ot(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), r = 0; r < i.length; r++) e.pathMouseLeave(i[r])
                        }
                    }, {
                        key: "handleMouseOut",
                        value: function(t) {
                            var e = this.w,
                                i = this.getElXCrosshairs();
                            if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                                null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                                for (var r = 0; r < this.yaxisTTEls.length; r++) this.yaxisTTEls[r].classList.remove("apexcharts-active")
                            }
                            e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(l) {
                                var h = l.getAttribute("data:default-text");
                                l.innerHTML = decodeURIComponent(h)
                            })
                        }
                    }, {
                        key: "markerClick",
                        value: function(t, e, i) {
                            var r = this.w;
                            "function" == typeof r.config.chart.events.markerClick && r.config.chart.events.markerClick(t, this.ctx, {
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: r
                            }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: r
                            }])
                        }
                    }, {
                        key: "create",
                        value: function(t, e, i, r, l) {
                            var h, d, g, x, b, v, w, S, C, P, T, I, R, p, k, M, D = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                X = this.w,
                                H = e;
                            "mouseup" === t.type && this.markerClick(t, i, r), null === D && (D = this.tConfig.shared);
                            var j = this.tooltipUtil.hasMarkers(i),
                                U = this.tooltipUtil.getElBars();
                            if (X.config.legend.tooltipHoverFormatter) {
                                var Q = X.config.legend.tooltipHoverFormatter,
                                    at = Array.from(this.legendLabels);
                                at.forEach(function(Ce) {
                                    var De = Ce.getAttribute("data:default-text");
                                    Ce.innerHTML = decodeURIComponent(De)
                                });
                                for (var it = 0; it < at.length; it++) {
                                    var mt = at[it],
                                        yt = parseInt(mt.getAttribute("i"), 10),
                                        Pt = decodeURIComponent(mt.getAttribute("data:default-text")),
                                        Dt = Q(Pt, {
                                            seriesIndex: D ? yt : i,
                                            dataPointIndex: r,
                                            w: X
                                        });
                                    if (D) mt.innerHTML = X.globals.collapsedSeriesIndices.indexOf(yt) < 0 ? Dt : Pt;
                                    else if (mt.innerHTML = yt === i ? Dt : Pt, i === yt) break
                                }
                            }
                            var Vt = ut(ut({
                                ttItems: l,
                                i,
                                j: r
                            }, void 0 !== (null === (h = X.globals.seriesRange) || void 0 === h || null === (d = h[i]) || void 0 === d || null === (g = d[r]) || void 0 === g || null === (x = g.y[0]) || void 0 === x ? void 0 : x.y1) && {
                                y1: null === (b = X.globals.seriesRange) || void 0 === b || null === (v = b[i]) || void 0 === v || null === (w = v[r]) || void 0 === w || null === (S = w.y[0]) || void 0 === S ? void 0 : S.y1
                            }), void 0 !== (null === (C = X.globals.seriesRange) || void 0 === C || null === (P = C[i]) || void 0 === P || null === (T = P[r]) || void 0 === T || null === (I = T.y[0]) || void 0 === I ? void 0 : I.y2) && {
                                y2: null === (R = X.globals.seriesRange) || void 0 === R || null === (p = R[i]) || void 0 === p || null === (k = p[r]) || void 0 === k || null === (M = k.y[0]) || void 0 === M ? void 0 : M.y2
                            });
                            if (D) {
                                if (H.tooltipLabels.drawSeriesTexts(ut(ut({}, Vt), {}, {
                                        shared: !this.showOnIntersect && this.tConfig.shared
                                    })), j) X.globals.markers.largestSize > 0 ? H.marker.enlargePoints(r) : H.tooltipPosition.moveDynamicPointsOnHover(r);
                                else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(U), this.barSeriesHeight > 0)) {
                                    var ee = new ot(this.ctx),
                                        ie = X.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(r, "']"));
                                    this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(r, i);
                                    for (var Kt = 0; Kt < ie.length; Kt++) ee.pathMouseEnter(ie[Kt])
                                }
                            } else H.tooltipLabels.drawSeriesTexts(ut({
                                shared: !1
                            }, Vt)), this.tooltipUtil.hasBars() && H.tooltipPosition.moveStickyTooltipOverBars(r, i), j && H.tooltipPosition.moveMarkers(i, r)
                        }
                    }]), _
                }(),
                Qe = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.barCtx = t, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter)
                    }
                    return ht(_, [{
                        key: "handleBarDataLabels",
                        value: function(t) {
                            var e = t.x,
                                i = t.y,
                                r = t.y1,
                                l = t.y2,
                                h = t.i,
                                d = t.j,
                                g = t.realIndex,
                                x = t.groupIndex,
                                b = t.series,
                                v = t.barHeight,
                                w = t.barWidth,
                                S = t.barXPosition,
                                C = t.barYPosition,
                                P = t.visibleSeries,
                                T = t.renderedPath,
                                I = this.w,
                                R = new ot(this.barCtx.ctx),
                                p = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[g] : this.barCtx.strokeWidth,
                                k = e + parseFloat(w * P),
                                M = i + parseFloat(v * P);
                            I.globals.isXNumeric && !I.globals.isBarHorizontal && (k = e + parseFloat(w * (P + 1)), M = i + parseFloat(v * (P + 1)) - p);
                            var D, U, X = null,
                                H = e,
                                j = i,
                                Q = I.config.dataLabels,
                                at = this.barCtx.barOptions.dataLabels,
                                it = this.barCtx.barOptions.dataLabels.total;
                            void 0 !== C && this.barCtx.isRangeBar && (M = C, j = C), void 0 !== S && this.barCtx.isVerticalGroupedRangeBar && (k = S, H = S);
                            var mt = Q.offsetX,
                                yt = Q.offsetY,
                                Pt = {
                                    width: 0,
                                    height: 0
                                };
                            I.config.dataLabels.enabled && (Pt = R.getTextRects(I.globals.yLabelFormatters[0](this.barCtx.series[h][d]), parseFloat(Q.style.fontSize)));
                            var Vt = {
                                x: e,
                                y: i,
                                i: h,
                                j: d,
                                realIndex: g,
                                groupIndex: x || -1,
                                renderedPath: T,
                                bcx: k,
                                bcy: M,
                                barHeight: v,
                                barWidth: w,
                                textRects: Pt,
                                strokeWidth: p,
                                dataLabelsX: H,
                                dataLabelsY: j,
                                dataLabelsConfig: Q,
                                barDataLabelsConfig: at,
                                barTotalDataLabelsConfig: it,
                                offX: mt,
                                offY: yt
                            };
                            return U = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(Vt) : this.calculateColumnsDataLabelsPosition(Vt), T.attr({
                                cy: U.bcy,
                                cx: U.bcx,
                                j: d,
                                val: b[h][d],
                                barHeight: v,
                                barWidth: w
                            }), D = this.drawCalculatedDataLabels({
                                x: U.dataLabelsX,
                                y: U.dataLabelsY,
                                val: this.barCtx.isRangeBar ? [r, l] : b[h][d],
                                i: g,
                                j: d,
                                barWidth: w,
                                barHeight: v,
                                textRects: Pt,
                                dataLabelsConfig: Q
                            }), I.config.chart.stacked && it.enabled && (X = this.drawTotalDataLabels({
                                x: U.totalDataLabelsX,
                                y: U.totalDataLabelsY,
                                realIndex: g,
                                textAnchor: U.totalDataLabelsAnchor,
                                val: this.getStackedTotalDataLabel({
                                    realIndex: g,
                                    j: d
                                }),
                                dataLabelsConfig: Q,
                                barTotalDataLabelsConfig: it
                            })), {
                                dataLabels: D,
                                totalDataLabels: X
                            }
                        }
                    }, {
                        key: "getStackedTotalDataLabel",
                        value: function(t) {
                            var e = t.realIndex,
                                i = t.j,
                                r = this.w,
                                l = this.barCtx.stackedSeriesTotals[i];
                            return this.totalFormatter && (l = this.totalFormatter(l, ut(ut({}, r), {}, {
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: r
                            }))), l
                        }
                    }, {
                        key: "calculateColumnsDataLabelsPosition",
                        value: function(t) {
                            var e, i, r = this.w,
                                l = t.i,
                                h = t.j,
                                d = t.realIndex,
                                g = t.groupIndex,
                                x = t.y,
                                b = t.bcx,
                                v = t.barWidth,
                                w = t.barHeight,
                                S = t.textRects,
                                C = t.dataLabelsX,
                                P = t.dataLabelsY,
                                T = t.dataLabelsConfig,
                                I = t.barDataLabelsConfig,
                                R = t.barTotalDataLabelsConfig,
                                p = t.strokeWidth,
                                k = t.offX,
                                M = t.offY;
                            w = Math.abs(w);
                            var D = "vertical" === r.config.plotOptions.bar.dataLabels.orientation,
                                X = this.barCtx.barHelpers.getZeroValueEncounters({
                                    i: l,
                                    j: h
                                }).zeroEncounters;
                            b = b - p / 2 + (-1 !== g ? g * v : 0), this.barCtx.isVerticalGroupedRangeBar ? C += v / 2 : (C = r.globals.isXNumeric ? b - v / 2 + k : b - r.globals.gridWidth / r.globals.dataPoints + v / 2 + k, X > 0 && r.config.plotOptions.bar.hideZeroBarsWhenGrouped && (C -= v * X)), D && (C = C + S.height / 2 - p / 2 - 2);
                            var j = this.barCtx.series[l][h] < 0,
                                U = x;
                            switch (this.barCtx.isReversed && (U = x - w + (j ? 2 * w : 0), x -= w), I.position) {
                                case "center":
                                    P = D ? j ? U - w / 2 + M : U + w / 2 - M : j ? U - w / 2 + S.height / 2 + M : U + w / 2 + S.height / 2 - M;
                                    break;
                                case "bottom":
                                    P = D ? j ? U - w + M : U + w - M : j ? U - w + S.height + p + M : U + w - S.height / 2 + p - M;
                                    break;
                                case "top":
                                    P = D ? j ? U + M : U - M : j ? U - S.height / 2 - M : U + S.height + M
                            }
                            if (this.barCtx.lastActiveBarSerieIndex === d && R.enabled) {
                                var Q = new ot(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                                    realIndex: d,
                                    j: h
                                }), T.fontSize);
                                e = j ? U - Q.height / 2 - M - R.offsetY + 18 : U + Q.height + M + R.offsetY - 18, i = C + R.offsetX
                            }
                            return r.config.chart.stacked || (P < 0 ? P = 0 + p : P + S.height / 3 > r.globals.gridHeight && (P = r.globals.gridHeight - p)), {
                                bcx: b,
                                bcy: x,
                                dataLabelsX: C,
                                dataLabelsY: P,
                                totalDataLabelsX: i,
                                totalDataLabelsY: e,
                                totalDataLabelsAnchor: "middle"
                            }
                        }
                    }, {
                        key: "calculateBarsDataLabelsPosition",
                        value: function(t) {
                            var e = this.w,
                                i = t.x,
                                r = t.i,
                                l = t.j,
                                h = t.realIndex,
                                d = t.groupIndex,
                                g = t.bcy,
                                x = t.barHeight,
                                b = t.barWidth,
                                v = t.textRects,
                                w = t.dataLabelsX,
                                S = t.strokeWidth,
                                C = t.dataLabelsConfig,
                                P = t.barDataLabelsConfig,
                                T = t.barTotalDataLabelsConfig,
                                I = t.offX,
                                R = t.offY,
                                p = e.globals.gridHeight / e.globals.dataPoints;
                            b = Math.abs(b);
                            var k, M, D = (g += -1 !== d ? d * x : 0) - (this.barCtx.isRangeBar ? 0 : p) + x / 2 + v.height / 2 + R - 3,
                                X = "start",
                                H = this.barCtx.series[r][l] < 0,
                                j = i;
                            switch (this.barCtx.isReversed && (j = i + b - (H ? 2 * b : 0), i = e.globals.gridWidth - b), P.position) {
                                case "center":
                                    w = H ? j + b / 2 - I : Math.max(v.width / 2, j - b / 2) + I;
                                    break;
                                case "bottom":
                                    w = H ? j + b - S - Math.round(v.width / 2) - I : j - b + S + Math.round(v.width / 2) + I;
                                    break;
                                case "top":
                                    w = H ? j - S + Math.round(v.width / 2) - I : j - S - Math.round(v.width / 2) + I
                            }
                            if (this.barCtx.lastActiveBarSerieIndex === h && T.enabled) {
                                var U = new ot(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                                    realIndex: h,
                                    j: l
                                }), C.fontSize);
                                H ? (k = j - S + Math.round(U.width / 2) - I - T.offsetX - 15, X = "end") : k = j - S - Math.round(U.width / 2) + I + T.offsetX + 15, M = D + T.offsetY
                            }
                            return e.config.chart.stacked || (w < 0 ? w = w + v.width + S : w + v.width / 2 > e.globals.gridWidth && (w = e.globals.gridWidth - v.width - S)), {
                                bcx: i,
                                bcy: g,
                                dataLabelsX: w,
                                dataLabelsY: D,
                                totalDataLabelsX: k,
                                totalDataLabelsY: M,
                                totalDataLabelsAnchor: X
                            }
                        }
                    }, {
                        key: "drawCalculatedDataLabels",
                        value: function(t) {
                            var e = t.x,
                                i = t.y,
                                r = t.val,
                                l = t.i,
                                h = t.j,
                                d = t.textRects,
                                g = t.barHeight,
                                x = t.barWidth,
                                b = t.dataLabelsConfig,
                                v = this.w,
                                w = "rotate(0)";
                            "vertical" === v.config.plotOptions.bar.dataLabels.orientation && (w = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
                            var S = new ve(this.barCtx.ctx),
                                C = new ot(this.barCtx.ctx),
                                P = b.formatter,
                                T = null,
                                I = v.globals.collapsedSeriesIndices.indexOf(l) > -1;
                            if (b.enabled && !I) {
                                T = C.group({
                                    class: "apexcharts-data-labels",
                                    transform: w
                                });
                                var R = "";
                                void 0 !== r && (R = P(r, ut(ut({}, v), {}, {
                                    seriesIndex: l,
                                    dataPointIndex: h,
                                    w: v
                                }))), !r && v.config.plotOptions.bar.hideZeroBarsWhenGrouped && (R = "");
                                var p = v.globals.series[l][h] < 0,
                                    k = v.config.plotOptions.bar.dataLabels.position;
                                "vertical" === v.config.plotOptions.bar.dataLabels.orientation && ("top" === k && (b.textAnchor = p ? "end" : "start"), "center" === k && (b.textAnchor = "middle"), "bottom" === k && (b.textAnchor = p ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && x < C.getTextRects(R, parseFloat(b.style.fontSize)).width && (R = ""), v.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? d.width / 1.6 > Math.abs(x) && (R = "") : d.height / 1.6 > Math.abs(g) && (R = ""));
                                var M = ut({}, b);
                                this.barCtx.isHorizontal && r < 0 && ("start" === b.textAnchor ? M.textAnchor = "end" : "end" === b.textAnchor && (M.textAnchor = "start")), S.plotDataLabelsText({
                                    x: e,
                                    y: i,
                                    text: R,
                                    i: l,
                                    j: h,
                                    parent: T,
                                    dataLabelsConfig: M,
                                    alwaysDrawDataLabel: !0,
                                    offsetCorrection: !0
                                })
                            }
                            return T
                        }
                    }, {
                        key: "drawTotalDataLabels",
                        value: function(t) {
                            var e, i = t.x,
                                r = t.y,
                                l = t.val,
                                h = t.realIndex,
                                d = t.textAnchor,
                                g = t.barTotalDataLabelsConfig,
                                x = new ot(this.barCtx.ctx);
                            return g.enabled && void 0 !== i && void 0 !== r && this.barCtx.lastActiveBarSerieIndex === h && (e = x.drawText({
                                x: i,
                                y: r,
                                foreColor: g.style.color,
                                text: l,
                                textAnchor: d,
                                fontFamily: g.style.fontFamily,
                                fontSize: g.style.fontSize,
                                fontWeight: g.style.fontWeight
                            })), e
                        }
                    }]), _
                }(),
                Xe = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.barCtx = t
                    }
                    return ht(_, [{
                        key: "initVariables",
                        value: function(t) {
                            var e = this.w;
                            this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
                            for (var i = 0; i < t.length; i++)
                                if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric)
                                    for (var r = 0; r < t[i].length; r++) e.globals.seriesX[i][r] > e.globals.minX && e.globals.seriesX[i][r] < e.globals.maxX && this.barCtx.visibleItems++;
                                else this.barCtx.visibleItems = e.globals.dataPoints;
                            0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e.globals.comboCharts || this.checkZeroSeries({
                                series: t
                            })
                        }
                    }, {
                        key: "initialPositions",
                        value: function() {
                            var t, e, i, r, l, h, d, g, x = this.w,
                                b = x.globals.dataPoints;
                            this.barCtx.isRangeBar && (b = x.globals.labels.length);
                            var v = this.barCtx.seriesLen;
                            if (x.config.plotOptions.bar.rangeBarGroupRows && (v = 1), this.barCtx.isHorizontal) l = (i = x.globals.gridHeight / b) / v, x.globals.isXNumeric && (l = (i = x.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), l = l * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (l = parseInt(this.barCtx.barOptions.barHeight, 10)), g = this.barCtx.baseLineInvertedY + x.globals.padHorizontal + (this.barCtx.isReversed ? x.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (g = x.globals.gridWidth / 2), e = (i - l * this.barCtx.seriesLen) / 2;
                            else {
                                if (r = x.globals.gridWidth / this.barCtx.visibleItems, x.config.xaxis.convertedCatToNumeric && (r = x.globals.gridWidth / x.globals.dataPoints), h = r / v * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, x.globals.isXNumeric) {
                                    var w = this.barCtx.xRatio;
                                    x.config.xaxis.convertedCatToNumeric && (w = this.barCtx.initialXRatio), x.globals.minXDiff && .5 !== x.globals.minXDiff && x.globals.minXDiff / w > 0 && (r = x.globals.minXDiff / w), (h = r / v * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (h = 1)
                                } - 1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (h = parseInt(this.barCtx.barOptions.columnWidth, 10)), d = x.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? x.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = x.globals.padHorizontal + (r - h * this.barCtx.seriesLen) / 2
                            }
                            return {
                                x: t,
                                y: e,
                                yDivision: i,
                                xDivision: r,
                                barHeight: l,
                                barWidth: h,
                                zeroH: d,
                                zeroW: g
                            }
                        }
                    }, {
                        key: "initializeStackedPrevVars",
                        value: function(t) {
                            var e = t.w;
                            e.globals.hasSeriesGroups ? e.globals.seriesGroups.forEach(function(i) {
                                t[i] || (t[i] = {}), t[i].prevY = [], t[i].prevX = [], t[i].prevYF = [], t[i].prevXF = [], t[i].prevYVal = [], t[i].prevXVal = []
                            }) : (t.prevY = [], t.prevX = [], t.prevYF = [], t.prevXF = [], t.prevYVal = [], t.prevXVal = [])
                        }
                    }, {
                        key: "initializeStackedXYVars",
                        value: function(t) {
                            var e = t.w;
                            e.globals.hasSeriesGroups ? e.globals.seriesGroups.forEach(function(i) {
                                t[i] || (t[i] = {}), t[i].xArrj = [], t[i].xArrjF = [], t[i].xArrjVal = [], t[i].yArrj = [], t[i].yArrjF = [], t[i].yArrjVal = []
                            }) : (t.xArrj = [], t.xArrjF = [], t.xArrjVal = [], t.yArrj = [], t.yArrjF = [], t.yArrjVal = [])
                        }
                    }, {
                        key: "getPathFillColor",
                        value: function(t, e, i, r) {
                            var l, h, d, g, x = this.w,
                                b = new ce(this.barCtx.ctx),
                                v = null,
                                w = this.barCtx.barOptions.distributed ? i : e;
                            return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(S) {
                                t[e][i] >= S.from && t[e][i] <= S.to && (v = S.color)
                            }), x.config.series[e].data[i] && x.config.series[e].data[i].fillColor && (v = x.config.series[e].data[i].fillColor), b.fillPath({
                                seriesNumber: this.barCtx.barOptions.distributed ? w : r,
                                dataPointIndex: i,
                                color: v,
                                value: t[e][i],
                                fillConfig: null === (l = x.config.series[e].data[i]) || void 0 === l ? void 0 : l.fill,
                                fillType: null !== (h = x.config.series[e].data[i]) && void 0 !== h && null !== (d = h.fill) && void 0 !== d && d.type ? null === (g = x.config.series[e].data[i]) || void 0 === g ? void 0 : g.fill.type : x.config.fill.type
                            })
                        }
                    }, {
                        key: "getStrokeWidth",
                        value: function(t, e, i) {
                            var r = 0,
                                l = this.w;
                            return this.barCtx.isNullValue = !this.barCtx.series[t][e], l.config.stroke.show && (this.barCtx.isNullValue || (r = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), r
                        }
                    }, {
                        key: "shouldApplyRadius",
                        value: function(t) {
                            var e = this.w,
                                i = !1;
                            return e.config.plotOptions.bar.borderRadius > 0 && (e.config.chart.stacked && "last" === e.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === t && (i = !0) : i = !0), i
                        }
                    }, {
                        key: "barBackground",
                        value: function(t) {
                            var e = t.j,
                                i = t.i,
                                r = t.x1,
                                l = t.x2,
                                h = t.y1,
                                d = t.y2,
                                g = t.elSeries,
                                x = this.w,
                                b = new ot(this.barCtx.ctx),
                                v = new xe(this.barCtx.ctx).getActiveConfigSeriesIndex();
                            if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && v === i) {
                                e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                                var S = b.drawRect(void 0 !== r ? r : 0, void 0 !== h ? h : 0, void 0 !== l ? l : x.globals.gridWidth, void 0 !== d ? d : x.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, this.barCtx.barOptions.colors.backgroundBarColors[e], this.barCtx.barOptions.colors.backgroundBarOpacity);
                                g.add(S), S.node.classList.add("apexcharts-backgroundBar")
                            }
                        }
                    }, {
                        key: "getColumnPaths",
                        value: function(t) {
                            var e, i = t.barWidth,
                                r = t.barXPosition,
                                l = t.y1,
                                h = t.y2,
                                d = t.strokeWidth,
                                g = t.seriesGroup,
                                x = t.realIndex,
                                b = t.i,
                                v = t.j,
                                w = t.w,
                                S = new ot(this.barCtx.ctx);
                            (d = Array.isArray(d) ? d[x] : d) || (d = 0);
                            var C = i,
                                P = r;
                            null !== (e = w.config.series[x].data[v]) && void 0 !== e && e.columnWidthOffset && (P = r - w.config.series[x].data[v].columnWidthOffset / 2, C = i + w.config.series[x].data[v].columnWidthOffset);
                            var T = P,
                                I = P + C;
                            h += .001;
                            var R = S.move(T, l += .001),
                                p = S.move(T, l),
                                k = S.line(I - d, l);
                            if (w.globals.previousPaths.length > 0 && (p = this.barCtx.getPreviousPath(x, v, !1)), R = R + S.line(T, h) + S.line(I - d, h) + S.line(I - d, l) + ("around" === w.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), p = p + S.line(T, l) + k + k + k + k + k + S.line(T, l) + ("around" === w.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(x) && (R = S.roundPathCorners(R, w.config.plotOptions.bar.borderRadius)), w.config.chart.stacked) {
                                var M = this.barCtx;
                                w.globals.hasSeriesGroups && g && (M = this.barCtx[g]), M.yArrj.push(h), M.yArrjF.push(Math.abs(l - h)), M.yArrjVal.push(this.barCtx.series[b][v])
                            }
                            return {
                                pathTo: R,
                                pathFrom: p
                            }
                        }
                    }, {
                        key: "getBarpaths",
                        value: function(t) {
                            var e, i = t.barYPosition,
                                r = t.barHeight,
                                l = t.x1,
                                h = t.x2,
                                d = t.strokeWidth,
                                g = t.seriesGroup,
                                x = t.realIndex,
                                b = t.i,
                                v = t.j,
                                w = t.w,
                                S = new ot(this.barCtx.ctx);
                            (d = Array.isArray(d) ? d[x] : d) || (d = 0);
                            var C = i,
                                P = r;
                            null !== (e = w.config.series[x].data[v]) && void 0 !== e && e.barHeightOffset && (C = i - w.config.series[x].data[v].barHeightOffset / 2, P = r + w.config.series[x].data[v].barHeightOffset);
                            var T = C,
                                I = C + P;
                            h += .001;
                            var R = S.move(l += .001, T),
                                p = S.move(l, T);
                            w.globals.previousPaths.length > 0 && (p = this.barCtx.getPreviousPath(x, v, !1));
                            var k = S.line(l, I - d);
                            if (R = R + S.line(h, T) + S.line(h, I - d) + k + ("around" === w.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), p = p + S.line(l, T) + k + k + k + k + k + S.line(l, T) + ("around" === w.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(x) && (R = S.roundPathCorners(R, w.config.plotOptions.bar.borderRadius)), w.config.chart.stacked) {
                                var M = this.barCtx;
                                w.globals.hasSeriesGroups && g && (M = this.barCtx[g]), M.xArrj.push(h), M.xArrjF.push(Math.abs(l - h)), M.xArrjVal.push(this.barCtx.series[b][v])
                            }
                            return {
                                pathTo: R,
                                pathFrom: p
                            }
                        }
                    }, {
                        key: "checkZeroSeries",
                        value: function(t) {
                            for (var e = t.series, i = this.w, r = 0; r < e.length; r++) {
                                for (var l = 0, h = 0; h < e[i.globals.maxValsInArrayIndex].length; h++) l += e[r][h];
                                0 === l && this.barCtx.zeroSerieses.push(r)
                            }
                        }
                    }, {
                        key: "getXForValue",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : e;
                            return null != t && (i = e + t / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)), i
                        }
                    }, {
                        key: "getYForValue",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : e;
                            return null != t && (i = e - t / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i
                        }
                    }, {
                        key: "getGoalValues",
                        value: function(t, e, i, r, l) {
                            var h = this,
                                d = this.w,
                                g = [],
                                x = function(w, S) {
                                    var C;
                                    g.push((Et(C = {}, t, "x" === t ? h.getXForValue(w, e, !1) : h.getYForValue(w, i, !1)), Et(C, "attrs", S), C))
                                };
                            if (d.globals.seriesGoals[r] && d.globals.seriesGoals[r][l] && Array.isArray(d.globals.seriesGoals[r][l]) && d.globals.seriesGoals[r][l].forEach(function(w) {
                                    x(w.value, w)
                                }), this.barCtx.barOptions.isDumbbell && d.globals.seriesRange.length) {
                                var b = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : d.globals.colors,
                                    v = {
                                        strokeHeight: "x" === t ? 0 : d.globals.markers.size[r],
                                        strokeWidth: "x" === t ? d.globals.markers.size[r] : 0,
                                        strokeDashArray: 0,
                                        strokeLineCap: "round",
                                        strokeColor: Array.isArray(b[r]) ? b[r][0] : b[r]
                                    };
                                x(d.globals.seriesRangeStart[r][l], v), x(d.globals.seriesRangeEnd[r][l], ut(ut({}, v), {}, {
                                    strokeColor: Array.isArray(b[r]) ? b[r][1] : b[r]
                                }))
                            }
                            return g
                        }
                    }, {
                        key: "drawGoalLine",
                        value: function(t) {
                            var e = t.barXPosition,
                                i = t.barYPosition,
                                r = t.goalX,
                                l = t.goalY,
                                h = t.barWidth,
                                d = t.barHeight,
                                g = new ot(this.barCtx.ctx),
                                x = g.group({
                                    className: "apexcharts-bar-goals-groups"
                                });
                            x.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({
                                el: x.node
                            }), x.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
                            var b = null;
                            return this.barCtx.isHorizontal ? Array.isArray(r) && r.forEach(function(v) {
                                var w = void 0 !== v.attrs.strokeHeight ? v.attrs.strokeHeight : d / 2,
                                    S = i + w + d / 2;
                                b = g.drawLine(v.x, S - 2 * w, v.x, S, v.attrs.strokeColor ? v.attrs.strokeColor : void 0, v.attrs.strokeDashArray, v.attrs.strokeWidth ? v.attrs.strokeWidth : 2, v.attrs.strokeLineCap), x.add(b)
                            }) : Array.isArray(l) && l.forEach(function(v) {
                                var w = void 0 !== v.attrs.strokeWidth ? v.attrs.strokeWidth : h / 2,
                                    S = e + w + h / 2;
                                b = g.drawLine(S - 2 * w, v.y, S, v.y, v.attrs.strokeColor ? v.attrs.strokeColor : void 0, v.attrs.strokeDashArray, v.attrs.strokeHeight ? v.attrs.strokeHeight : 2, v.attrs.strokeLineCap), x.add(b)
                            }), x
                        }
                    }, {
                        key: "drawBarShadow",
                        value: function(t) {
                            var e = t.prevPaths,
                                i = t.currPaths,
                                r = t.color,
                                l = this.w,
                                h = e.x,
                                d = e.x1,
                                x = i.x,
                                b = i.x1,
                                v = i.barYPosition,
                                w = e.barYPosition + i.barHeight,
                                S = new ot(this.barCtx.ctx),
                                C = new q,
                                P = S.move(d, w) + S.line(h, w) + S.line(x, v) + S.line(b, v) + S.line(d, w) + ("around" === l.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
                            return S.drawPath({
                                d: P,
                                fill: C.shadeColor(.5, q.rgb2hex(r)),
                                stroke: "none",
                                strokeWidth: 0,
                                fillOpacity: 1,
                                classes: "apexcharts-bar-shadows"
                            })
                        }
                    }, {
                        key: "getZeroValueEncounters",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                l = 0,
                                h = 0;
                            return this.w.globals.seriesPercent.forEach(function(d, g) {
                                d[i] && l++, g < e && 0 === d[i] && h++
                            }), {
                                nonZeroColumns: l,
                                zeroEncounters: h
                            }
                        }
                    }]), _
                }(),
                Ne = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.w = t.w;
                        var i = this.w;
                        this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = e, null !== this.xyRatios && (this.xRatio = e.xRatio, this.initialXRatio = e.initialXRatio, this.yRatio = e.yRatio, this.invertedXRatio = e.invertedXRatio, this.invertedYRatio = e.invertedYRatio, this.baseLineY = e.baseLineY, this.baseLineInvertedY = e.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
                        var r = new xe(this.ctx);
                        this.lastActiveBarSerieIndex = r.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
                        var l = r.getBarSeriesIndices(),
                            h = new te(this.ctx);
                        this.stackedSeriesTotals = h.getStackedSeriesTotals(this.w.config.series.map(function(d, g) {
                            return -1 === l.indexOf(g) ? g : -1
                        }).filter(function(d) {
                            return -1 !== d
                        })), this.barHelpers = new Xe(this)
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ot(this.ctx),
                                l = new te(this.ctx, i);
                            t = l.getLogSeries(t), this.series = t, this.yRatio = l.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                            var h = r.group({
                                class: "apexcharts-bar-series apexcharts-plot-series"
                            });
                            i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
                            for (var d = 0, g = 0; d < t.length; d++, g++) {
                                var x, b, v, w, S = void 0,
                                    C = void 0,
                                    P = [],
                                    T = [],
                                    I = i.globals.comboCharts ? e[d] : d,
                                    R = r.group({
                                        class: "apexcharts-series",
                                        rel: d + 1,
                                        seriesName: q.escapeString(i.globals.seriesNames[I]),
                                        "data:realIndex": I
                                    });
                                this.ctx.series.addCollapsedClassToSeries(R, I), t[d].length > 0 && (this.visibleI = this.visibleI + 1);
                                var p = 0,
                                    k = 0;
                                this.yRatio.length > 1 && (this.yaxisIndex = I), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
                                var M = this.barHelpers.initialPositions();
                                C = M.y, p = M.barHeight, b = M.yDivision, w = M.zeroW, S = M.x, k = M.barWidth, x = M.xDivision, v = M.zeroH, this.horizontal || T.push(S + k / 2);
                                var D = r.group({
                                    class: "apexcharts-datalabels",
                                    "data:realIndex": I
                                });
                                i.globals.delayedElements.push({
                                    el: D.node
                                }), D.node.classList.add("apexcharts-element-hidden");
                                var X = r.group({
                                        class: "apexcharts-bar-goals-markers"
                                    }),
                                    H = r.group({
                                        class: "apexcharts-bar-shadows"
                                    });
                                i.globals.delayedElements.push({
                                    el: H.node
                                }), H.node.classList.add("apexcharts-element-hidden");
                                for (var j = 0; j < i.globals.dataPoints; j++) {
                                    var U = this.barHelpers.getStrokeWidth(d, j, I),
                                        Q = null,
                                        at = {
                                            indexes: {
                                                i: d,
                                                j,
                                                realIndex: I,
                                                bc: g
                                            },
                                            x: S,
                                            y: C,
                                            strokeWidth: U,
                                            elSeries: R
                                        };
                                    this.isHorizontal ? (Q = this.drawBarPaths(ut(ut({}, at), {}, {
                                        barHeight: p,
                                        zeroW: w,
                                        yDivision: b
                                    })), k = this.series[d][j] / this.invertedYRatio) : (Q = this.drawColumnPaths(ut(ut({}, at), {}, {
                                        xDivision: x,
                                        barWidth: k,
                                        zeroH: v
                                    })), p = this.series[d][j] / this.yRatio[this.yaxisIndex]);
                                    var it = this.barHelpers.getPathFillColor(t, d, j, I);
                                    if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && j > 0) {
                                        var mt = this.barHelpers.drawBarShadow({
                                            color: "string" == typeof it && -1 === it ? .indexOf("url") ? it : q.hexToRgba(i.globals.colors[d]),
                                            prevPaths: this.pathArr[this.pathArr.length - 1],
                                            currPaths: Q
                                        });
                                        mt && H.add(mt)
                                    }
                                    this.pathArr.push(Q);
                                    var yt = this.barHelpers.drawGoalLine({
                                        barXPosition: Q.barXPosition,
                                        barYPosition: Q.barYPosition,
                                        goalX: Q.goalX,
                                        goalY: Q.goalY,
                                        barHeight: p,
                                        barWidth: k
                                    });
                                    yt && X.add(yt), C = Q.y, S = Q.x, j > 0 && T.push(S + k / 2), P.push(C), this.renderSeries({
                                        realIndex: I,
                                        pathFill: it,
                                        j,
                                        i: d,
                                        pathFrom: Q.pathFrom,
                                        pathTo: Q.pathTo,
                                        strokeWidth: U,
                                        elSeries: R,
                                        x: S,
                                        y: C,
                                        series: t,
                                        barHeight: Q.barHeight ? Q.barHeight : p,
                                        barWidth: Q.barWidth ? Q.barWidth : k,
                                        elDataLabelsWrap: D,
                                        elGoalsMarkers: X,
                                        elBarShadows: H,
                                        visibleSeries: this.visibleI,
                                        type: "bar"
                                    })
                                }
                                i.globals.seriesXvalues[I] = T, i.globals.seriesYvalues[I] = P, h.add(R)
                            }
                            return h
                        }
                    }, {
                        key: "renderSeries",
                        value: function(t) {
                            var e = t.realIndex,
                                i = t.pathFill,
                                r = t.lineFill,
                                l = t.j,
                                h = t.i,
                                d = t.groupIndex,
                                g = t.pathFrom,
                                x = t.pathTo,
                                b = t.strokeWidth,
                                v = t.elSeries,
                                w = t.x,
                                S = t.y,
                                C = t.y1,
                                P = t.y2,
                                T = t.series,
                                I = t.barHeight,
                                R = t.barWidth,
                                p = t.barXPosition,
                                k = t.barYPosition,
                                M = t.elDataLabelsWrap,
                                D = t.elGoalsMarkers,
                                X = t.elBarShadows,
                                H = t.visibleSeries,
                                j = t.type,
                                U = this.w,
                                Q = new ot(this.ctx);
                            r || (r = this.barOptions.distributed ? U.globals.stroke.colors[l] : U.globals.stroke.colors[e]), U.config.series[h].data[l] && U.config.series[h].data[l].strokeColor && (r = U.config.series[h].data[l].strokeColor), this.isNullValue && (i = "none");
                            var it = Q.renderPaths({
                                i: h,
                                j: l,
                                realIndex: e,
                                pathFrom: g,
                                pathTo: x,
                                stroke: r,
                                strokeWidth: b,
                                strokeLineCap: U.config.stroke.lineCap,
                                fill: i,
                                animationDelay: l / U.config.chart.animations.animateGradually.delay * (U.config.chart.animations.speed / U.globals.dataPoints) / 2.4,
                                initialSpeed: U.config.chart.animations.speed,
                                dataChangeSpeed: U.config.chart.animations.dynamicAnimation.speed,
                                className: "apexcharts-".concat(j, "-area")
                            });
                            it.attr("clip-path", "url(#gridRectMask".concat(U.globals.cuid, ")"));
                            var mt = U.config.forecastDataPoints;
                            mt.count > 0 && l >= U.globals.dataPoints - mt.count && (it.node.setAttribute("stroke-dasharray", mt.dashArray), it.node.setAttribute("stroke-width", mt.strokeWidth), it.node.setAttribute("fill-opacity", mt.fillOpacity)), void 0 !== C && void 0 !== P && (it.attr("data-range-y1", C), it.attr("data-range-y2", P)), new ae(this.ctx).setSelectionFilter(it, e, l), v.add(it);
                            var yt = new Qe(this).handleBarDataLabels({
                                x: w,
                                y: S,
                                y1: C,
                                y2: P,
                                i: h,
                                j: l,
                                series: T,
                                realIndex: e,
                                groupIndex: d,
                                barHeight: I,
                                barWidth: R,
                                barXPosition: p,
                                barYPosition: k,
                                renderedPath: it,
                                visibleSeries: H
                            });
                            return null !== yt.dataLabels && M.add(yt.dataLabels), yt.totalDataLabels && M.add(yt.totalDataLabels), v.add(M), D && v.add(D), X && v.add(X), v
                        }
                    }, {
                        key: "drawBarPaths",
                        value: function(t) {
                            var e, d, i = t.indexes,
                                r = t.barHeight,
                                l = t.strokeWidth,
                                h = t.zeroW,
                                g = t.y,
                                x = t.yDivision,
                                b = t.elSeries,
                                v = this.w,
                                w = i.i,
                                S = i.j;
                            if (v.globals.isXNumeric) e = (g = (v.globals.seriesX[w][S] - v.globals.minX) / this.invertedXRatio - r) + r * this.visibleI;
                            else if (v.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                                var C = 0,
                                    P = 0;
                                v.globals.seriesPercent.forEach(function(I, R) {
                                    I[S] && C++, R < w && 0 === I[S] && P++
                                }), C > 0 && (r = this.seriesLen * r / C), e = g + r * this.visibleI, e -= r * P
                            } else e = g + r * this.visibleI;
                            this.isFunnel && (h -= (this.barHelpers.getXForValue(this.series[w][S], h) - h) / 2), d = this.barHelpers.getXForValue(this.series[w][S], h);
                            var T = this.barHelpers.getBarpaths({
                                barYPosition: e,
                                barHeight: r,
                                x1: h,
                                x2: d,
                                strokeWidth: l,
                                series: this.series,
                                realIndex: i.realIndex,
                                i: w,
                                j: S,
                                w: v
                            });
                            return v.globals.isXNumeric || (g += x), this.barHelpers.barBackground({
                                j: S,
                                i: w,
                                y1: e - r * this.visibleI,
                                y2: r * this.seriesLen,
                                elSeries: b
                            }), {
                                pathTo: T.pathTo,
                                pathFrom: T.pathFrom,
                                x1: h,
                                x: d,
                                y: g,
                                goalX: this.barHelpers.getGoalValues("x", h, null, w, S),
                                barYPosition: e,
                                barHeight: r
                            }
                        }
                    }, {
                        key: "drawColumnPaths",
                        value: function(t) {
                            var e, l, i = t.indexes,
                                r = t.x,
                                h = t.xDivision,
                                d = t.barWidth,
                                g = t.zeroH,
                                x = t.strokeWidth,
                                b = t.elSeries,
                                v = this.w,
                                w = i.realIndex,
                                S = i.i,
                                C = i.j,
                                P = i.bc;
                            if (v.globals.isXNumeric) {
                                var T = w;
                                v.globals.seriesX[w].length || (T = v.globals.maxValsInArrayIndex), v.globals.seriesX[T][C] && (r = (v.globals.seriesX[T][C] - v.globals.minX) / this.xRatio - d * this.seriesLen / 2), e = r + d * this.visibleI
                            } else if (v.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                                var I = this.barHelpers.getZeroValueEncounters({
                                        i: S,
                                        j: C
                                    }),
                                    R = I.nonZeroColumns;
                                R > 0 && (d = this.seriesLen * d / R), e = r + d * this.visibleI, e -= d * I.zeroEncounters
                            } else e = r + d * this.visibleI;
                            l = this.barHelpers.getYForValue(this.series[S][C], g);
                            var k = this.barHelpers.getColumnPaths({
                                barXPosition: e,
                                barWidth: d,
                                y1: g,
                                y2: l,
                                strokeWidth: x,
                                series: this.series,
                                realIndex: i.realIndex,
                                i: S,
                                j: C,
                                w: v
                            });
                            return v.globals.isXNumeric || (r += h), this.barHelpers.barBackground({
                                bc: P,
                                j: C,
                                i: S,
                                x1: e - x / 2 - d * this.visibleI,
                                x2: d * this.seriesLen + x / 2,
                                elSeries: b
                            }), {
                                pathTo: k.pathTo,
                                pathFrom: k.pathFrom,
                                x: r,
                                y: l,
                                goalY: this.barHelpers.getGoalValues("y", null, g, S, C),
                                barXPosition: e,
                                barWidth: d
                            }
                        }
                    }, {
                        key: "getPreviousPath",
                        value: function(t, e) {
                            for (var i, r = this.w, l = 0; l < r.globals.previousPaths.length; l++) {
                                var h = r.globals.previousPaths[l];
                                h.paths && h.paths.length > 0 && parseInt(h.realIndex, 10) === parseInt(t, 10) && void 0 !== r.globals.previousPaths[l].paths[e] && (i = r.globals.previousPaths[l].paths[e].d)
                            }
                            return i
                        }
                    }]), _
                }(),
                Gi = function(_) {
                    Rt(e, Ne);
                    var t = Me(e);

                    function e() {
                        return xt(this, e), t.apply(this, arguments)
                    }
                    return ht(e, [{
                        key: "draw",
                        value: function(i, r) {
                            var l = this,
                                h = this.w;
                            this.graphics = new ot(this.ctx), this.bar = new Ne(this.ctx, this.xyRatios);
                            var d = new te(this.ctx, h);
                            i = d.getLogSeries(i), this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), "100%" === h.config.chart.stackType && (i = h.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
                            for (var g = this.graphics.group({
                                    class: "apexcharts-bar-series apexcharts-plot-series"
                                }), x = 0, b = 0, v = function(C, P) {
                                    var T = void 0,
                                        I = void 0,
                                        R = void 0,
                                        p = void 0,
                                        k = -1;
                                    l.groupCtx = l, h.globals.seriesGroups.forEach(function(ie, Kt) {
                                        ie.indexOf(h.config.series[C].name) > -1 && (k = Kt)
                                    }), -1 !== k && (l.groupCtx = l[h.globals.seriesGroups[k]]);
                                    var M = [],
                                        D = [],
                                        X = h.globals.comboCharts ? r[C] : C;
                                    l.yRatio.length > 1 && (l.yaxisIndex = X), l.isReversed = h.config.yaxis[l.yaxisIndex] && h.config.yaxis[l.yaxisIndex].reversed;
                                    var H = l.graphics.group({
                                        class: "apexcharts-series",
                                        seriesName: q.escapeString(h.globals.seriesNames[X]),
                                        rel: C + 1,
                                        "data:realIndex": X
                                    });
                                    l.ctx.series.addCollapsedClassToSeries(H, X);
                                    var j = l.graphics.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": X
                                        }),
                                        U = l.graphics.group({
                                            class: "apexcharts-bar-goals-markers"
                                        }),
                                        Q = 0,
                                        at = 0,
                                        it = l.initialPositions(x, b, T, I, R, p);
                                    b = it.y, Q = it.barHeight, I = it.yDivision, p = it.zeroW, x = it.x, at = it.barWidth, T = it.xDivision, R = it.zeroH, l.barHelpers.initializeStackedXYVars(l), 1 === l.groupCtx.prevY.length && l.groupCtx.prevY[0].every(function(ie) {
                                        return isNaN(ie)
                                    }) && (l.groupCtx.prevY[0] = l.groupCtx.prevY[0].map(function(ie) {
                                        return R
                                    }), l.groupCtx.prevYF[0] = l.groupCtx.prevYF[0].map(function(ie) {
                                        return 0
                                    }));
                                    for (var mt = 0; mt < h.globals.dataPoints; mt++) {
                                        var yt = l.barHelpers.getStrokeWidth(C, mt, X),
                                            Pt = {
                                                indexes: {
                                                    i: C,
                                                    j: mt,
                                                    realIndex: X,
                                                    bc: P
                                                },
                                                strokeWidth: yt,
                                                x,
                                                y: b,
                                                elSeries: H,
                                                groupIndex: k,
                                                seriesGroup: h.globals.seriesGroups[k]
                                            },
                                            Dt = null;
                                        l.isHorizontal ? (Dt = l.drawStackedBarPaths(ut(ut({}, Pt), {}, {
                                            zeroW: p,
                                            barHeight: Q,
                                            yDivision: I
                                        })), at = l.series[C][mt] / l.invertedYRatio) : (Dt = l.drawStackedColumnPaths(ut(ut({}, Pt), {}, {
                                            xDivision: T,
                                            barWidth: at,
                                            zeroH: R
                                        })), Q = l.series[C][mt] / l.yRatio[l.yaxisIndex]);
                                        var Vt = l.barHelpers.drawGoalLine({
                                            barXPosition: Dt.barXPosition,
                                            barYPosition: Dt.barYPosition,
                                            goalX: Dt.goalX,
                                            goalY: Dt.goalY,
                                            barHeight: Q,
                                            barWidth: at
                                        });
                                        Vt && U.add(Vt), b = Dt.y, M.push(x = Dt.x), D.push(b);
                                        var ee = l.barHelpers.getPathFillColor(i, C, mt, X);
                                        H = l.renderSeries({
                                            realIndex: X,
                                            pathFill: ee,
                                            j: mt,
                                            i: C,
                                            groupIndex: k,
                                            pathFrom: Dt.pathFrom,
                                            pathTo: Dt.pathTo,
                                            strokeWidth: yt,
                                            elSeries: H,
                                            x,
                                            y: b,
                                            series: i,
                                            barHeight: Q,
                                            barWidth: at,
                                            elDataLabelsWrap: j,
                                            elGoalsMarkers: U,
                                            type: "bar",
                                            visibleSeries: 0
                                        })
                                    }
                                    h.globals.seriesXvalues[X] = M, h.globals.seriesYvalues[X] = D, l.groupCtx.prevY.push(l.groupCtx.yArrj), l.groupCtx.prevYF.push(l.groupCtx.yArrjF), l.groupCtx.prevYVal.push(l.groupCtx.yArrjVal), l.groupCtx.prevX.push(l.groupCtx.xArrj), l.groupCtx.prevXF.push(l.groupCtx.xArrjF), l.groupCtx.prevXVal.push(l.groupCtx.xArrjVal), g.add(H)
                                }, w = 0, S = 0; w < i.length; w++, S++) v(w, S);
                            return g
                        }
                    }, {
                        key: "initialPositions",
                        value: function(i, r, l, h, d, g) {
                            var x, b, v, w, S = this.w;
                            return this.isHorizontal ? (v = (v = h = S.globals.gridHeight / S.globals.dataPoints) * parseInt(S.config.plotOptions.bar.barHeight, 10) / 100, -1 === String(S.config.plotOptions.bar.barHeight).indexOf("%") && (v = parseInt(S.config.plotOptions.bar.barHeight, 10)), g = this.baseLineInvertedY + S.globals.padHorizontal + (this.isReversed ? S.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), r = (h - v) / 2) : (w = l = S.globals.gridWidth / S.globals.dataPoints, w = S.globals.isXNumeric && S.globals.dataPoints > 1 ? (l = S.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : w * parseInt(S.config.plotOptions.bar.columnWidth, 10) / 100, -1 === String(S.config.plotOptions.bar.columnWidth).indexOf("%") && (w = parseInt(S.config.plotOptions.bar.columnWidth, 10)), d = S.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? S.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), i = S.globals.padHorizontal + (l - w) / 2), {
                                x: i,
                                y: r,
                                yDivision: h,
                                xDivision: l,
                                barHeight: null !== (x = S.globals.seriesGroups) && void 0 !== x && x.length ? v / S.globals.seriesGroups.length : v,
                                barWidth: null !== (b = S.globals.seriesGroups) && void 0 !== b && b.length ? w / S.globals.seriesGroups.length : w,
                                zeroH: d,
                                zeroW: g
                            }
                        }
                    }, {
                        key: "drawStackedBarPaths",
                        value: function(i) {
                            for (var r, x, l = i.indexes, h = i.barHeight, d = i.strokeWidth, g = i.zeroW, b = i.y, v = i.groupIndex, w = i.seriesGroup, S = i.yDivision, C = i.elSeries, P = this.w, T = b + (-1 !== v ? v * h : 0), I = l.i, R = l.j, p = 0, k = 0; k < this.groupCtx.prevXF.length; k++) p += this.groupCtx.prevXF[k][R];
                            var M = I;
                            if (w && (M = w.indexOf(P.config.series[I].name)), M > 0) {
                                var D = g;
                                this.groupCtx.prevXVal[M - 1][R] < 0 ? D = this.series[I][R] >= 0 ? this.groupCtx.prevX[M - 1][R] + p - 2 * (this.isReversed ? p : 0) : this.groupCtx.prevX[M - 1][R] : this.groupCtx.prevXVal[M - 1][R] >= 0 && (D = this.series[I][R] >= 0 ? this.groupCtx.prevX[M - 1][R] : this.groupCtx.prevX[M - 1][R] - p + 2 * (this.isReversed ? p : 0)), r = D
                            } else r = g;
                            var X = this.barHelpers.getBarpaths({
                                barYPosition: T,
                                barHeight: h,
                                x1: r,
                                x2: x = null === this.series[I][R] ? r : r + this.series[I][R] / this.invertedYRatio - 2 * (this.isReversed ? this.series[I][R] / this.invertedYRatio : 0),
                                strokeWidth: d,
                                series: this.series,
                                realIndex: l.realIndex,
                                seriesGroup: w,
                                i: I,
                                j: R,
                                w: P
                            });
                            return this.barHelpers.barBackground({
                                j: R,
                                i: I,
                                y1: T,
                                y2: h,
                                elSeries: C
                            }), b += S, {
                                pathTo: X.pathTo,
                                pathFrom: X.pathFrom,
                                goalX: this.barHelpers.getGoalValues("x", g, null, I, R),
                                barYPosition: T,
                                x,
                                y: b
                            }
                        }
                    }, {
                        key: "drawStackedColumnPaths",
                        value: function(i) {
                            var h, r = i.indexes,
                                l = i.x,
                                d = i.xDivision,
                                g = i.barWidth,
                                x = i.zeroH,
                                b = i.groupIndex,
                                v = i.seriesGroup,
                                w = i.elSeries,
                                S = this.w,
                                C = r.i,
                                P = r.j,
                                T = r.bc;
                            if (S.globals.isXNumeric) {
                                var I = S.globals.seriesX[C][P];
                                I || (I = 0), l = (I - S.globals.minX) / this.xRatio - g / 2, S.globals.seriesGroups.length && (l = (I - S.globals.minX) / this.xRatio - g / 2 * S.globals.seriesGroups.length)
                            }
                            for (var R, p = l + (-1 !== b ? b * g : 0), k = 0, M = 0; M < this.groupCtx.prevYF.length; M++) k += isNaN(this.groupCtx.prevYF[M][P]) ? 0 : this.groupCtx.prevYF[M][P];
                            var D = C;
                            if (v && (D = v.indexOf(S.config.series[C].name)), D > 0 && !S.globals.isXNumeric || D > 0 && S.globals.isXNumeric && S.globals.seriesX[C - 1][P] === S.globals.seriesX[C][P]) {
                                var X, H, j, U = Math.min(this.yRatio.length + 1, C + 1);
                                if (void 0 !== this.groupCtx.prevY[D - 1] && this.groupCtx.prevY[D - 1].length)
                                    for (var Q = 1; Q < U; Q++) {
                                        var at;
                                        if (!isNaN(null === (at = this.groupCtx.prevY[D - Q]) || void 0 === at ? void 0 : at[P])) {
                                            j = this.groupCtx.prevY[D - Q][P];
                                            break
                                        }
                                    }
                                for (var it = 1; it < U; it++) {
                                    var mt, yt;
                                    if ((null === (mt = this.groupCtx.prevYVal[D - it]) || void 0 === mt ? void 0 : mt[P]) < 0) {
                                        H = this.series[C][P] >= 0 ? j - k + 2 * (this.isReversed ? k : 0) : j;
                                        break
                                    }
                                    if ((null === (yt = this.groupCtx.prevYVal[D - it]) || void 0 === yt ? void 0 : yt[P]) >= 0) {
                                        H = this.series[C][P] >= 0 ? j : j + k - 2 * (this.isReversed ? k : 0);
                                        break
                                    }
                                }
                                void 0 === H && (H = S.globals.gridHeight), R = null !== (X = this.groupCtx.prevYF[0]) && void 0 !== X && X.every(function(Dt) {
                                    return 0 === Dt
                                }) && this.groupCtx.prevYF.slice(1, D).every(function(Dt) {
                                    return Dt.every(function(Vt) {
                                        return isNaN(Vt)
                                    })
                                }) ? x : H
                            } else R = x;
                            var Pt = this.barHelpers.getColumnPaths({
                                barXPosition: p,
                                barWidth: g,
                                y1: R,
                                y2: h = this.series[C][P] ? R - this.series[C][P] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[C][P] / this.yRatio[this.yaxisIndex] : 0) : R,
                                yRatio: this.yRatio[this.yaxisIndex],
                                strokeWidth: this.strokeWidth,
                                series: this.series,
                                seriesGroup: v,
                                realIndex: r.realIndex,
                                i: C,
                                j: P,
                                w: S
                            });
                            return this.barHelpers.barBackground({
                                bc: T,
                                j: P,
                                i: C,
                                x1: p,
                                x2: g,
                                elSeries: w
                            }), l += d, {
                                pathTo: Pt.pathTo,
                                pathFrom: Pt.pathFrom,
                                goalY: this.barHelpers.getGoalValues("y", null, x, C, P),
                                barXPosition: p,
                                x: S.globals.isXNumeric ? l - d : l,
                                y: h
                            }
                        }
                    }]), e
                }(),
                jt = function(_) {
                    Rt(e, Ne);
                    var t = Me(e);

                    function e() {
                        return xt(this, e), t.apply(this, arguments)
                    }
                    return ht(e, [{
                        key: "draw",
                        value: function(i, r, l) {
                            var h = this,
                                d = this.w,
                                g = new ot(this.ctx),
                                x = d.globals.comboCharts ? r : d.config.chart.type,
                                b = new ce(this.ctx);
                            this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = d.config.plotOptions.bar.horizontal;
                            var v = new te(this.ctx, d);
                            i = v.getLogSeries(i), this.series = i, this.yRatio = v.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
                            for (var w = g.group({
                                    class: "apexcharts-".concat(x, "-series apexcharts-plot-series")
                                }), S = function(P) {
                                    h.isBoxPlot = "boxPlot" === d.config.chart.type || "boxPlot" === d.config.series[P].type;
                                    var T, I, R, p, U, Q, k = void 0,
                                        M = void 0,
                                        D = [],
                                        X = [],
                                        H = d.globals.comboCharts ? l[P] : P,
                                        j = g.group({
                                            class: "apexcharts-series",
                                            seriesName: q.escapeString(d.globals.seriesNames[H]),
                                            rel: P + 1,
                                            "data:realIndex": H
                                        });
                                    h.ctx.series.addCollapsedClassToSeries(j, H), i[P].length > 0 && (h.visibleI = h.visibleI + 1), h.yRatio.length > 1 && (h.yaxisIndex = H);
                                    var at = h.barHelpers.initialPositions();
                                    M = at.y, U = at.barHeight, I = at.yDivision, p = at.zeroW, T = at.xDivision, R = at.zeroH, X.push((k = at.x) + (Q = at.barWidth) / 2);
                                    for (var it = g.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": H
                                        }), mt = function(Pt) {
                                            var Dt = h.barHelpers.getStrokeWidth(P, Pt, H),
                                                Vt = null,
                                                ee = {
                                                    indexes: {
                                                        i: P,
                                                        j: Pt,
                                                        realIndex: H
                                                    },
                                                    x: k,
                                                    y: M,
                                                    strokeWidth: Dt,
                                                    elSeries: j
                                                };
                                            Vt = h.isHorizontal ? h.drawHorizontalBoxPaths(ut(ut({}, ee), {}, {
                                                yDivision: I,
                                                barHeight: U,
                                                zeroW: p
                                            })) : h.drawVerticalBoxPaths(ut(ut({}, ee), {}, {
                                                xDivision: T,
                                                barWidth: Q,
                                                zeroH: R
                                            })), M = Vt.y, k = Vt.x, Pt > 0 && X.push(k + Q / 2), D.push(M), Vt.pathTo.forEach(function(ie, Kt) {
                                                var Ce = !h.isBoxPlot && h.candlestickOptions.wick.useFillColor ? Vt.color[Kt] : d.globals.stroke.colors[P],
                                                    De = b.fillPath({
                                                        seriesNumber: H,
                                                        dataPointIndex: Pt,
                                                        color: Vt.color[Kt],
                                                        value: i[P][Pt]
                                                    });
                                                h.renderSeries({
                                                    realIndex: H,
                                                    pathFill: De,
                                                    lineFill: Ce,
                                                    j: Pt,
                                                    i: P,
                                                    pathFrom: Vt.pathFrom,
                                                    pathTo: ie,
                                                    strokeWidth: Dt,
                                                    elSeries: j,
                                                    x: k,
                                                    y: M,
                                                    series: i,
                                                    barHeight: U,
                                                    barWidth: Q,
                                                    elDataLabelsWrap: it,
                                                    visibleSeries: h.visibleI,
                                                    type: d.config.chart.type
                                                })
                                            })
                                        }, yt = 0; yt < d.globals.dataPoints; yt++) mt(yt);
                                    d.globals.seriesXvalues[H] = X, d.globals.seriesYvalues[H] = D, w.add(j)
                                }, C = 0; C < i.length; C++) S(C);
                            return w
                        }
                    }, {
                        key: "drawVerticalBoxPaths",
                        value: function(i) {
                            var r = i.indexes,
                                l = i.x,
                                h = i.xDivision,
                                d = i.barWidth,
                                g = i.zeroH,
                                x = i.strokeWidth,
                                b = this.w,
                                v = new ot(this.ctx),
                                w = r.i,
                                S = r.j,
                                C = !0,
                                P = b.config.plotOptions.candlestick.colors.upward,
                                T = b.config.plotOptions.candlestick.colors.downward,
                                I = "";
                            this.isBoxPlot && (I = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                            var R = this.yRatio[this.yaxisIndex],
                                p = r.realIndex,
                                k = this.getOHLCValue(p, S),
                                M = g,
                                D = g;
                            k.o > k.c && (C = !1);
                            var X = Math.min(k.o, k.c),
                                H = Math.max(k.o, k.c),
                                j = k.m;
                            b.globals.isXNumeric && (l = (b.globals.seriesX[p][S] - b.globals.minX) / this.xRatio - d / 2);
                            var U = l + d * this.visibleI;
                            null == this.series[w][S] ? (X = g, H = g) : (X = g - X / R, H = g - H / R, M = g - k.h / R, D = g - k.l / R, j = g - k.m / R);
                            var Q = v.move(U, g),
                                at = v.move(U + d / 2, X);
                            return b.globals.previousPaths.length > 0 && (at = this.getPreviousPath(p, S, !0)), Q = this.isBoxPlot ? [v.move(U, X) + v.line(U + d / 2, X) + v.line(U + d / 2, M) + v.line(U + d / 4, M) + v.line(U + d - d / 4, M) + v.line(U + d / 2, M) + v.line(U + d / 2, X) + v.line(U + d, X) + v.line(U + d, j) + v.line(U, j) + v.line(U, X + x / 2), v.move(U, j) + v.line(U + d, j) + v.line(U + d, H) + v.line(U + d / 2, H) + v.line(U + d / 2, D) + v.line(U + d - d / 4, D) + v.line(U + d / 4, D) + v.line(U + d / 2, D) + v.line(U + d / 2, H) + v.line(U, H) + v.line(U, j) + "z"] : [v.move(U, H) + v.line(U + d / 2, H) + v.line(U + d / 2, M) + v.line(U + d / 2, H) + v.line(U + d, H) + v.line(U + d, X) + v.line(U + d / 2, X) + v.line(U + d / 2, D) + v.line(U + d / 2, X) + v.line(U, X) + v.line(U, H - x / 2)], at += v.move(U, X), b.globals.isXNumeric || (l += h), {
                                pathTo: Q,
                                pathFrom: at,
                                x: l,
                                y: H,
                                barXPosition: U,
                                color: this.isBoxPlot ? I : C ? [P] : [T]
                            }
                        }
                    }, {
                        key: "drawHorizontalBoxPaths",
                        value: function(i) {
                            var r = i.indexes,
                                l = i.y,
                                h = i.yDivision,
                                d = i.barHeight,
                                g = i.zeroW,
                                x = i.strokeWidth,
                                b = this.w,
                                v = new ot(this.ctx),
                                w = r.i,
                                S = r.j,
                                C = this.boxOptions.colors.lower;
                            this.isBoxPlot && (C = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                            var P = this.invertedYRatio,
                                T = r.realIndex,
                                I = this.getOHLCValue(T, S),
                                R = g,
                                p = g,
                                k = Math.min(I.o, I.c),
                                M = Math.max(I.o, I.c),
                                D = I.m;
                            b.globals.isXNumeric && (l = (b.globals.seriesX[T][S] - b.globals.minX) / this.invertedXRatio - d / 2);
                            var X = l + d * this.visibleI;
                            null == this.series[w][S] ? (k = g, M = g) : (k = g + k / P, M = g + M / P, R = g + I.h / P, p = g + I.l / P, D = g + I.m / P);
                            var H = v.move(g, X),
                                j = v.move(k, X + d / 2);
                            return b.globals.previousPaths.length > 0 && (j = this.getPreviousPath(T, S, !0)), H = [v.move(k, X) + v.line(k, X + d / 2) + v.line(R, X + d / 2) + v.line(R, X + d / 2 - d / 4) + v.line(R, X + d / 2 + d / 4) + v.line(R, X + d / 2) + v.line(k, X + d / 2) + v.line(k, X + d) + v.line(D, X + d) + v.line(D, X) + v.line(k + x / 2, X), v.move(D, X) + v.line(D, X + d) + v.line(M, X + d) + v.line(M, X + d / 2) + v.line(p, X + d / 2) + v.line(p, X + d - d / 4) + v.line(p, X + d / 4) + v.line(p, X + d / 2) + v.line(M, X + d / 2) + v.line(M, X) + v.line(D, X) + "z"], j += v.move(k, X), b.globals.isXNumeric || (l += h), {
                                pathTo: H,
                                pathFrom: j,
                                x: M,
                                y: l,
                                barYPosition: X,
                                color: C
                            }
                        }
                    }, {
                        key: "getOHLCValue",
                        value: function(i, r) {
                            var l = this.w;
                            return {
                                o: this.isBoxPlot ? l.globals.seriesCandleH[i][r] : l.globals.seriesCandleO[i][r],
                                h: this.isBoxPlot ? l.globals.seriesCandleO[i][r] : l.globals.seriesCandleH[i][r],
                                m: l.globals.seriesCandleM[i][r],
                                l: this.isBoxPlot ? l.globals.seriesCandleC[i][r] : l.globals.seriesCandleL[i][r],
                                c: this.isBoxPlot ? l.globals.seriesCandleL[i][r] : l.globals.seriesCandleC[i][r]
                            }
                        }
                    }]), e
                }(),
                W = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "checkColorRange",
                        value: function() {
                            var t = this.w,
                                e = !1,
                                i = t.config.plotOptions[t.config.chart.type];
                            return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(r, l) {
                                r.from <= 0 && (e = !0)
                            }), e
                        }
                    }, {
                        key: "getShadeColor",
                        value: function(t, e, i, r) {
                            var l = this.w,
                                h = 1,
                                d = l.config.plotOptions[t].shadeIntensity,
                                g = this.determineColor(t, e, i);
                            l.globals.hasNegs || r ? h = l.config.plotOptions[t].reverseNegativeShade ? g.percent < 0 ? g.percent / 100 * (1.25 * d) : 1.25 * d * (1 - g.percent / 100) : g.percent <= 0 ? 1 - (1 + g.percent / 100) * d : (1 - g.percent / 100) * d : (h = 1 - g.percent / 100, "treemap" === t && (h = 1.25 * d * (1 - g.percent / 100)));
                            var x = g.color,
                                b = new q;
                            return l.config.plotOptions[t].enableShades && (x = q.hexToRgba(b.shadeColor("dark" === this.w.config.theme.mode ? -1 * h : h, g.color), l.config.fill.opacity)), {
                                color: x,
                                colorProps: g
                            }
                        }
                    }, {
                        key: "determineColor",
                        value: function(t, e, i) {
                            var r = this.w,
                                l = r.globals.series[e][i],
                                h = r.config.plotOptions[t],
                                d = h.colorScale.inverse ? i : e;
                            h.distributed && "treemap" === r.config.chart.type && (d = i);
                            var g = r.globals.colors[d],
                                x = null,
                                b = Math.min.apply(Math, le(r.globals.series[e])),
                                v = Math.max.apply(Math, le(r.globals.series[e]));
                            h.distributed || "heatmap" !== t || (b = r.globals.minY, v = r.globals.maxY), void 0 !== h.colorScale.min && (b = h.colorScale.min < r.globals.minY ? h.colorScale.min : r.globals.minY, v = h.colorScale.max > r.globals.maxY ? h.colorScale.max : r.globals.maxY);
                            var w = Math.abs(v) + Math.abs(b),
                                S = 100 * l / (0 === w ? w - 1e-6 : w);
                            return h.colorScale.ranges.length > 0 && h.colorScale.ranges.map(function(C, P) {
                                if (l >= C.from && l <= C.to) {
                                    g = C.color, x = C.foreColor ? C.foreColor : null, b = C.from, v = C.to;
                                    var T = Math.abs(v) + Math.abs(b);
                                    S = 100 * l / (0 === T ? T - 1e-6 : T)
                                }
                            }), {
                                color: g,
                                foreColor: x,
                                percent: S
                            }
                        }
                    }, {
                        key: "calculateDataLabels",
                        value: function(t) {
                            var e = t.text,
                                i = t.x,
                                r = t.y,
                                l = t.i,
                                h = t.j,
                                d = t.colorProps,
                                g = t.fontSize,
                                x = this.w.config.dataLabels,
                                b = new ot(this.ctx),
                                v = new ve(this.ctx),
                                w = null;
                            if (x.enabled) {
                                w = b.group({
                                    class: "apexcharts-data-labels"
                                });
                                var C = x.offsetY,
                                    P = i + x.offsetX,
                                    T = r + parseFloat(x.style.fontSize) / 3 + C;
                                v.plotDataLabelsText({
                                    x: P,
                                    y: T,
                                    text: e,
                                    i: l,
                                    j: h,
                                    color: d.foreColor,
                                    parent: w,
                                    fontSize: g,
                                    dataLabelsConfig: x
                                })
                            }
                            return w
                        }
                    }, {
                        key: "addListeners",
                        value: function(t) {
                            var e = new ot(this.ctx);
                            t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t))
                        }
                    }]), _
                }(),
                E = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.xRatio = e.xRatio, this.yRatio = e.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new W(t), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t) {
                            var e = this.w,
                                i = new ot(this.ctx),
                                r = i.group({
                                    class: "apexcharts-heatmap"
                                });
                            r.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
                            var l = e.globals.gridWidth / e.globals.dataPoints,
                                h = e.globals.gridHeight / e.globals.series.length,
                                d = 0,
                                g = !1;
                            this.negRange = this.helpers.checkColorRange();
                            var x = t.slice();
                            e.config.yaxis[0].reversed && (g = !0, x.reverse());
                            for (var b = g ? 0 : x.length - 1; g ? b < x.length : b >= 0; g ? b++ : b--) {
                                var v = i.group({
                                    class: "apexcharts-series apexcharts-heatmap-series",
                                    seriesName: q.escapeString(e.globals.seriesNames[b]),
                                    rel: b + 1,
                                    "data:realIndex": b
                                });
                                if (this.ctx.series.addCollapsedClassToSeries(v, b), e.config.chart.dropShadow.enabled) {
                                    var w = e.config.chart.dropShadow;
                                    new ae(this.ctx).dropShadow(v, w, b)
                                }
                                for (var S = 0, C = e.config.plotOptions.heatmap.shadeIntensity, P = 0; P < x[b].length; P++) {
                                    var T = this.helpers.getShadeColor(e.config.chart.type, b, P, this.negRange),
                                        I = T.color,
                                        R = T.colorProps;
                                    "image" === e.config.fill.type && (I = new ce(this.ctx).fillPath({
                                        seriesNumber: b,
                                        dataPointIndex: P,
                                        opacity: e.globals.hasNegs ? R.percent < 0 ? 1 - (1 + R.percent / 100) : C + R.percent / 100 : R.percent / 100,
                                        patternID: q.randomId(),
                                        width: e.config.fill.image.width ? e.config.fill.image.width : l,
                                        height: e.config.fill.image.height ? e.config.fill.image.height : h
                                    }));
                                    var k = i.drawRect(S, d, l, h, this.rectRadius);
                                    if (k.attr({
                                            cx: S,
                                            cy: d
                                        }), k.node.classList.add("apexcharts-heatmap-rect"), v.add(k), k.attr({
                                            fill: I,
                                            i: b,
                                            index: b,
                                            j: P,
                                            val: x[b][P],
                                            "stroke-width": this.strokeWidth,
                                            stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? I : e.globals.stroke.colors[0],
                                            color: I
                                        }), this.helpers.addListeners(k), e.config.chart.animations.enabled && !e.globals.dataChanged) {
                                        var M = 1;
                                        e.globals.resized || (M = e.config.chart.animations.speed), this.animateHeatMap(k, S, d, l, h, M)
                                    }
                                    if (e.globals.dataChanged) {
                                        var D = 1;
                                        if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                                            D = this.dynamicAnim.speed;
                                            var X = e.globals.previousPaths[b] && e.globals.previousPaths[b][P] && e.globals.previousPaths[b][P].color;
                                            X || (X = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k, q.isColorHex(X) ? X : q.rgb2hex(X), q.isColorHex(I) ? I : q.rgb2hex(I), D)
                                        }
                                    }
                                    var H = (0, e.config.dataLabels.formatter)(e.globals.series[b][P], {
                                            value: e.globals.series[b][P],
                                            seriesIndex: b,
                                            dataPointIndex: P,
                                            w: e
                                        }),
                                        j = this.helpers.calculateDataLabels({
                                            text: H,
                                            x: S + l / 2,
                                            y: d + h / 2,
                                            i: b,
                                            j: P,
                                            colorProps: R,
                                            series: x
                                        });
                                    null !== j && v.add(j), S += l
                                }
                                d += h, r.add(v)
                            }
                            var U = e.globals.yAxisScale[0].result.slice();
                            return e.config.yaxis[0].reversed ? U.unshift("") : U.push(""), e.globals.yAxisScale[0].result = U, r
                        }
                    }, {
                        key: "animateHeatMap",
                        value: function(t, e, i, r, l, h) {
                            var d = new Bt(this.ctx);
                            d.animateRect(t, {
                                x: e + r / 2,
                                y: i + l / 2,
                                width: 0,
                                height: 0
                            }, {
                                x: e,
                                y: i,
                                width: r,
                                height: l
                            }, h, function() {
                                d.animationCompleted(t)
                            })
                        }
                    }, {
                        key: "animateHeatColor",
                        value: function(t, e, i, r) {
                            t.attr({
                                fill: e
                            }).animate(r).attr({
                                fill: i
                            })
                        }
                    }]), _
                }(),
                N = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "drawYAxisTexts",
                        value: function(t, e, i, r) {
                            var l = this.w,
                                h = l.config.yaxis[0],
                                d = l.globals.yLabelFormatters[0];
                            return new ot(this.ctx).drawText({
                                x: t + h.labels.offsetX,
                                y: e + h.labels.offsetY,
                                text: d(r, i),
                                textAnchor: "middle",
                                fontSize: h.labels.style.fontSize,
                                fontFamily: h.labels.style.fontFamily,
                                foreColor: Array.isArray(h.labels.style.colors) ? h.labels.style.colors[i] : h.labels.style.colors
                            })
                        }
                    }]), _
                }(),
                F = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w;
                        var e = this.w;
                        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== e.globals.stroke.colors ? e.globals.stroke.colors : e.globals.colors, this.defaultSize = Math.min(e.globals.gridWidth, e.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = e.globals.gridWidth / 2, this.fullAngle = "radialBar" === e.config.chart.type ? 360 : Math.abs(e.config.plotOptions.pie.endAngle - e.config.plotOptions.pie.startAngle), this.initialAngle = e.config.plotOptions.pie.startAngle % this.fullAngle, e.globals.radialSize = this.defaultSize / 2.05 - e.config.stroke.width - (e.config.chart.sparkline.enabled ? 0 : e.config.chart.dropShadow.blur), this.donutSize = e.globals.radialSize * parseInt(e.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = new ot(this.ctx);
                            if (this.ret = r.group({
                                    class: "apexcharts-pie"
                                }), i.globals.noData) return this.ret;
                            for (var l = 0, h = 0; h < t.length; h++) l += q.negToZero(t[h]);
                            var d = [],
                                g = r.group();
                            0 === l && (l = 1e-5), t.forEach(function(X) {
                                e.maxY = Math.max(e.maxY, X)
                            }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                            for (var x = 0; x < t.length; x++) {
                                var b = this.fullAngle * q.negToZero(t[x]) / l;
                                d.push(b), "polarArea" === this.chartType ? (d[x] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[x] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                            }
                            if (i.globals.dataChanged) {
                                for (var v, w = 0, S = 0; S < i.globals.previousPaths.length; S++) w += q.negToZero(i.globals.previousPaths[S]);
                                for (var C = 0; C < i.globals.previousPaths.length; C++) v = this.fullAngle * q.negToZero(i.globals.previousPaths[C]) / w, this.prevSectorAngleArr.push(v)
                            }
                            this.donutSize < 0 && (this.donutSize = 0);
                            var P = i.config.plotOptions.pie.customScale,
                                R = i.globals.gridWidth / 2 - i.globals.gridWidth / 2 * P,
                                p = i.globals.gridHeight / 2 - i.globals.gridHeight / 2 * P;
                            if ("donut" === this.chartType) {
                                var k = r.drawCircle(this.donutSize);
                                k.attr({
                                    cx: this.centerX,
                                    cy: this.centerY,
                                    fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
                                }), g.add(k)
                            }
                            var M = this.drawArcs(d, t);
                            if (this.sliceLabels.forEach(function(X) {
                                    M.add(X)
                                }), g.attr({
                                    transform: "translate(".concat(R, ", ").concat(p, ") scale(").concat(P, ")")
                                }), g.add(M), this.ret.add(g), this.donutDataLabels.show) {
                                var D = this.renderInnerDataLabels(this.donutDataLabels, {
                                    hollowSize: this.donutSize,
                                    centerX: this.centerX,
                                    centerY: this.centerY,
                                    opacity: this.donutDataLabels.show,
                                    translateX: R,
                                    translateY: p
                                });
                                this.ret.add(D)
                            }
                            return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret
                        }
                    }, {
                        key: "drawArcs",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ae(this.ctx),
                                l = new ot(this.ctx),
                                h = new ce(this.ctx),
                                d = l.group({
                                    class: "apexcharts-slices"
                                }),
                                g = this.initialAngle,
                                x = this.initialAngle,
                                b = this.initialAngle,
                                v = this.initialAngle;
                            this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                            for (var w = 0; w < t.length; w++) {
                                var S = l.group({
                                    class: "apexcharts-series apexcharts-pie-series",
                                    seriesName: q.escapeString(i.globals.seriesNames[w]),
                                    rel: w + 1,
                                    "data:realIndex": w
                                });
                                d.add(S), b = (g = b) + t[w], v = (x = v) + this.prevSectorAngleArr[w];
                                var C = b < g ? this.fullAngle + b - g : b - g,
                                    P = h.fillPath({
                                        seriesNumber: w,
                                        size: this.sliceSizes[w],
                                        value: e[w]
                                    }),
                                    T = this.getChangedPath(x, v),
                                    I = l.drawPath({
                                        d: T,
                                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[w] : this.lineColorArr,
                                        strokeWidth: 0,
                                        fill: P,
                                        fillOpacity: i.config.fill.opacity,
                                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(w)
                                    });
                                I.attr({
                                    index: 0,
                                    j: w
                                }), r.setSelectionFilter(I, 0, w), i.config.chart.dropShadow.enabled && r.dropShadow(I, i.config.chart.dropShadow, w), this.addListeners(I, this.donutDataLabels), ot.setAttrs(I.node, {
                                    "data:angle": C,
                                    "data:startAngle": g,
                                    "data:strokeWidth": this.strokeWidth,
                                    "data:value": e[w]
                                });
                                var p = {
                                    x: 0,
                                    y: 0
                                };
                                "pie" === this.chartType || "polarArea" === this.chartType ? p = q.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (g + C / 2) % this.fullAngle) : "donut" === this.chartType && (p = q.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (g + C / 2) % this.fullAngle)), S.add(I);
                                var k = 0;
                                if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (k = C / this.fullAngle * i.config.chart.animations.speed) && (k = 1), this.animDur = k + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(I, this.dynamicAnim && i.globals.dataChanged ? {
                                        size: this.sliceSizes[w],
                                        endAngle: b,
                                        startAngle: g,
                                        prevStartAngle: x,
                                        prevEndAngle: v,
                                        animateStartingPos: !0,
                                        i: w,
                                        animBeginArr: this.animBeginArr,
                                        shouldSetPrevPaths: !0,
                                        dur: i.config.chart.animations.dynamicAnimation.speed
                                    } : {
                                        size: this.sliceSizes[w],
                                        endAngle: b,
                                        startAngle: g,
                                        i: w,
                                        totalItems: t.length - 1,
                                        animBeginArr: this.animBeginArr,
                                        dur: k
                                    }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && I.click(this.pieClicked.bind(this, w)), void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(w) > -1 && this.pieClicked(w), i.config.dataLabels.enabled) {
                                    var M = p.x,
                                        D = p.y,
                                        X = 100 * C / this.fullAngle + "%";
                                    if (0 !== C && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[w]) {
                                        var H = i.config.dataLabels.formatter;
                                        void 0 !== H && (X = H(i.globals.seriesPercent[w][0], {
                                            seriesIndex: w,
                                            w: i
                                        }));
                                        var j = i.globals.dataLabels.style.colors[w],
                                            U = l.group({
                                                class: "apexcharts-datalabels"
                                            }),
                                            Q = l.drawText({
                                                x: M,
                                                y: D,
                                                text: X,
                                                textAnchor: "middle",
                                                fontSize: i.config.dataLabels.style.fontSize,
                                                fontFamily: i.config.dataLabels.style.fontFamily,
                                                fontWeight: i.config.dataLabels.style.fontWeight,
                                                foreColor: j
                                            });
                                        U.add(Q), i.config.dataLabels.dropShadow.enabled && r.dropShadow(Q, i.config.dataLabels.dropShadow), Q.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (Q.node.classList.add("apexcharts-pie-label-delay"), Q.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(U)
                                    }
                                }
                            }
                            return d
                        }
                    }, {
                        key: "addListeners",
                        value: function(t, e) {
                            var i = new ot(this.ctx);
                            t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)))
                        }
                    }, {
                        key: "animatePaths",
                        value: function(t, e) {
                            var r = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
                                l = r,
                                h = e.startAngle,
                                d = e.startAngle;
                            void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (h = e.prevEndAngle, l = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === this.w.config.series.length - 1 && (r + d > this.fullAngle ? e.endAngle = e.endAngle - (r + d) : r + d < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (r + d)))), r === this.fullAngle && (r = this.fullAngle - .01), this.animateArc(t, h, d, r, l, e)
                        }
                    }, {
                        key: "animateArc",
                        value: function(t, e, i, r, l, h) {
                            var d, g = this,
                                x = this.w,
                                b = new Bt(this.ctx),
                                v = h.size;
                            (isNaN(e) || isNaN(l)) && (e = i, l = r, h.dur = 0);
                            var w = r,
                                S = i,
                                C = e < i ? this.fullAngle + e - i : e - i;
                            x.globals.dataChanged && h.shouldSetPrevPaths && h.prevEndAngle && (d = g.getPiePath({
                                me: g,
                                startAngle: h.prevStartAngle,
                                angle: h.prevEndAngle < h.prevStartAngle ? this.fullAngle + h.prevEndAngle - h.prevStartAngle : h.prevEndAngle - h.prevStartAngle,
                                size: v
                            }), t.attr({
                                d
                            })), 0 !== h.dur ? t.animate(h.dur, x.globals.easing, h.animBeginArr[h.i]).afterAll(function() {
                                "pie" !== g.chartType && "donut" !== g.chartType && "polarArea" !== g.chartType || this.animate(x.config.chart.animations.dynamicAnimation.speed).attr({
                                    "stroke-width": g.strokeWidth
                                }), h.i === x.config.series.length - 1 && b.animationCompleted(t)
                            }).during(function(P) {
                                w = C + (r - C) * P, h.animateStartingPos && (w = l + (r - l) * P, S = e - l + (i - (e - l)) * P), d = g.getPiePath({
                                    me: g,
                                    startAngle: S,
                                    angle: w,
                                    size: v
                                }), t.node.setAttribute("data:pathOrig", d), t.attr({
                                    d
                                })
                            }) : (d = g.getPiePath({
                                me: g,
                                startAngle: S,
                                angle: r,
                                size: v
                            }), h.isTrack || (x.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", d), t.attr({
                                d,
                                "stroke-width": g.strokeWidth
                            }))
                        }
                    }, {
                        key: "pieClicked",
                        value: function(t) {
                            var e, i = this.w,
                                r = this,
                                l = r.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
                                h = i.globals.dom.Paper.select(".apexcharts-".concat(r.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
                            if ("true" !== h.attr("data:pieClicked")) {
                                var d = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                                Array.prototype.forEach.call(d, function(v) {
                                    v.setAttribute("data:pieClicked", "false");
                                    var w = v.getAttribute("data:pathOrig");
                                    w && v.setAttribute("d", w)
                                }), h.attr("data:pieClicked", "true");
                                var g = parseInt(h.attr("data:startAngle"), 10),
                                    x = parseInt(h.attr("data:angle"), 10);
                                e = r.getPiePath({
                                    me: r,
                                    startAngle: g,
                                    angle: x,
                                    size: l
                                }), 360 !== x && h.plot(e)
                            } else {
                                h.attr({
                                    "data:pieClicked": "false"
                                }), this.revertDataLabelsInner(h.node, this.donutDataLabels);
                                var b = h.attr("data:pathOrig");
                                h.attr({
                                    d: b
                                })
                            }
                        }
                    }, {
                        key: "getChangedPath",
                        value: function(t, e) {
                            var i = "";
                            return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
                                me: this,
                                startAngle: t,
                                angle: e - t,
                                size: this.size
                            })), i
                        }
                    }, {
                        key: "getPiePath",
                        value: function(t) {
                            var e = t.me,
                                i = t.startAngle,
                                r = t.angle,
                                l = t.size,
                                h = i,
                                d = Math.PI * (h - 90) / 180,
                                g = r + i;
                            Math.ceil(g) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (g = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(g) > this.fullAngle && (g -= this.fullAngle);
                            var x = Math.PI * (g - 90) / 180,
                                b = e.centerX + l * Math.cos(d),
                                v = e.centerY + l * Math.sin(d),
                                w = e.centerX + l * Math.cos(x),
                                S = e.centerY + l * Math.sin(x),
                                C = q.polarToCartesian(e.centerX, e.centerY, e.donutSize, g),
                                P = q.polarToCartesian(e.centerX, e.centerY, e.donutSize, h),
                                T = r > 180 ? 1 : 0,
                                I = ["M", b, v, "A", l, l, 0, T, 1, w, S];
                            return "donut" === e.chartType ? [].concat(I, ["L", C.x, C.y, "A", e.donutSize, e.donutSize, 0, T, 0, P.x, P.y, "L", b, v, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(I, ["L", e.centerX, e.centerY, "L", b, v]).join(" ") : [].concat(I).join(" ")
                        }
                    }, {
                        key: "drawPolarElements",
                        value: function(t) {
                            var e = this.w,
                                i = new $e(this.ctx),
                                r = new ot(this.ctx),
                                l = new N(this.ctx),
                                h = r.group(),
                                d = r.group(),
                                g = i.niceScale(0, Math.ceil(this.maxY), e.config.yaxis[0].tickAmount, 0, !0),
                                x = g.result.reverse(),
                                b = g.result.length;
                            this.maxY = g.niceMax;
                            for (var v = e.globals.radialSize, w = v / (b - 1), S = 0; S < b - 1; S++) {
                                var C = r.drawCircle(v);
                                if (C.attr({
                                        cx: this.centerX,
                                        cy: this.centerY,
                                        fill: "none",
                                        "stroke-width": e.config.plotOptions.polarArea.rings.strokeWidth,
                                        stroke: e.config.plotOptions.polarArea.rings.strokeColor
                                    }), e.config.yaxis[0].show) {
                                    var P = l.drawYAxisTexts(this.centerX, this.centerY - v + parseInt(e.config.yaxis[0].labels.style.fontSize, 10) / 2, S, x[S]);
                                    d.add(P)
                                }
                                h.add(C), v -= w
                            }
                            this.drawSpokes(t), t.add(h), t.add(d)
                        }
                    }, {
                        key: "renderInnerDataLabels",
                        value: function(t, e) {
                            var i = this.w,
                                r = new ot(this.ctx),
                                l = r.group({
                                    class: "apexcharts-datalabels-group",
                                    transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
                                }),
                                h = t.total.show;
                            l.node.style.opacity = e.opacity;
                            var d, g, x = e.centerX,
                                b = e.centerY;
                            d = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
                            var v = t.name.fontSize,
                                w = t.name.fontFamily,
                                S = t.name.fontWeight;
                            g = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
                            var C = t.value.formatter,
                                P = "",
                                T = "";
                            if (h ? (d = t.total.color, v = t.total.fontSize, w = t.total.fontFamily, S = t.total.fontWeight, T = t.total.label, P = t.total.formatter(i)) : 1 === i.globals.series.length && (P = C(i.globals.series[0], i), T = i.globals.seriesNames[0]), T && (T = t.name.formatter(T, t.total.show, i)), t.name.show) {
                                var I = r.drawText({
                                    x,
                                    y: b + parseFloat(t.name.offsetY),
                                    text: T,
                                    textAnchor: "middle",
                                    foreColor: d,
                                    fontSize: v,
                                    fontWeight: S,
                                    fontFamily: w
                                });
                                I.node.classList.add("apexcharts-datalabel-label"), l.add(I)
                            }
                            if (t.value.show) {
                                var R = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
                                    p = r.drawText({
                                        x,
                                        y: b + R,
                                        text: P,
                                        textAnchor: "middle",
                                        foreColor: g,
                                        fontWeight: t.value.fontWeight,
                                        fontSize: t.value.fontSize,
                                        fontFamily: t.value.fontFamily
                                    });
                                p.node.classList.add("apexcharts-datalabel-value"), l.add(p)
                            }
                            return l
                        }
                    }, {
                        key: "printInnerLabels",
                        value: function(t, e, i, r) {
                            var l, h = this.w;
                            r ? l = void 0 === t.name.color ? h.globals.colors[parseInt(r.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : h.globals.series.length > 1 && t.total.show && (l = t.total.color);
                            var d = h.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
                                g = h.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                            i = (0, t.value.formatter)(i, h), r || "function" != typeof t.total.formatter || (i = t.total.formatter(h)), e = t.name.formatter(e, e === t.total.label, h), null !== d && (d.textContent = e), null !== g && (g.textContent = i), null !== d && (d.style.fill = l)
                        }
                    }, {
                        key: "printDataLabelsInner",
                        value: function(t, e) {
                            var i = this.w,
                                r = t.getAttribute("data:value"),
                                l = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
                            i.globals.series.length > 1 && this.printInnerLabels(e, l, r, t);
                            var h = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                            null !== h && (h.style.opacity = 1)
                        }
                    }, {
                        key: "drawSpokes",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = new ot(this.ctx),
                                l = i.config.plotOptions.polarArea.spokes;
                            if (0 !== l.strokeWidth) {
                                for (var h = [], d = 360 / i.globals.series.length, g = 0; g < i.globals.series.length; g++) h.push(q.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + d * g));
                                h.forEach(function(x, b) {
                                    var v = r.drawLine(x.x, x.y, e.centerX, e.centerY, Array.isArray(l.connectorColors) ? l.connectorColors[b] : l.connectorColors);
                                    t.add(v)
                                })
                            }
                        }
                    }, {
                        key: "revertDataLabelsInner",
                        value: function(t, e, i) {
                            var r = this,
                                l = this.w,
                                h = l.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
                                d = !1,
                                g = l.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
                                x = function(w) {
                                    var S = w.makeSliceOut,
                                        C = w.printLabel;
                                    Array.prototype.forEach.call(g, function(P) {
                                        "true" === P.getAttribute("data:pieClicked") && (S && (d = !0), C && r.printDataLabelsInner(P, e))
                                    })
                                };
                            if (x({
                                    makeSliceOut: !0,
                                    printLabel: !1
                                }), e.total.show && l.globals.series.length > 1) d && !e.total.showAlways ? x({
                                makeSliceOut: !1,
                                printLabel: !0
                            }) : this.printInnerLabels(e, e.total.label, e.total.formatter(l));
                            else if (x({
                                    makeSliceOut: !1,
                                    printLabel: !0
                                }), !d)
                                if (l.globals.selectedDataPoints.length && l.globals.series.length > 1)
                                    if (l.globals.selectedDataPoints[0].length > 0) {
                                        var b = l.globals.selectedDataPoints[0],
                                            v = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(b));
                                        this.printDataLabelsInner(v, e)
                                    } else h && l.globals.selectedDataPoints.length && 0 === l.globals.selectedDataPoints[0].length && (h.style.opacity = 0);
                            else h && l.globals.series.length > 1 && (h.style.opacity = 0)
                        }
                    }]), _
                }(),
                Y = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
                        var e = this.w;
                        this.graphics = new ot(this.ctx), this.lineColorArr = void 0 !== e.globals.stroke.colors ? e.globals.stroke.colors : e.globals.colors, this.defaultSize = e.globals.svgHeight < e.globals.svgWidth ? e.globals.gridHeight + 1.5 * e.globals.goldenPadding : e.globals.gridWidth, this.isLog = e.config.yaxis[0].logarithmic, this.coreUtils = new te(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(e.globals.maxY, 0) : e.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : e.globals.minY, this.polygons = e.config.plotOptions.radar.polygons, this.strokeWidth = e.config.stroke.show ? e.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - e.config.chart.dropShadow.blur, e.config.xaxis.labels.show && (this.size = this.size - e.globals.xAxisLabelsWidth / 1.75), void 0 !== e.config.plotOptions.radar.size && (this.size = e.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = new ce(this.ctx),
                                l = [],
                                h = new ve(this.ctx);
                            t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
                            var b = i.globals.gridHeight / 2 + i.config.plotOptions.radar.offsetY,
                                v = this.graphics.group({
                                    class: "apexcharts-radar-series apexcharts-plot-series",
                                    transform: "translate(".concat(i.globals.gridWidth / 2 + i.config.plotOptions.radar.offsetX || 0, ", ").concat(b || 0, ")")
                                }),
                                w = [],
                                S = null,
                                C = null;
                            if (this.yaxisLabels = this.graphics.group({
                                    class: "apexcharts-yaxis"
                                }), t.forEach(function(T, I) {
                                    var R = T.length === i.globals.dataPoints,
                                        p = e.graphics.group().attr({
                                            class: "apexcharts-series",
                                            "data:longestSeries": R,
                                            seriesName: q.escapeString(i.globals.seriesNames[I]),
                                            rel: I + 1,
                                            "data:realIndex": I
                                        });
                                    e.dataRadiusOfPercent[I] = [], e.dataRadius[I] = [], e.angleArr[I] = [], T.forEach(function(it, mt) {
                                        var yt = Math.abs(e.maxValue - e.minValue);
                                        it += Math.abs(e.minValue), e.isLog && (it = e.coreUtils.getLogVal(it, 0)), e.dataRadiusOfPercent[I][mt] = it / yt, e.dataRadius[I][mt] = e.dataRadiusOfPercent[I][mt] * e.size, e.angleArr[I][mt] = mt * e.disAngle
                                    }), w = e.getDataPointsPos(e.dataRadius[I], e.angleArr[I]);
                                    var k = e.createPaths(w, {
                                        x: 0,
                                        y: 0
                                    });
                                    S = e.graphics.group({
                                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                                    }), C = e.graphics.group({
                                        class: "apexcharts-datalabels",
                                        "data:realIndex": I
                                    }), i.globals.delayedElements.push({
                                        el: S.node,
                                        index: I
                                    });
                                    var M = {
                                            i: I,
                                            realIndex: I,
                                            animationDelay: I,
                                            initialSpeed: i.config.chart.animations.speed,
                                            dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                                            className: "apexcharts-radar",
                                            shouldClipToGrid: !1,
                                            bindEventsOnPaths: !1,
                                            stroke: i.globals.stroke.colors[I],
                                            strokeLineCap: i.config.stroke.lineCap
                                        },
                                        D = null;
                                    i.globals.previousPaths.length > 0 && (D = e.getPreviousPath(I));
                                    for (var X = 0; X < k.linePathsTo.length; X++) {
                                        var H = e.graphics.renderPaths(ut(ut({}, M), {}, {
                                            pathFrom: null === D ? k.linePathsFrom[X] : D,
                                            pathTo: k.linePathsTo[X],
                                            strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[I] : e.strokeWidth,
                                            fill: "none",
                                            drawShadow: !1
                                        }));
                                        p.add(H);
                                        var j = r.fillPath({
                                                seriesNumber: I
                                            }),
                                            U = e.graphics.renderPaths(ut(ut({}, M), {}, {
                                                pathFrom: null === D ? k.areaPathsFrom[X] : D,
                                                pathTo: k.areaPathsTo[X],
                                                strokeWidth: 0,
                                                fill: j,
                                                drawShadow: !1
                                            }));
                                        i.config.chart.dropShadow.enabled && new ae(e.ctx).dropShadow(U, Object.assign({}, i.config.chart.dropShadow, {
                                            noUserSpaceOnUse: !0
                                        }), I), p.add(U)
                                    }
                                    T.forEach(function(it, mt) {
                                        var yt = new gi(e.ctx).getMarkerConfig({
                                                cssClass: "apexcharts-marker",
                                                seriesIndex: I,
                                                dataPointIndex: mt
                                            }),
                                            Pt = e.graphics.drawMarker(w[mt].x, w[mt].y, yt);
                                        Pt.attr("rel", mt), Pt.attr("j", mt), Pt.attr("index", I), Pt.node.setAttribute("default-marker-size", yt.pSize);
                                        var Dt = e.graphics.group({
                                            class: "apexcharts-series-markers"
                                        });
                                        Dt && Dt.add(Pt), S.add(Dt), p.add(S);
                                        var Vt = i.config.dataLabels;
                                        if (Vt.enabled) {
                                            var ee = Vt.formatter(i.globals.series[I][mt], {
                                                seriesIndex: I,
                                                dataPointIndex: mt,
                                                w: i
                                            });
                                            h.plotDataLabelsText({
                                                x: w[mt].x,
                                                y: w[mt].y,
                                                text: ee,
                                                textAnchor: "middle",
                                                i: I,
                                                j: I,
                                                parent: C,
                                                offsetCorrection: !1,
                                                dataLabelsConfig: ut({}, Vt)
                                            })
                                        }
                                        p.add(C)
                                    }), l.push(p)
                                }), this.drawPolygons({
                                    parent: v
                                }), i.config.xaxis.labels.show) {
                                var P = this.drawXAxisTexts();
                                v.add(P)
                            }
                            return l.forEach(function(T) {
                                v.add(T)
                            }), v.add(this.yaxisLabels), v
                        }
                    }, {
                        key: "drawPolygons",
                        value: function(t) {
                            for (var e = this, i = this.w, r = t.parent, l = new N(this.ctx), h = i.globals.yAxisScale[0].result.reverse(), d = h.length, g = [], x = this.size / (d - 1), b = 0; b < d; b++) g[b] = x * b;
                            g.reverse();
                            var v = [],
                                w = [];
                            g.forEach(function(S, C) {
                                var P = q.getPolygonPos(S, e.dataPointsLen),
                                    T = "";
                                P.forEach(function(I, R) {
                                    if (0 === C) {
                                        var p = e.graphics.drawLine(I.x, I.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[R] : e.polygons.connectorColors);
                                        w.push(p)
                                    }
                                    0 === R && e.yaxisLabelsTextsPos.push({
                                        x: I.x,
                                        y: I.y
                                    }), T += I.x + "," + I.y + " "
                                }), v.push(T)
                            }), v.forEach(function(S, C) {
                                var P = e.polygons.strokeColors,
                                    T = e.polygons.strokeWidth,
                                    I = e.graphics.drawPolygon(S, Array.isArray(P) ? P[C] : P, Array.isArray(T) ? T[C] : T, i.globals.radarPolygons.fill.colors[C]);
                                r.add(I)
                            }), w.forEach(function(S) {
                                r.add(S)
                            }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(S, C) {
                                var P = l.drawYAxisTexts(S.x, S.y, C, h[C]);
                                e.yaxisLabels.add(P)
                            })
                        }
                    }, {
                        key: "drawXAxisTexts",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.config.xaxis.labels,
                                r = this.graphics.group({
                                    class: "apexcharts-xaxis"
                                }),
                                l = q.getPolygonPos(this.size, this.dataPointsLen);
                            return e.globals.labels.forEach(function(h, d) {
                                var g = e.config.xaxis.labels.formatter,
                                    x = new ve(t.ctx);
                                if (l[d]) {
                                    var b = t.getTextPos(l[d], t.size),
                                        v = g(h, {
                                            seriesIndex: -1,
                                            dataPointIndex: d,
                                            w: e
                                        });
                                    x.plotDataLabelsText({
                                        x: b.newX,
                                        y: b.newY,
                                        text: v,
                                        textAnchor: b.textAnchor,
                                        i: d,
                                        j: d,
                                        parent: r,
                                        color: Array.isArray(i.style.colors) && i.style.colors[d] ? i.style.colors[d] : "#a8a8a8",
                                        dataLabelsConfig: ut({
                                            textAnchor: b.textAnchor,
                                            dropShadow: {
                                                enabled: !1
                                            }
                                        }, i),
                                        offsetCorrection: !1
                                    })
                                }
                            }), r
                        }
                    }, {
                        key: "createPaths",
                        value: function(t, e) {
                            var i = this,
                                r = [],
                                l = [],
                                h = [],
                                d = [];
                            if (t.length) {
                                l = [this.graphics.move(e.x, e.y)], d = [this.graphics.move(e.x, e.y)];
                                var g = this.graphics.move(t[0].x, t[0].y),
                                    x = this.graphics.move(t[0].x, t[0].y);
                                t.forEach(function(b, v) {
                                    g += i.graphics.line(b.x, b.y), x += i.graphics.line(b.x, b.y), v === t.length - 1 && (g += "Z", x += "Z")
                                }), r.push(g), h.push(x)
                            }
                            return {
                                linePathsFrom: l,
                                linePathsTo: r,
                                areaPathsFrom: d,
                                areaPathsTo: h
                            }
                        }
                    }, {
                        key: "getTextPos",
                        value: function(t, e) {
                            var i = "middle",
                                r = t.x,
                                l = t.y;
                            return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", r += 10) : t.x < 0 && (i = "end", r -= 10) : i = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? l -= 10 : t.y > 0 && (l += 10)), {
                                textAnchor: i,
                                newX: r,
                                newY: l
                            }
                        }
                    }, {
                        key: "getPreviousPath",
                        value: function(t) {
                            for (var e = this.w, i = null, r = 0; r < e.globals.previousPaths.length; r++) {
                                var l = e.globals.previousPaths[r];
                                l.paths.length > 0 && parseInt(l.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[r].paths[0] && (i = e.globals.previousPaths[r].paths[0].d)
                            }
                            return i
                        }
                    }, {
                        key: "getDataPointsPos",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                            t = t || [], e = e || [];
                            for (var r = [], l = 0; l < i; l++) {
                                var h = {};
                                h.x = t[l] * Math.sin(e[l]), h.y = -t[l] * Math.cos(e[l]), r.push(h)
                            }
                            return r
                        }
                    }]), _
                }(),
                $ = function(_) {
                    Rt(e, F);
                    var t = Me(e);

                    function e(i) {
                        var r;
                        xt(this, e), (r = t.call(this, i)).ctx = i, r.w = i.w, r.animBeginArr = [0], r.animDur = 0;
                        var l = r.w;
                        return r.startAngle = l.config.plotOptions.radialBar.startAngle, r.endAngle = l.config.plotOptions.radialBar.endAngle, r.totalAngle = Math.abs(l.config.plotOptions.radialBar.endAngle - l.config.plotOptions.radialBar.startAngle), r.trackStartAngle = l.config.plotOptions.radialBar.track.startAngle, r.trackEndAngle = l.config.plotOptions.radialBar.track.endAngle, r.donutDataLabels = r.w.config.plotOptions.radialBar.dataLabels, r.radialDataLabels = r.donutDataLabels, r.trackStartAngle || (r.trackStartAngle = r.startAngle), r.trackEndAngle || (r.trackEndAngle = r.endAngle), 360 === r.endAngle && (r.endAngle = 359.99), r.margin = parseInt(l.config.plotOptions.radialBar.track.margin, 10), r
                    }
                    return ht(e, [{
                        key: "draw",
                        value: function(i) {
                            var r = this.w,
                                l = new ot(this.ctx),
                                h = l.group({
                                    class: "apexcharts-radialbar"
                                });
                            if (r.globals.noData) return h;
                            var d = l.group(),
                                g = this.defaultSize / 2,
                                x = r.globals.gridWidth / 2,
                                b = this.defaultSize / 2.05;
                            r.config.chart.sparkline.enabled || (b = b - r.config.stroke.width - r.config.chart.dropShadow.blur);
                            var v = r.globals.fill.colors;
                            if (r.config.plotOptions.radialBar.track.show) {
                                var w = this.drawTracks({
                                    size: b,
                                    centerX: x,
                                    centerY: g,
                                    colorArr: v,
                                    series: i
                                });
                                d.add(w)
                            }
                            var S = this.drawArcs({
                                    size: b,
                                    centerX: x,
                                    centerY: g,
                                    colorArr: v,
                                    series: i
                                }),
                                C = 360;
                            r.config.plotOptions.radialBar.startAngle < 0 && (C = this.totalAngle);
                            var P = (360 - C) / 360;
                            if (r.globals.radialSize = b - b * P, this.radialDataLabels.value.show) {
                                var T = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                                r.globals.radialSize += T * P
                            }
                            return d.add(S.g), "front" === r.config.plotOptions.radialBar.hollow.position && (S.g.add(S.elHollow), S.dataLabels && S.g.add(S.dataLabels)), h.add(d), h
                        }
                    }, {
                        key: "drawTracks",
                        value: function(i) {
                            var r = this.w,
                                l = new ot(this.ctx),
                                h = l.group({
                                    class: "apexcharts-tracks"
                                }),
                                d = new ae(this.ctx),
                                g = new ce(this.ctx),
                                x = this.getStrokeWidth(i);
                            i.size = i.size - x / 2;
                            for (var b = 0; b < i.series.length; b++) {
                                var v = l.group({
                                    class: "apexcharts-radialbar-track apexcharts-track"
                                });
                                h.add(v), v.attr({
                                    rel: b + 1
                                }), i.size = i.size - x - this.margin;
                                var w = r.config.plotOptions.radialBar.track,
                                    S = g.fillPath({
                                        seriesNumber: 0,
                                        size: i.size,
                                        fillColors: Array.isArray(w.background) ? w.background[b] : w.background,
                                        solid: !0
                                    }),
                                    C = this.trackStartAngle,
                                    P = this.trackEndAngle;
                                Math.abs(P) + Math.abs(C) >= 360 && (P = 360 - Math.abs(this.startAngle) - .1);
                                var T = l.drawPath({
                                    d: "",
                                    stroke: S,
                                    strokeWidth: x * parseInt(w.strokeWidth, 10) / 100,
                                    fill: "none",
                                    strokeOpacity: w.opacity,
                                    classes: "apexcharts-radialbar-area"
                                });
                                w.dropShadow.enabled && d.dropShadow(T, w.dropShadow), v.add(T), T.attr("id", "apexcharts-radialbarTrack-" + b), this.animatePaths(T, {
                                    centerX: i.centerX,
                                    centerY: i.centerY,
                                    endAngle: P,
                                    startAngle: C,
                                    size: i.size,
                                    i: b,
                                    totalItems: 2,
                                    animBeginArr: 0,
                                    dur: 0,
                                    isTrack: !0,
                                    easing: r.globals.easing
                                })
                            }
                            return h
                        }
                    }, {
                        key: "drawArcs",
                        value: function(i) {
                            var r = this.w,
                                l = new ot(this.ctx),
                                h = new ce(this.ctx),
                                d = new ae(this.ctx),
                                g = l.group(),
                                x = this.getStrokeWidth(i);
                            i.size = i.size - x / 2;
                            var b = r.config.plotOptions.radialBar.hollow.background,
                                v = i.size - x * i.series.length - this.margin * i.series.length - x * parseInt(r.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
                                w = v - r.config.plotOptions.radialBar.hollow.margin;
                            void 0 !== r.config.plotOptions.radialBar.hollow.image && (b = this.drawHollowImage(i, g, v, b));
                            var S = this.drawHollow({
                                size: w,
                                centerX: i.centerX,
                                centerY: i.centerY,
                                fill: b || "transparent"
                            });
                            r.config.plotOptions.radialBar.hollow.dropShadow.enabled && d.dropShadow(S, r.config.plotOptions.radialBar.hollow.dropShadow);
                            var P = 1;
                            !this.radialDataLabels.total.show && r.globals.series.length > 1 && (P = 0);
                            var T = null;
                            this.radialDataLabels.show && (T = this.renderInnerDataLabels(this.radialDataLabels, {
                                hollowSize: v,
                                centerX: i.centerX,
                                centerY: i.centerY,
                                opacity: P
                            })), "back" === r.config.plotOptions.radialBar.hollow.position && (g.add(S), T && g.add(T));
                            var I = !1;
                            r.config.plotOptions.radialBar.inverseOrder && (I = !0);
                            for (var R = I ? i.series.length - 1 : 0; I ? R >= 0 : R < i.series.length; I ? R-- : R++) {
                                var p = l.group({
                                    class: "apexcharts-series apexcharts-radial-series",
                                    seriesName: q.escapeString(r.globals.seriesNames[R])
                                });
                                g.add(p), p.attr({
                                    rel: R + 1,
                                    "data:realIndex": R
                                }), this.ctx.series.addCollapsedClassToSeries(p, R), i.size = i.size - x - this.margin;
                                var k = h.fillPath({
                                        seriesNumber: R,
                                        size: i.size,
                                        value: i.series[R]
                                    }),
                                    M = this.startAngle,
                                    D = void 0,
                                    X = q.negToZero(i.series[R] > 100 ? 100 : i.series[R]) / 100,
                                    H = Math.round(this.totalAngle * X) + this.startAngle,
                                    j = void 0;
                                r.globals.dataChanged && (D = this.startAngle, j = Math.round(this.totalAngle * q.negToZero(r.globals.previousPaths[R]) / 100) + D), Math.abs(H) + Math.abs(M) >= 360 && (H -= .01), Math.abs(j) + Math.abs(D) >= 360 && (j -= .01);
                                var U = H - M,
                                    Q = Array.isArray(r.config.stroke.dashArray) ? r.config.stroke.dashArray[R] : r.config.stroke.dashArray,
                                    at = l.drawPath({
                                        d: "",
                                        stroke: k,
                                        strokeWidth: x,
                                        fill: "none",
                                        fillOpacity: r.config.fill.opacity,
                                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + R,
                                        strokeDashArray: Q
                                    });
                                ot.setAttrs(at.node, {
                                    "data:angle": U,
                                    "data:value": i.series[R]
                                }), r.config.chart.dropShadow.enabled && d.dropShadow(at, r.config.chart.dropShadow, R), d.setSelectionFilter(at, 0, R), this.addListeners(at, this.radialDataLabels), p.add(at), at.attr({
                                    index: 0,
                                    j: R
                                });
                                var mt = 0;
                                !this.initialAnim || r.globals.resized || r.globals.dataChanged || (mt = r.config.chart.animations.speed), r.globals.dataChanged && (mt = r.config.chart.animations.dynamicAnimation.speed), this.animDur = mt / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(at, {
                                    centerX: i.centerX,
                                    centerY: i.centerY,
                                    endAngle: H,
                                    startAngle: M,
                                    prevEndAngle: j,
                                    prevStartAngle: D,
                                    size: i.size,
                                    i: R,
                                    totalItems: 2,
                                    animBeginArr: this.animBeginArr,
                                    dur: mt,
                                    shouldSetPrevPaths: !0,
                                    easing: r.globals.easing
                                })
                            }
                            return {
                                g,
                                elHollow: S,
                                dataLabels: T
                            }
                        }
                    }, {
                        key: "drawHollow",
                        value: function(i) {
                            var r = new ot(this.ctx).drawCircle(2 * i.size);
                            return r.attr({
                                class: "apexcharts-radialbar-hollow",
                                cx: i.centerX,
                                cy: i.centerY,
                                r: i.size,
                                fill: i.fill
                            }), r
                        }
                    }, {
                        key: "drawHollowImage",
                        value: function(i, r, l, h) {
                            var d = this.w,
                                g = new ce(this.ctx),
                                x = q.randomId(),
                                b = d.config.plotOptions.radialBar.hollow.image;
                            if (d.config.plotOptions.radialBar.hollow.imageClipped) g.clippedImgArea({
                                width: l,
                                height: l,
                                image: b,
                                patternID: "pattern".concat(d.globals.cuid).concat(x)
                            }), h = "url(#pattern".concat(d.globals.cuid).concat(x, ")");
                            else {
                                var v = d.config.plotOptions.radialBar.hollow.imageWidth,
                                    w = d.config.plotOptions.radialBar.hollow.imageHeight;
                                if (void 0 === v && void 0 === w) {
                                    var S = d.globals.dom.Paper.image(b).loaded(function(P) {
                                        this.move(i.centerX - P.width / 2 + d.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - P.height / 2 + d.config.plotOptions.radialBar.hollow.imageOffsetY)
                                    });
                                    r.add(S)
                                } else {
                                    var C = d.globals.dom.Paper.image(b).loaded(function(P) {
                                        this.move(i.centerX - v / 2 + d.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - w / 2 + d.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(v, w)
                                    });
                                    r.add(C)
                                }
                            }
                            return h
                        }
                    }, {
                        key: "getStrokeWidth",
                        value: function(i) {
                            return i.size * (100 - parseInt(this.w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin
                        }
                    }]), e
                }(),
                K = function(_) {
                    Rt(e, Ne);
                    var t = Me(e);

                    function e() {
                        return xt(this, e), t.apply(this, arguments)
                    }
                    return ht(e, [{
                        key: "draw",
                        value: function(i, r) {
                            var l = this.w,
                                h = new ot(this.ctx);
                            this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = l.globals.seriesRangeStart, this.seriesRangeEnd = l.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
                            for (var d = h.group({
                                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                                }), g = 0; g < i.length; g++) {
                                var x, b, v, w, S = void 0,
                                    C = void 0,
                                    P = l.globals.comboCharts ? r[g] : g,
                                    T = h.group({
                                        class: "apexcharts-series",
                                        seriesName: q.escapeString(l.globals.seriesNames[P]),
                                        rel: g + 1,
                                        "data:realIndex": P
                                    });
                                this.ctx.series.addCollapsedClassToSeries(T, P), i[g].length > 0 && (this.visibleI = this.visibleI + 1);
                                var I = 0,
                                    R = 0;
                                this.yRatio.length > 1 && (this.yaxisIndex = P);
                                var p = this.barHelpers.initialPositions();
                                C = p.y, w = p.zeroW, S = p.x, R = p.barWidth, I = p.barHeight, x = p.xDivision, b = p.yDivision, v = p.zeroH;
                                for (var k = h.group({
                                        class: "apexcharts-datalabels",
                                        "data:realIndex": P
                                    }), M = h.group({
                                        class: "apexcharts-rangebar-goals-markers"
                                    }), D = 0; D < l.globals.dataPoints; D++) {
                                    var X, H = this.barHelpers.getStrokeWidth(g, D, P),
                                        j = this.seriesRangeStart[g][D],
                                        U = this.seriesRangeEnd[g][D],
                                        Q = null,
                                        at = null,
                                        it = null,
                                        mt = {
                                            x: S,
                                            y: C,
                                            strokeWidth: H,
                                            elSeries: T
                                        },
                                        yt = this.seriesLen;
                                    if (l.config.plotOptions.bar.rangeBarGroupRows && (yt = 1), void 0 === l.config.series[g].data[D]) break;
                                    if (this.isHorizontal) {
                                        if (it = C + I * this.visibleI, l.config.series[g].data[D].x) {
                                            var Dt = this.detectOverlappingBars({
                                                i: g,
                                                j: D,
                                                barYPosition: it,
                                                srty: (b - I * yt) / 2,
                                                barHeight: I,
                                                yDivision: b,
                                                initPositions: p
                                            });
                                            I = Dt.barHeight, it = Dt.barYPosition
                                        }
                                        R = (Q = this.drawRangeBarPaths(ut({
                                            indexes: {
                                                i: g,
                                                j: D,
                                                realIndex: P
                                            },
                                            barHeight: I,
                                            barYPosition: it,
                                            zeroW: w,
                                            yDivision: b,
                                            y1: j,
                                            y2: U
                                        }, mt))).barWidth
                                    } else {
                                        if (l.globals.isXNumeric && (S = (l.globals.seriesX[g][D] - l.globals.minX) / this.xRatio - R / 2), at = S + R * this.visibleI, l.config.series[g].data[D].x) {
                                            var ee = this.detectOverlappingBars({
                                                i: g,
                                                j: D,
                                                barXPosition: at,
                                                srtx: (x - R * yt) / 2,
                                                barWidth: R,
                                                xDivision: x,
                                                initPositions: p
                                            });
                                            R = ee.barWidth, at = ee.barXPosition
                                        }
                                        I = (Q = this.drawRangeColumnPaths(ut({
                                            indexes: {
                                                i: g,
                                                j: D,
                                                realIndex: P
                                            },
                                            barWidth: R,
                                            barXPosition: at,
                                            zeroH: v,
                                            xDivision: x
                                        }, mt))).barHeight
                                    }
                                    var ie = this.barHelpers.drawGoalLine({
                                        barXPosition: Q.barXPosition,
                                        barYPosition: it,
                                        goalX: Q.goalX,
                                        goalY: Q.goalY,
                                        barHeight: I,
                                        barWidth: R
                                    });
                                    ie && M.add(ie), C = Q.y, S = Q.x;
                                    var Kt = this.barHelpers.getPathFillColor(i, g, D, P);
                                    this.renderSeries((Et(X = {
                                        realIndex: P,
                                        pathFill: Kt,
                                        lineFill: l.globals.stroke.colors[P],
                                        j: D,
                                        i: g,
                                        x: S,
                                        y: C,
                                        y1: j,
                                        y2: U,
                                        pathFrom: Q.pathFrom,
                                        pathTo: Q.pathTo,
                                        strokeWidth: H,
                                        elSeries: T,
                                        series: i,
                                        barHeight: I,
                                        barWidth: R,
                                        barXPosition: at,
                                        barYPosition: it
                                    }, "barWidth", R), Et(X, "elDataLabelsWrap", k), Et(X, "elGoalsMarkers", M), Et(X, "visibleSeries", this.visibleI), Et(X, "type", "rangebar"), X))
                                }
                                d.add(T)
                            }
                            return d
                        }
                    }, {
                        key: "detectOverlappingBars",
                        value: function(i) {
                            var r = i.i,
                                l = i.j,
                                h = i.barYPosition,
                                d = i.barXPosition,
                                g = i.srty,
                                x = i.srtx,
                                b = i.barHeight,
                                v = i.barWidth,
                                w = i.yDivision,
                                S = i.xDivision,
                                C = i.initPositions,
                                P = this.w,
                                T = [],
                                I = P.config.series[r].data[l].rangeName,
                                R = P.config.series[r].data[l].x,
                                p = Array.isArray(R) ? R.join(" ") : R,
                                k = P.globals.labels.map(function(D) {
                                    return Array.isArray(D) ? D.join(" ") : D
                                }).indexOf(p),
                                M = P.globals.seriesRange[r].findIndex(function(D) {
                                    return D.x === p && D.overlaps.length > 0
                                });
                            return this.isHorizontal ? (h = P.config.plotOptions.bar.rangeBarGroupRows ? g + w * k : g + b * this.visibleI + w * k, M > -1 && !P.config.plotOptions.bar.rangeBarOverlap && (T = P.globals.seriesRange[r][M].overlaps).indexOf(I) > -1 && (h = (b = C.barHeight / T.length) * this.visibleI + w * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + b * (this.visibleI + T.indexOf(I)) + w * k)) : (k > -1 && (d = P.config.plotOptions.bar.rangeBarGroupRows ? x + S * k : x + v * this.visibleI + S * k), M > -1 && !P.config.plotOptions.bar.rangeBarOverlap && (T = P.globals.seriesRange[r][M].overlaps).indexOf(I) > -1 && (d = (v = C.barWidth / T.length) * this.visibleI + S * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + v * (this.visibleI + T.indexOf(I)) + S * k)), {
                                barYPosition: h,
                                barXPosition: d,
                                barHeight: b,
                                barWidth: v
                            }
                        }
                    }, {
                        key: "drawRangeColumnPaths",
                        value: function(i) {
                            var r = i.indexes,
                                l = i.x,
                                h = i.xDivision,
                                d = i.barWidth,
                                g = i.barXPosition,
                                x = i.zeroH,
                                b = this.w,
                                v = r.i,
                                w = r.j,
                                S = this.yRatio[this.yaxisIndex],
                                C = r.realIndex,
                                P = this.getRangeValue(C, w),
                                T = Math.min(P.start, P.end),
                                I = Math.max(P.start, P.end);
                            null == this.series[v][w] ? T = x : (T = x - T / S, I = x - I / S);
                            var R = Math.abs(I - T),
                                p = this.barHelpers.getColumnPaths({
                                    barXPosition: g,
                                    barWidth: d,
                                    y1: T,
                                    y2: I,
                                    strokeWidth: this.strokeWidth,
                                    series: this.seriesRangeEnd,
                                    realIndex: r.realIndex,
                                    i: C,
                                    j: w,
                                    w: b
                                });
                            return b.globals.isXNumeric || (l += h), {
                                pathTo: p.pathTo,
                                pathFrom: p.pathFrom,
                                barHeight: R,
                                x: l,
                                y: I,
                                goalY: this.barHelpers.getGoalValues("y", null, x, v, w),
                                barXPosition: g
                            }
                        }
                    }, {
                        key: "drawRangeBarPaths",
                        value: function(i) {
                            var r = i.indexes,
                                l = i.y,
                                g = i.yDivision,
                                x = i.barHeight,
                                b = i.barYPosition,
                                v = i.zeroW,
                                w = this.w,
                                S = v + i.y1 / this.invertedYRatio,
                                C = v + i.y2 / this.invertedYRatio,
                                P = Math.abs(C - S),
                                T = this.barHelpers.getBarpaths({
                                    barYPosition: b,
                                    barHeight: x,
                                    x1: S,
                                    x2: C,
                                    strokeWidth: this.strokeWidth,
                                    series: this.seriesRangeEnd,
                                    i: r.realIndex,
                                    realIndex: r.realIndex,
                                    j: r.j,
                                    w
                                });
                            return w.globals.isXNumeric || (l += g), {
                                pathTo: T.pathTo,
                                pathFrom: T.pathFrom,
                                barWidth: P,
                                x: C,
                                goalX: this.barHelpers.getGoalValues("x", v, null, r.realIndex, r.j),
                                y: l
                            }
                        }
                    }, {
                        key: "getRangeValue",
                        value: function(i, r) {
                            var l = this.w;
                            return {
                                start: l.globals.seriesRangeStart[i][r],
                                end: l.globals.seriesRangeEnd[i][r]
                            }
                        }
                    }]), e
                }(),
                et = function() {
                    function _(t) {
                        xt(this, _), this.w = t.w, this.lineCtx = t
                    }
                    return ht(_, [{
                        key: "sameValueSeriesFix",
                        value: function(t, e) {
                            var i = this.w;
                            if (("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) && new te(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
                                var r = e[t].slice();
                                r[r.length - 1] = r[r.length - 1] + 1e-6, e[t] = r
                            }
                            return e
                        }
                    }, {
                        key: "calculatePoints",
                        value: function(t) {
                            var e = t.series,
                                r = t.x,
                                l = t.y,
                                h = t.i,
                                d = t.j,
                                g = t.prevY,
                                x = this.w,
                                b = [],
                                v = [];
                            if (0 === d) {
                                var w = this.lineCtx.categoryAxisCorrection + x.config.markers.offsetX;
                                x.globals.isXNumeric && (w = (x.globals.seriesX[t.realIndex][0] - x.globals.minX) / this.lineCtx.xRatio + x.config.markers.offsetX), b.push(w), v.push(q.isNumber(e[h][0]) ? g + x.config.markers.offsetY : null), b.push(r + x.config.markers.offsetX), v.push(q.isNumber(e[h][d + 1]) ? l + x.config.markers.offsetY : null)
                            } else b.push(r + x.config.markers.offsetX), v.push(q.isNumber(e[h][d + 1]) ? l + x.config.markers.offsetY : null);
                            return {
                                x: b,
                                y: v
                            }
                        }
                    }, {
                        key: "checkPreviousPaths",
                        value: function(t) {
                            for (var e = t.pathFromLine, i = t.pathFromArea, r = t.realIndex, l = this.w, h = 0; h < l.globals.previousPaths.length; h++) {
                                var d = l.globals.previousPaths[h];
                                ("line" === d.type || "area" === d.type) && d.paths.length > 0 && parseInt(d.realIndex, 10) === parseInt(r, 10) && ("line" === d.type ? (this.lineCtx.appendPathFrom = !1, e = l.globals.previousPaths[h].paths[0].d) : "area" === d.type && (this.lineCtx.appendPathFrom = !1, i = l.globals.previousPaths[h].paths[0].d, l.config.stroke.show && l.globals.previousPaths[h].paths[1] && (e = l.globals.previousPaths[h].paths[1].d)))
                            }
                            return {
                                pathFromLine: e,
                                pathFromArea: i
                            }
                        }
                    }, {
                        key: "determineFirstPrevY",
                        value: function(t) {
                            var e, i = t.i,
                                r = t.series,
                                l = t.prevY,
                                h = t.lineYPosition,
                                d = this.w;
                            if (void 0 !== (null === (e = r[i]) || void 0 === e ? void 0 : e[0])) l = (h = d.config.chart.stacked && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) - r[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? r[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                            else if (d.config.chart.stacked && i > 0 && void 0 === r[i][0])
                                for (var g = i - 1; g >= 0; g--)
                                    if (null != r[g][0]) {
                                        l = h = this.lineCtx.prevSeriesY[g][0];
                                        break
                                    }
                            return {
                                prevY: l,
                                lineYPosition: h
                            }
                        }
                    }]), _
                }(),
                lt = function(_) {
                    for (var t = "", e = 0; e < _.length; e++) {
                        var i = _[e],
                            r = i.length;
                        r > 4 ? (t += "C".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]), t += ", ".concat(i[4], ", ").concat(i[5])) : r > 2 && (t += "S".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]))
                    }
                    return t
                },
                ct = function(_) {
                    var t = function(_) {
                            for (var t, e, i, r, l = function(b) {
                                    for (var v = [], w = b[0], S = b[1], C = v[0] = wt(w, S), P = 1, T = b.length - 1; P < T; P++) v[P] = .5 * (C + (C = wt(w = S, S = b[P + 1])));
                                    return v[P] = C, v
                                }(_), h = _.length - 1, d = [], g = 0; g < h; g++) i = wt(_[g], _[g + 1]), Math.abs(i) < 1e-6 ? l[g] = l[g + 1] = 0 : (r = (t = l[g] / i) * t + (e = l[g + 1] / i) * e) > 9 && (r = 3 * i / Math.sqrt(r), l[g] = r * t, l[g + 1] = r * e);
                            for (var x = 0; x <= h; x++) r = (_[Math.min(h, x + 1)][0] - _[Math.max(0, x - 1)][0]) / (6 * (1 + l[x] * l[x])), d.push([r || 0, l[x] * r || 0]);
                            return d
                        }(_),
                        e = _[1],
                        i = _[0],
                        r = [],
                        l = t[1],
                        h = t[0];
                    r.push(i, [i[0] + h[0], i[1] + h[1], e[0] - l[0], e[1] - l[1], e[0], e[1]]);
                    for (var d = 2, g = t.length; d < g; d++) {
                        var x = _[d],
                            b = t[d];
                        r.push([x[0] - b[0], x[1] - b[1], x[0], x[1]])
                    }
                    return r
                };

            function wt(_, t) {
                return (t[1] - _[1]) / (t[0] - _[0])
            }
            var st = function() {
                function _(t, e, i) {
                    xt(this, _), this.ctx = t, this.w = t.w, this.xyRatios = e, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || i, this.scatter = new fi(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new et(this), this.markers = new gi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
                }
                return ht(_, [{
                    key: "draw",
                    value: function(t, e, i, r) {
                        var l = this.w,
                            h = new ot(this.ctx),
                            d = l.globals.comboCharts ? e : l.config.chart.type,
                            g = h.group({
                                class: "apexcharts-".concat(d, "-series apexcharts-plot-series")
                            }),
                            x = new te(this.ctx, l);
                        this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = x.getLogSeries(t), this.yRatio = x.getLogYRatios(this.yRatio);
                        for (var b = [], v = 0; v < t.length; v++) {
                            t = this.lineHelpers.sameValueSeriesFix(v, t);
                            var w = l.globals.comboCharts ? i[v] : v;
                            this._initSerieVariables(t, v, w);
                            var S = [],
                                C = [],
                                P = [],
                                T = l.globals.padHorizontal + this.categoryAxisCorrection;
                            this.ctx.series.addCollapsedClassToSeries(this.elSeries, w), l.globals.isXNumeric && l.globals.seriesX.length > 0 && (T = (l.globals.seriesX[w][0] - l.globals.minX) / this.xRatio), P.push(T);
                            var I = T,
                                R = this.zeroY,
                                p = this.zeroY;
                            R = this.lineHelpers.determineFirstPrevY({
                                i: v,
                                series: t,
                                prevY: R,
                                lineYPosition: 0
                            }).prevY, S.push("smooth" === l.config.stroke.curve && null === t[v][0] ? null : R), "rangeArea" === d && (p = this.lineHelpers.determineFirstPrevY({
                                i: v,
                                series: r,
                                prevY: p,
                                lineYPosition: 0
                            }).prevY, C.push(p));
                            var k = {
                                    type: d,
                                    series: t,
                                    realIndex: w,
                                    i: v,
                                    x: T,
                                    y: 1,
                                    pathsFrom: this._calculatePathsFrom({
                                        type: d,
                                        series: t,
                                        i: v,
                                        realIndex: w,
                                        prevX: I,
                                        prevY: R,
                                        prevY2: p
                                    }),
                                    linePaths: [],
                                    areaPaths: [],
                                    seriesIndex: i,
                                    lineYPosition: 0,
                                    xArrj: P,
                                    yArrj: S,
                                    y2Arrj: C,
                                    seriesRangeEnd: r
                                },
                                M = this._iterateOverDataPoints(ut(ut({}, k), {}, {
                                    iterations: "rangeArea" === d ? t[v].length - 1 : void 0,
                                    isRangeStart: !0
                                }));
                            if ("rangeArea" === d) {
                                var D = this._calculatePathsFrom({
                                        series: r,
                                        i: v,
                                        realIndex: w,
                                        prevX: I,
                                        prevY: p
                                    }),
                                    X = this._iterateOverDataPoints(ut(ut({}, k), {}, {
                                        series: r,
                                        pathsFrom: D,
                                        iterations: r[v].length - 1,
                                        isRangeStart: !1
                                    }));
                                M.linePaths[0] = X.linePath + M.linePath, M.pathFromLine = X.pathFromLine + M.pathFromLine
                            }
                            this._handlePaths({
                                type: d,
                                realIndex: w,
                                i: v,
                                paths: M
                            }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), b.push(this.elSeries)
                        }
                        if (l.config.chart.stacked)
                            for (var H = b.length; H > 0; H--) g.add(b[H - 1]);
                        else
                            for (var j = 0; j < b.length; j++) g.add(b[j]);
                        return g
                    }
                }, {
                    key: "_initSerieVariables",
                    value: function(t, e, i) {
                        var r = this.w,
                            l = new ot(this.ctx);
                        this.xDivision = r.globals.gridWidth / (r.globals.dataPoints - ("on" === r.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[i] : r.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = r.config.yaxis[this.yaxisIndex] && r.config.yaxis[this.yaxisIndex].reversed, this.zeroY = r.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? r.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > r.globals.gridHeight || "end" === r.config.plotOptions.area.fillTo) && (this.areaBottomY = r.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = l.group({
                            class: "apexcharts-series",
                            seriesName: q.escapeString(r.globals.seriesNames[i])
                        }), this.elPointsMain = l.group({
                            class: "apexcharts-series-markers-wrap",
                            "data:realIndex": i
                        }), this.elDataLabelsWrap = l.group({
                            class: "apexcharts-datalabels",
                            "data:realIndex": i
                        }), this.elSeries.attr({
                            "data:longestSeries": t[e].length === r.globals.dataPoints,
                            rel: e + 1,
                            "data:realIndex": i
                        }), this.appendPathFrom = !0
                    }
                }, {
                    key: "_calculatePathsFrom",
                    value: function(t) {
                        var e, i, r, l, h = t.type,
                            d = t.series,
                            g = t.i,
                            x = t.realIndex,
                            b = t.prevX,
                            v = t.prevY,
                            w = t.prevY2,
                            S = this.w,
                            C = new ot(this.ctx);
                        if (null === d[g][0]) {
                            for (var P = 0; P < d[g].length; P++)
                                if (null !== d[g][P]) {
                                    e = C.move(b = this.xDivision * P, v = this.zeroY - d[g][P] / this.yRatio[this.yaxisIndex]), i = C.move(b, this.areaBottomY);
                                    break
                                }
                        } else e = C.move(b, v), "rangeArea" === h && (e = C.move(b, w) + C.line(b, v)), i = C.move(b, this.areaBottomY) + C.line(b, v);
                        if (r = C.move(-1, this.zeroY) + C.line(-1, this.zeroY), l = C.move(-1, this.zeroY) + C.line(-1, this.zeroY), S.globals.previousPaths.length > 0) {
                            var T = this.lineHelpers.checkPreviousPaths({
                                pathFromLine: r,
                                pathFromArea: l,
                                realIndex: x
                            });
                            r = T.pathFromLine, l = T.pathFromArea
                        }
                        return {
                            prevX: b,
                            prevY: v,
                            linePath: e,
                            areaPath: i,
                            pathFromLine: r,
                            pathFromArea: l
                        }
                    }
                }, {
                    key: "_handlePaths",
                    value: function(t) {
                        var e = t.type,
                            i = t.realIndex,
                            r = t.i,
                            l = t.paths,
                            h = this.w,
                            d = new ot(this.ctx),
                            g = new ce(this.ctx);
                        this.prevSeriesY.push(l.yArrj), h.globals.seriesXvalues[i] = l.xArrj, h.globals.seriesYvalues[i] = l.yArrj;
                        var x = h.config.forecastDataPoints;
                        if (x.count > 0 && "rangeArea" !== e) {
                            var b = h.globals.seriesXvalues[i][h.globals.seriesXvalues[i].length - x.count - 1],
                                v = d.drawRect(b, 0, h.globals.gridWidth, h.globals.gridHeight, 0);
                            h.globals.dom.elForecastMask.appendChild(v.node);
                            var w = d.drawRect(0, 0, b, h.globals.gridHeight, 0);
                            h.globals.dom.elNonForecastMask.appendChild(w.node)
                        }
                        this.pointsChart || h.globals.delayedElements.push({
                            el: this.elPointsMain.node,
                            index: i
                        });
                        var S = {
                            i: r,
                            realIndex: i,
                            animationDelay: r,
                            initialSpeed: h.config.chart.animations.speed,
                            dataChangeSpeed: h.config.chart.animations.dynamicAnimation.speed,
                            className: "apexcharts-".concat(e)
                        };
                        if ("area" === e)
                            for (var C = g.fillPath({
                                    seriesNumber: i
                                }), P = 0; P < l.areaPaths.length; P++) {
                                var T = d.renderPaths(ut(ut({}, S), {}, {
                                    pathFrom: l.pathFromArea,
                                    pathTo: l.areaPaths[P],
                                    stroke: "none",
                                    strokeWidth: 0,
                                    strokeLineCap: null,
                                    fill: C
                                }));
                                this.elSeries.add(T)
                            }
                        if (h.config.stroke.show && !this.pointsChart) {
                            var I = null;
                            if ("line" === e) I = g.fillPath({
                                seriesNumber: i,
                                i: r
                            });
                            else if ("solid" === h.config.stroke.fill.type) I = h.globals.stroke.colors[i];
                            else {
                                var R = h.config.fill;
                                h.config.fill = h.config.stroke.fill, I = g.fillPath({
                                    seriesNumber: i,
                                    i: r
                                }), h.config.fill = R
                            }
                            for (var p = 0; p < l.linePaths.length; p++) {
                                var k = I;
                                "rangeArea" === e && (k = g.fillPath({
                                    seriesNumber: i
                                }));
                                var M = ut(ut({}, S), {}, {
                                        pathFrom: l.pathFromLine,
                                        pathTo: l.linePaths[p],
                                        stroke: I,
                                        strokeWidth: this.strokeWidth,
                                        strokeLineCap: h.config.stroke.lineCap,
                                        fill: "rangeArea" === e ? k : "none"
                                    }),
                                    D = d.renderPaths(M);
                                if (this.elSeries.add(D), D.attr("fill-rule", "evenodd"), x.count > 0 && "rangeArea" !== e) {
                                    var X = d.renderPaths(M);
                                    X.node.setAttribute("stroke-dasharray", x.dashArray), x.strokeWidth && X.node.setAttribute("stroke-width", x.strokeWidth), this.elSeries.add(X), X.attr("clip-path", "url(#forecastMask".concat(h.globals.cuid, ")")), D.attr("clip-path", "url(#nonForecastMask".concat(h.globals.cuid, ")"))
                                }
                            }
                        }
                    }
                }, {
                    key: "_iterateOverDataPoints",
                    value: function(t) {
                        var e = this,
                            i = t.type,
                            r = t.series,
                            l = t.iterations,
                            h = t.realIndex,
                            d = t.i,
                            g = t.x,
                            x = t.y,
                            b = t.pathsFrom,
                            v = t.linePaths,
                            w = t.areaPaths,
                            S = t.seriesIndex,
                            C = t.lineYPosition,
                            P = t.xArrj,
                            T = t.yArrj,
                            I = t.y2Arrj,
                            R = t.isRangeStart,
                            p = t.seriesRangeEnd,
                            k = this.w,
                            M = new ot(this.ctx),
                            D = this.yRatio,
                            X = b.prevY,
                            H = b.linePath,
                            j = b.areaPath,
                            U = b.pathFromLine,
                            Q = b.pathFromArea,
                            at = q.isNumber(k.globals.minYArr[h]) ? k.globals.minYArr[h] : k.globals.minY;
                        l || (l = k.globals.dataPoints > 1 ? k.globals.dataPoints - 1 : k.globals.dataPoints);
                        for (var it = function(ie, Kt) {
                                return Kt - ie / D[e.yaxisIndex] + 2 * (e.isReversed ? ie / D[e.yaxisIndex] : 0)
                            }, mt = x, yt = 0; yt < l; yt++) {
                            var Pt = null == r[d][yt + 1];
                            if (k.globals.isXNumeric) {
                                var Dt = k.globals.seriesX[h][yt + 1];
                                void 0 === k.globals.seriesX[h][yt + 1] && (Dt = k.globals.seriesX[h][l - 1]), g = (Dt - k.globals.minX) / this.xRatio
                            } else g += this.xDivision;
                            C = k.config.chart.stacked && d > 0 && k.globals.collapsedSeries.length < k.config.series.length - 1 ? this.prevSeriesY[function(ie) {
                                for (var Kt = ie, Ce = 0; Ce < k.globals.series.length; Ce++)
                                    if (k.globals.collapsedSeriesIndices.indexOf(ie) > -1) {
                                        Kt--;
                                        break
                                    }
                                return Kt >= 0 ? Kt : 0
                            }(d - 1)][yt + 1] : this.zeroY, Pt ? x = it(at, C) : (x = it(r[d][yt + 1], C), "rangeArea" === i && (mt = it(p[d][yt + 1], C))), P.push(g), T.push(Pt && "smooth" === k.config.stroke.curve ? null : x), I.push(mt);
                            var Vt = this.lineHelpers.calculatePoints({
                                    series: r,
                                    x: g,
                                    y: x,
                                    realIndex: h,
                                    i: d,
                                    j: yt,
                                    prevY: X
                                }),
                                ee = this._createPaths({
                                    type: i,
                                    series: r,
                                    i: d,
                                    realIndex: h,
                                    j: yt,
                                    x: g,
                                    y: x,
                                    y2: mt,
                                    xArrj: P,
                                    yArrj: T,
                                    y2Arrj: I,
                                    linePath: H,
                                    areaPath: j,
                                    linePaths: v,
                                    areaPaths: w,
                                    seriesIndex: S,
                                    isRangeStart: R
                                });
                            w = ee.areaPaths, v = ee.linePaths, j = ee.areaPath, H = ee.linePath, !this.appendPathFrom || "smooth" === k.config.stroke.curve && "rangeArea" === i || (U += M.line(g, this.zeroY), Q += M.line(g, this.zeroY)), this.handleNullDataPoints(r, Vt, d, yt, h), this._handleMarkersAndLabels({
                                type: i,
                                pointsPos: Vt,
                                i: d,
                                j: yt,
                                realIndex: h,
                                isRangeStart: R
                            })
                        }
                        return {
                            yArrj: T,
                            xArrj: P,
                            pathFromArea: Q,
                            areaPaths: w,
                            pathFromLine: U,
                            linePaths: v,
                            linePath: H,
                            areaPath: j
                        }
                    }
                }, {
                    key: "_handleMarkersAndLabels",
                    value: function(t) {
                        var e = t.type,
                            i = t.pointsPos,
                            r = t.isRangeStart,
                            l = t.i,
                            h = t.j,
                            d = t.realIndex,
                            g = this.w,
                            x = new ve(this.ctx);
                        if (this.pointsChart) this.scatter.draw(this.elSeries, h, {
                            realIndex: d,
                            pointsPos: i,
                            zRatio: this.zRatio,
                            elParent: this.elPointsMain
                        });
                        else {
                            g.globals.series[l].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                            var b = this.markers.plotChartMarkers(i, d, h + 1);
                            null !== b && this.elPointsMain.add(b)
                        }
                        var v = x.drawDataLabel({
                            type: e,
                            isRangeStart: r,
                            pos: i,
                            i: d,
                            j: h + 1
                        });
                        null !== v && this.elDataLabelsWrap.add(v)
                    }
                }, {
                    key: "_createPaths",
                    value: function(t) {
                        var e = t.type,
                            i = t.series,
                            r = t.i,
                            l = t.realIndex,
                            h = t.j,
                            d = t.x,
                            g = t.y,
                            x = t.xArrj,
                            b = t.yArrj,
                            v = t.y2,
                            w = t.y2Arrj,
                            S = t.linePath,
                            C = t.areaPath,
                            P = t.linePaths,
                            T = t.areaPaths,
                            I = t.seriesIndex,
                            R = t.isRangeStart,
                            p = this.w,
                            k = new ot(this.ctx),
                            M = p.config.stroke.curve,
                            D = this.areaBottomY;
                        if (Array.isArray(p.config.stroke.curve) && (M = Array.isArray(I) ? p.config.stroke.curve[I[r]] : p.config.stroke.curve[r]), "rangeArea" === e && (p.globals.hasNullValues || p.config.forecastDataPoints.count > 0) && "smooth" === M && (M = "straight"), "smooth" === M) {
                            if ("rangeArea" === e ? x.length === p.globals.dataPoints : h === i[r].length - 2) {
                                var X = x.map(function(mt, yt) {
                                        return [x[yt], b[yt]]
                                    }).filter(function(mt) {
                                        return null !== mt[1]
                                    }),
                                    H = ct(X);
                                if (S += lt(H), null === i[r][0] ? C = S : C += lt(H), "rangeArea" === e && R) {
                                    S += k.line(x[x.length - 1], w[w.length - 1]);
                                    var j = x.slice().reverse(),
                                        U = w.slice().reverse(),
                                        Q = j.map(function(mt, yt) {
                                            return [j[yt], U[yt]]
                                        }),
                                        at = ct(Q);
                                    C = S += lt(at)
                                } else C += k.line(X[X.length - 1][0], D) + k.line(X[0][0], D) + k.move(X[0][0], X[0][1]) + "z";
                                P.push(S), T.push(C)
                            }
                        } else null === i[r][h + 1] && (S += k.move(d, g), C = C + k.line(p.globals.isXNumeric ? (p.globals.seriesX[l][h] - p.globals.minX) / this.xRatio : d - this.xDivision, D) + k.move(d, g) + "z"), null === i[r][h] && (S += k.move(d, g), C += k.move(d, D)), "stepline" === M ? (S = S + k.line(d, null, "H") + k.line(null, g, "V"), C = C + k.line(d, null, "H") + k.line(null, g, "V")) : "straight" === M && (S += k.line(d, g), C += k.line(d, g)), h === i[r].length - 2 && (C = C + k.line(d, D) + k.move(d, g) + "z", "rangeArea" === e && R ? S = S + k.line(d, v) + k.move(d, v) + "z" : (P.push(S), T.push(C)));
                        return {
                            linePaths: P,
                            areaPaths: T,
                            linePath: S,
                            areaPath: C
                        }
                    }
                }, {
                    key: "handleNullDataPoints",
                    value: function(t, e, i, r, l) {
                        var h = this.w;
                        if (null === t[i][r] && h.config.markers.showNullDataPoints || 1 === t[i].length) {
                            var d = this.markers.plotChartMarkers(e, l, r + 1, this.strokeWidth - h.config.markers.strokeWidth / 2, !0);
                            null !== d && this.elPointsMain.add(d)
                        }
                    }
                }]), _
            }();
            window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
                function _(d, g, x, b) {
                    this.xoffset = d, this.yoffset = g, this.height = b, this.width = x, this.shortestEdge = function() {
                        return Math.min(this.height, this.width)
                    }, this.getCoordinates = function(v) {
                        var w, S = [],
                            C = this.xoffset,
                            P = this.yoffset,
                            T = l(v) / this.height,
                            I = l(v) / this.width;
                        if (this.width >= this.height)
                            for (w = 0; w < v.length; w++) S.push([C, P, C + T, P + v[w] / T]), P += v[w] / T;
                        else
                            for (w = 0; w < v.length; w++) S.push([C, P, C + v[w] / I, P + I]), C += v[w] / I;
                        return S
                    }, this.cutArea = function(v) {
                        var w;
                        if (this.width >= this.height) {
                            var S = v / this.height;
                            w = new _(this.xoffset + S, this.yoffset, this.width - S, this.height)
                        } else {
                            var P = v / this.width;
                            w = new _(this.xoffset, this.yoffset + P, this.width, this.height - P)
                        }
                        return w
                    }
                }

                function t(d, g, x, b, v) {
                    return b = void 0 === b ? 0 : b, v = void 0 === v ? 0 : v,
                        function(S) {
                            var C, P, T = [];
                            for (C = 0; C < S.length; C++)
                                for (P = 0; P < S[C].length; P++) T.push(S[C][P]);
                            return T
                        }(e(function(S, C) {
                            var P, T = [],
                                I = C / l(S);
                            for (P = 0; P < S.length; P++) T[P] = S[P] * I;
                            return T
                        }(d, g * x), [], new _(b, v, g, x), []))
                }

                function e(d, g, x, b) {
                    var v, w, S, C, P, T, I;
                    if (0 !== d.length) return v = x.shortestEdge(), P = w = d[0], T = v, 0 === (C = g).length || ((I = C.slice()).push(P), i(C, T) >= i(I, T)) ? (g.push(w), e(d.slice(1), g, x, b)) : (S = x.cutArea(l(g), b), b.push(x.getCoordinates(g)), e(d, [], S, b)), b;
                    b.push(x.getCoordinates(g))
                }

                function i(d, g) {
                    var x = Math.min.apply(Math, d),
                        b = Math.max.apply(Math, d),
                        v = l(d);
                    return Math.max(Math.pow(g, 2) * b / Math.pow(v, 2), Math.pow(v, 2) / (Math.pow(g, 2) * x))
                }

                function r(d) {
                    return d && d.constructor === Array
                }

                function l(d) {
                    var g, x = 0;
                    for (g = 0; g < d.length; g++) x += d[g];
                    return x
                }

                function h(d) {
                    var g, x = 0;
                    if (r(d[0]))
                        for (g = 0; g < d.length; g++) x += h(d[g]);
                    else x = l(d);
                    return x
                }
                return function d(g, x, b, v, w) {
                    v = void 0 === v ? 0 : v, w = void 0 === w ? 0 : w;
                    var S, C, P = [],
                        T = [];
                    if (r(g[0])) {
                        for (C = 0; C < g.length; C++) P[C] = h(g[C]);
                        for (S = t(P, x, b, v, w), C = 0; C < g.length; C++) T.push(d(g[C], S[C][2] - S[C][0], S[C][3] - S[C][1], S[C][0], S[C][1]))
                    } else T = t(g, x, b, v, w);
                    return T
                }
            }();
            var kt, gt, Gt = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new W(t), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
                    }
                    return ht(_, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = new ot(this.ctx),
                                l = new ce(this.ctx),
                                h = r.group({
                                    class: "apexcharts-treemap"
                                });
                            if (i.globals.noData) return h;
                            var d = [];
                            return t.forEach(function(g) {
                                var x = g.map(function(b) {
                                    return Math.abs(b)
                                });
                                d.push(x)
                            }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(g, x) {
                                g.data.forEach(function(b) {
                                    Array.isArray(e.labels[x]) || (e.labels[x] = []), e.labels[x].push(b.x)
                                })
                            }), window.TreemapSquared.generate(d, i.globals.gridWidth, i.globals.gridHeight).forEach(function(g, x) {
                                var b = r.group({
                                    class: "apexcharts-series apexcharts-treemap-series",
                                    seriesName: q.escapeString(i.globals.seriesNames[x]),
                                    rel: x + 1,
                                    "data:realIndex": x
                                });
                                if (i.config.chart.dropShadow.enabled) {
                                    var v = i.config.chart.dropShadow;
                                    new ae(e.ctx).dropShadow(h, v, x)
                                }
                                var w = r.group({
                                    class: "apexcharts-data-labels"
                                });
                                g.forEach(function(S, C) {
                                    var P = S[0],
                                        T = S[1],
                                        I = S[2],
                                        R = S[3],
                                        p = r.drawRect(P, T, I - P, R - T, 0, "#fff", 1, e.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? M : i.globals.stroke.colors[x]);
                                    p.attr({
                                        cx: P,
                                        cy: T,
                                        index: x,
                                        i: x,
                                        j: C,
                                        width: I - P,
                                        height: R - T
                                    });
                                    var k = e.helpers.getShadeColor(i.config.chart.type, x, C, e.negRange),
                                        M = k.color;
                                    void 0 !== i.config.series[x].data[C] && i.config.series[x].data[C].fillColor && (M = i.config.series[x].data[C].fillColor);
                                    var D = l.fillPath({
                                        color: M,
                                        seriesNumber: x,
                                        dataPointIndex: C
                                    });
                                    p.node.classList.add("apexcharts-treemap-rect"), p.attr({
                                        fill: D
                                    }), e.helpers.addListeners(p);
                                    var X = {
                                            x: P + (I - P) / 2,
                                            y: T + (R - T) / 2,
                                            width: 0,
                                            height: 0
                                        },
                                        H = {
                                            x: P,
                                            y: T,
                                            width: I - P,
                                            height: R - T
                                        };
                                    if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                                        var j = 1;
                                        i.globals.resized || (j = i.config.chart.animations.speed), e.animateTreemap(p, X, H, j)
                                    }
                                    i.globals.dataChanged && e.dynamicAnim.enabled && i.globals.shouldAnimate && (i.globals.previousPaths[x] && i.globals.previousPaths[x][C] && i.globals.previousPaths[x][C].rect && (X = i.globals.previousPaths[x][C].rect), e.animateTreemap(p, X, H, e.dynamicAnim.speed));
                                    var Q = e.getFontSize(S),
                                        at = i.config.dataLabels.formatter(e.labels[x][C], {
                                            value: i.globals.series[x][C],
                                            seriesIndex: x,
                                            dataPointIndex: C,
                                            w: i
                                        });
                                    "truncate" === i.config.plotOptions.treemap.dataLabels.format && (Q = parseInt(i.config.dataLabels.style.fontSize, 10), at = e.truncateLabels(at, Q, P, T, I, R));
                                    var it = e.helpers.calculateDataLabels({
                                        text: at,
                                        x: (P + I) / 2,
                                        y: (T + R) / 2 + e.strokeWidth / 2 + Q / 3,
                                        i: x,
                                        j: C,
                                        colorProps: k,
                                        fontSize: Q,
                                        series: t
                                    });
                                    i.config.dataLabels.enabled && it && e.rotateToFitLabel(it, Q, at, P, T, I, R), b.add(p), null !== it && b.add(it)
                                }), b.add(w), h.add(b)
                            }), h
                        }
                    }, {
                        key: "getFontSize",
                        value: function(t) {
                            var h, e = this.w,
                                d = function g(x) {
                                    var b, v = 0;
                                    if (Array.isArray(x[0]))
                                        for (b = 0; b < x.length; b++) v += g(x[b]);
                                    else
                                        for (b = 0; b < x.length; b++) v += x[b].length;
                                    return v
                                }(this.labels) / function g(x) {
                                    var b, v = 0;
                                    if (Array.isArray(x[0]))
                                        for (b = 0; b < x.length; b++) v += g(x[b]);
                                    else
                                        for (b = 0; b < x.length; b++) v += 1;
                                    return v
                                }(this.labels);
                            return h = Math.pow((t[2] - t[0]) * (t[3] - t[1]), .5), Math.min(h / d, parseInt(e.config.dataLabels.style.fontSize, 10))
                        }
                    }, {
                        key: "rotateToFitLabel",
                        value: function(t, e, i, r, l, h, d) {
                            var g = new ot(this.ctx),
                                x = g.getTextRects(i, e);
                            if (x.width + this.w.config.stroke.width + 5 > h - r && x.width <= d - l) {
                                var b = g.rotateAroundCenter(t.node);
                                t.node.setAttribute("transform", "rotate(-90 ".concat(b.x, " ").concat(b.y, ") translate(").concat(x.height / 3, ")"))
                            }
                        }
                    }, {
                        key: "truncateLabels",
                        value: function(t, e, i, r, l, h) {
                            var d = new ot(this.ctx),
                                g = d.getTextRects(t, e).width + this.w.config.stroke.width + 5 > l - i && h - r > l - i ? h - r : l - i,
                                x = d.getTextBasedOnMaxWidth({
                                    text: t,
                                    maxWidth: g,
                                    fontSize: e
                                });
                            return t.length !== x.length && g / e < 5 ? "" : x
                        }
                    }, {
                        key: "animateTreemap",
                        value: function(t, e, i, r) {
                            var l = new Bt(this.ctx);
                            l.animateRect(t, {
                                x: e.x,
                                y: e.y,
                                width: e.width,
                                height: e.height
                            }, {
                                x: i.x,
                                y: i.y,
                                width: i.width,
                                height: i.height
                            }, r, function() {
                                l.animationCompleted(t)
                            })
                        }
                    }]), _
                }(),
                _e = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
                    }
                    return ht(_, [{
                        key: "calculateTimeScaleTicks",
                        value: function(t, e) {
                            var i = this,
                                r = this.w;
                            if (r.globals.allSeriesCollapsed) return r.globals.labels = [], r.globals.timescaleLabels = [], [];
                            var l = new ne(this.ctx),
                                h = (e - t) / 864e5;
                            this.determineInterval(h), r.globals.disableZoomIn = !1, r.globals.disableZoomOut = !1, h < .00011574074074074075 ? r.globals.disableZoomIn = !0 : h > 5e4 && (r.globals.disableZoomOut = !0);
                            var d = l.getTimeUnitsfromTimestamp(t, e, this.utc),
                                g = r.globals.gridWidth / h,
                                x = g / 24,
                                b = x / 60,
                                v = b / 60,
                                w = Math.floor(24 * h),
                                S = Math.floor(1440 * h),
                                C = Math.floor(86400 * h),
                                P = Math.floor(h),
                                T = Math.floor(h / 30),
                                I = Math.floor(h / 365),
                                R = {
                                    minMillisecond: d.minMillisecond,
                                    minSecond: d.minSecond,
                                    minMinute: d.minMinute,
                                    minHour: d.minHour,
                                    minDate: d.minDate,
                                    minMonth: d.minMonth,
                                    minYear: d.minYear
                                },
                                p = {
                                    firstVal: R,
                                    currentMillisecond: R.minMillisecond,
                                    currentSecond: R.minSecond,
                                    currentMinute: R.minMinute,
                                    currentHour: R.minHour,
                                    currentMonthDate: R.minDate,
                                    currentDate: R.minDate,
                                    currentMonth: R.minMonth,
                                    currentYear: R.minYear,
                                    daysWidthOnXAxis: g,
                                    hoursWidthOnXAxis: x,
                                    minutesWidthOnXAxis: b,
                                    secondsWidthOnXAxis: v,
                                    numberOfSeconds: C,
                                    numberOfMinutes: S,
                                    numberOfHours: w,
                                    numberOfDays: P,
                                    numberOfMonths: T,
                                    numberOfYears: I
                                };
                            switch (this.tickInterval) {
                                case "years":
                                    this.generateYearScale(p);
                                    break;
                                case "months":
                                case "half_year":
                                    this.generateMonthScale(p);
                                    break;
                                case "months_days":
                                case "months_fortnight":
                                case "days":
                                case "week_days":
                                    this.generateDayScale(p);
                                    break;
                                case "hours":
                                    this.generateHourScale(p);
                                    break;
                                case "minutes_fives":
                                case "minutes":
                                    this.generateMinuteScale(p);
                                    break;
                                case "seconds_tens":
                                case "seconds_fives":
                                case "seconds":
                                    this.generateSecondScale(p)
                            }
                            var k = this.timeScaleArray.map(function(M) {
                                var D = {
                                    position: M.position,
                                    unit: M.unit,
                                    year: M.year,
                                    day: M.day ? M.day : 1,
                                    hour: M.hour ? M.hour : 0,
                                    month: M.month + 1
                                };
                                return "month" === M.unit ? ut(ut({}, D), {}, {
                                    day: 1,
                                    value: M.value + 1
                                }) : "day" === M.unit || "hour" === M.unit ? ut(ut({}, D), {}, {
                                    value: M.value
                                }) : "minute" === M.unit ? ut(ut({}, D), {}, {
                                    value: M.value,
                                    minute: M.value
                                }) : "second" === M.unit ? ut(ut({}, D), {}, {
                                    value: M.value,
                                    minute: M.minute,
                                    second: M.second
                                }) : M
                            });
                            return k.filter(function(M) {
                                var D = 1,
                                    X = Math.ceil(r.globals.gridWidth / 120),
                                    H = M.value;
                                void 0 !== r.config.xaxis.tickAmount && (X = r.config.xaxis.tickAmount), k.length > X && (D = Math.floor(k.length / X));
                                var j = !1,
                                    U = !1;
                                switch (i.tickInterval) {
                                    case "years":
                                        "year" === M.unit && (j = !0);
                                        break;
                                    case "half_year":
                                        D = 7, "year" === M.unit && (j = !0);
                                        break;
                                    case "months":
                                        D = 1, "year" === M.unit && (j = !0);
                                        break;
                                    case "months_fortnight":
                                        D = 15, "year" !== M.unit && "month" !== M.unit || (j = !0), 30 === H && (U = !0);
                                        break;
                                    case "months_days":
                                        D = 10, "month" === M.unit && (j = !0), 30 === H && (U = !0);
                                        break;
                                    case "week_days":
                                        D = 8, "month" === M.unit && (j = !0);
                                        break;
                                    case "days":
                                        D = 1, "month" === M.unit && (j = !0);
                                        break;
                                    case "hours":
                                        "day" === M.unit && (j = !0);
                                        break;
                                    case "minutes_fives":
                                    case "seconds_fives":
                                        H % 5 != 0 && (U = !0);
                                        break;
                                    case "seconds_tens":
                                        H % 10 != 0 && (U = !0)
                                }
                                if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
                                    if (!U) return !0
                                } else if ((H % D == 0 || j) && !U) return !0
                            })
                        }
                    }, {
                        key: "recalcDimensionsBasedOnFormat",
                        value: function(t, e) {
                            var i = this.w,
                                r = this.formatDates(t),
                                l = this.removeOverlappingTS(r);
                            i.globals.timescaleLabels = l.slice(), new Ve(this.ctx).plotCoords()
                        }
                    }, {
                        key: "determineInterval",
                        value: function(t) {
                            var e = 24 * t,
                                i = 60 * e;
                            switch (!0) {
                                case t / 365 > 5:
                                    this.tickInterval = "years";
                                    break;
                                case t > 800:
                                    this.tickInterval = "half_year";
                                    break;
                                case t > 180:
                                    this.tickInterval = "months";
                                    break;
                                case t > 90:
                                    this.tickInterval = "months_fortnight";
                                    break;
                                case t > 60:
                                    this.tickInterval = "months_days";
                                    break;
                                case t > 30:
                                    this.tickInterval = "week_days";
                                    break;
                                case t > 2:
                                    this.tickInterval = "days";
                                    break;
                                case e > 2.4:
                                    this.tickInterval = "hours";
                                    break;
                                case i > 15:
                                    this.tickInterval = "minutes_fives";
                                    break;
                                case i > 5:
                                    this.tickInterval = "minutes";
                                    break;
                                case i > 1:
                                    this.tickInterval = "seconds_tens";
                                    break;
                                case 60 * i > 20:
                                    this.tickInterval = "seconds_fives";
                                    break;
                                default:
                                    this.tickInterval = "seconds"
                            }
                        }
                    }, {
                        key: "generateYearScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonth,
                                r = t.currentYear,
                                l = t.daysWidthOnXAxis,
                                h = t.numberOfYears,
                                d = e.minYear,
                                g = 0,
                                x = new ne(this.ctx),
                                b = "year";
                            if (e.minDate > 1 || e.minMonth > 0) {
                                var v = x.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
                                g = (x.determineDaysOfYear(e.minYear) - v + 1) * l, this.timeScaleArray.push({
                                    position: g,
                                    value: d = e.minYear + 1,
                                    unit: b,
                                    year: d,
                                    month: q.monthMod(i + 1)
                                })
                            } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
                                position: g,
                                value: d,
                                unit: b,
                                year: r,
                                month: q.monthMod(i + 1)
                            });
                            for (var w = d, S = g, C = 0; C < h; C++) w++, S = x.determineDaysOfYear(w - 1) * l + S, this.timeScaleArray.push({
                                position: S,
                                value: w,
                                unit: b,
                                year: w,
                                month: 1
                            })
                        }
                    }, {
                        key: "generateMonthScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonthDate,
                                r = t.currentMonth,
                                l = t.currentYear,
                                h = t.daysWidthOnXAxis,
                                d = t.numberOfMonths,
                                g = r,
                                x = 0,
                                b = new ne(this.ctx),
                                v = "month",
                                w = 0;
                            if (e.minDate > 1) {
                                x = (b.determineDaysOfMonths(r + 1, e.minYear) - i + 1) * h, g = q.monthMod(r + 1);
                                var S = l + w,
                                    C = q.monthMod(g),
                                    P = g;
                                0 === g && (v = "year", P = S, C = 1, S += w += 1), this.timeScaleArray.push({
                                    position: x,
                                    value: P,
                                    unit: v,
                                    year: S,
                                    month: C
                                })
                            } else this.timeScaleArray.push({
                                position: x,
                                value: g,
                                unit: v,
                                year: l,
                                month: q.monthMod(r)
                            });
                            for (var T = g + 1, I = x, R = 0, p = 1; R < d; R++, p++) {
                                0 === (T = q.monthMod(T)) ? (v = "year", w += 1) : v = "month";
                                var k = this._getYear(l, T, w);
                                I = b.determineDaysOfMonths(T, k) * h + I, this.timeScaleArray.push({
                                    position: I,
                                    value: 0 === T ? k : T,
                                    unit: v,
                                    year: k,
                                    month: 0 === T ? 1 : T
                                }), T++
                            }
                        }
                    }, {
                        key: "generateDayScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonth,
                                r = t.currentYear,
                                l = t.hoursWidthOnXAxis,
                                h = t.numberOfDays,
                                d = new ne(this.ctx),
                                g = "day",
                                x = e.minDate + 1,
                                b = x,
                                v = function(p, k, M) {
                                    return p > d.determineDaysOfMonths(k + 1, M) && (b = 1, g = "month", S = k += 1), k
                                },
                                w = (24 - e.minHour) * l,
                                S = x,
                                C = v(b, i, r);
                            0 === e.minHour && 1 === e.minDate ? (w = 0, S = q.monthMod(e.minMonth), g = "month", b = e.minDate) : 1 !== e.minDate && 0 === e.minHour && 0 === e.minMinute && (w = 0, S = x = e.minDate, C = v(b = x, i, r)), this.timeScaleArray.push({
                                position: w,
                                value: S,
                                unit: g,
                                year: this._getYear(r, C, 0),
                                month: q.monthMod(C),
                                day: b
                            });
                            for (var P = w, T = 0; T < h; T++) {
                                g = "day", C = v(b += 1, C, this._getYear(r, C, 0));
                                var I = this._getYear(r, C, 0);
                                P = 24 * l + P;
                                var R = 1 === b ? q.monthMod(C) : b;
                                this.timeScaleArray.push({
                                    position: P,
                                    value: R,
                                    unit: g,
                                    year: I,
                                    month: q.monthMod(C),
                                    day: R
                                })
                            }
                        }
                    }, {
                        key: "generateHourScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentDate,
                                r = t.currentMonth,
                                l = t.currentYear,
                                h = t.minutesWidthOnXAxis,
                                d = t.numberOfHours,
                                g = new ne(this.ctx),
                                x = "hour",
                                b = function(D, X) {
                                    return D > g.determineDaysOfMonths(X + 1, l) && (T = 1, X += 1), {
                                        month: X,
                                        date: T
                                    }
                                },
                                v = function(D, X) {
                                    return D > g.determineDaysOfMonths(X + 1, l) ? X += 1 : X
                                },
                                w = 60 - (e.minMinute + e.minSecond / 60),
                                S = w * h,
                                C = e.minHour + 1,
                                P = C;
                            60 === w && (S = 0, P = (C = e.minHour) + 1);
                            var T = i;
                            P >= 24 && (P = 0, T += 1, x = "day");
                            var I = b(T, r).month;
                            I = v(T, I), this.timeScaleArray.push({
                                position: S,
                                value: C,
                                unit: x,
                                day: T,
                                hour: P,
                                year: l,
                                month: q.monthMod(I)
                            }), P++;
                            for (var R = S, p = 0; p < d; p++) {
                                x = "hour", P >= 24 && (P = 0, x = "day", I = b(T += 1, I).month, I = v(T, I));
                                var k = this._getYear(l, I, 0);
                                this.timeScaleArray.push({
                                    position: R = 60 * h + R,
                                    value: 0 === P ? T : P,
                                    unit: x,
                                    hour: P,
                                    day: T,
                                    year: k,
                                    month: q.monthMod(I)
                                }), P++
                            }
                        }
                    }, {
                        key: "generateMinuteScale",
                        value: function(t) {
                            for (var x = t.minutesWidthOnXAxis, v = t.numberOfMinutes, w = t.currentMinute + 1, S = t.currentDate, C = t.currentMonth, P = t.currentYear, T = t.currentHour, I = (60 - t.currentSecond - t.currentMillisecond / 1e3) * t.secondsWidthOnXAxis, R = 0; R < v; R++) w >= 60 && (w = 0, 24 === (T += 1) && (T = 0)), this.timeScaleArray.push({
                                position: I,
                                value: w,
                                unit: "minute",
                                hour: T,
                                minute: w,
                                day: S,
                                year: this._getYear(P, C, 0),
                                month: q.monthMod(C)
                            }), I += x, w++
                        }
                    }, {
                        key: "generateSecondScale",
                        value: function(t) {
                            for (var x = t.secondsWidthOnXAxis, b = t.numberOfSeconds, v = t.currentSecond + 1, w = t.currentMinute, S = t.currentDate, C = t.currentMonth, P = t.currentYear, T = t.currentHour, I = (1e3 - t.currentMillisecond) / 1e3 * x, R = 0; R < b; R++) v >= 60 && (v = 0, ++w >= 60 && (w = 0, 24 == ++T && (T = 0))), this.timeScaleArray.push({
                                position: I,
                                value: v,
                                unit: "second",
                                hour: T,
                                minute: w,
                                second: v,
                                day: S,
                                year: this._getYear(P, C, 0),
                                month: q.monthMod(C)
                            }), I += x, v++
                        }
                    }, {
                        key: "createRawDateString",
                        value: function(t, e) {
                            var i = t.year;
                            return 0 === t.month && (t.month = 1), i += "-" + ("0" + t.month.toString()).slice(-2), i += "day" === t.unit ? "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : "-" + ("0" + (t.day ? t.day : "1")).slice(-2), i += "hour" === t.unit ? "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), i += "minute" === t.unit ? ":" + ("0" + e).slice(-2) : ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), i += "second" === t.unit ? ":" + ("0" + e).slice(-2) : ":00", this.utc && (i += ".000Z"), i
                        }
                    }, {
                        key: "formatDates",
                        value: function(t) {
                            var e = this,
                                i = this.w;
                            return t.map(function(r) {
                                var l = r.value.toString(),
                                    h = new ne(e.ctx),
                                    d = e.createRawDateString(r, l),
                                    g = h.getDate(h.parseDate(d));
                                if (e.utc || (g = h.getDate(h.parseDateWithTimezone(d))), void 0 === i.config.xaxis.labels.format) {
                                    var x = "dd MMM",
                                        b = i.config.xaxis.labels.datetimeFormatter;
                                    "year" === r.unit && (x = b.year), "month" === r.unit && (x = b.month), "day" === r.unit && (x = b.day), "hour" === r.unit && (x = b.hour), "minute" === r.unit && (x = b.minute), "second" === r.unit && (x = b.second), l = h.formatDate(g, x)
                                } else l = h.formatDate(g, i.config.xaxis.labels.format);
                                return {
                                    dateString: d,
                                    position: r.position,
                                    value: l,
                                    unit: r.unit,
                                    year: r.year,
                                    month: r.month
                                }
                            })
                        }
                    }, {
                        key: "removeOverlappingTS",
                        value: function(t) {
                            var e, i = this,
                                r = new ot(this.ctx),
                                l = !1;
                            t.length > 0 && t[0].value && t.every(function(g) {
                                return g.value.length === t[0].value.length
                            }) && (l = !0, e = r.getTextRects(t[0].value).width);
                            var h = 0;
                            return t.map(function(g, x) {
                                if (x > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                                    var b = l ? e : r.getTextRects(t[h].value).width;
                                    return g.position > t[h].position + b + 10 ? (h = x, g) : null
                                }
                                return g
                            }).filter(function(g) {
                                return null !== g
                            })
                        }
                    }, {
                        key: "_getYear",
                        value: function(t, e, i) {
                            return t + Math.floor(e / 12) + i
                        }
                    }]), _
                }(),
                Te = function() {
                    function _(t, e) {
                        xt(this, _), this.ctx = e, this.w = e.w, this.el = t
                    }
                    return ht(_, [{
                        key: "setupElements",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config,
                                i = e.chart.type;
                            t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type || "boxPlot" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), ot.setAttrs(t.dom.elWrap, {
                                id: t.chartClass.substring(1),
                                class: "apexcharts-canvas " + t.chartClass.substring(1)
                            }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
                                class: "apexcharts-svg",
                                "xmlns:data": "ApexChartsNS",
                                transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
                            }), t.dom.Paper.node.style.background = "dark" === e.theme.mode && "transparent" === e.chart.background ? "rgba(0, 0, 0, 0.8)" : e.chart.background, this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), ot.setAttrs(t.dom.elLegendForeign, {
                                x: 0,
                                y: 0,
                                width: t.svgWidth,
                                height: t.svgHeight
                            }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t.dom.elLegendForeign.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({
                                class: "apexcharts-inner apexcharts-graphical"
                            }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs)
                        }
                    }, {
                        key: "plotChartType",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.config,
                                l = i.globals,
                                h = {
                                    series: [],
                                    i: []
                                },
                                d = {
                                    series: [],
                                    i: []
                                },
                                g = {
                                    series: [],
                                    i: []
                                },
                                x = {
                                    series: [],
                                    i: []
                                },
                                b = {
                                    series: [],
                                    i: []
                                },
                                v = {
                                    series: [],
                                    i: []
                                },
                                w = {
                                    series: [],
                                    i: []
                                },
                                S = {
                                    series: [],
                                    i: []
                                },
                                C = {
                                    series: [],
                                    seriesRangeEnd: [],
                                    i: []
                                };
                            l.series.map(function(X, H) {
                                var j = 0;
                                void 0 !== t[H].type ? ("column" === t[H].type || "bar" === t[H].type ? (l.series.length > 1 && r.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), b.series.push(X), b.i.push(H), j++, i.globals.columnSeries = b.series) : "area" === t[H].type ? (d.series.push(X), d.i.push(H), j++) : "line" === t[H].type ? (h.series.push(X), h.i.push(H), j++) : "scatter" === t[H].type ? (g.series.push(X), g.i.push(H)) : "bubble" === t[H].type ? (x.series.push(X), x.i.push(H), j++) : "candlestick" === t[H].type ? (v.series.push(X), v.i.push(H), j++) : "boxPlot" === t[H].type ? (w.series.push(X), w.i.push(H), j++) : "rangeBar" === t[H].type ? (S.series.push(X), S.i.push(H), j++) : "rangeArea" === t[H].type ? (C.series.push(l.seriesRangeStart[H]), C.seriesRangeEnd.push(l.seriesRangeEnd[H]), C.i.push(H), j++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), j > 1 && (l.comboCharts = !0)) : (h.series.push(X), h.i.push(H))
                            });
                            var P = new st(this.ctx, e),
                                T = new jt(this.ctx, e);
                            this.ctx.pie = new F(this.ctx);
                            var I = new $(this.ctx);
                            this.ctx.rangeBar = new K(this.ctx, e);
                            var R = new Y(this.ctx),
                                p = [];
                            if (l.comboCharts) {
                                if (d.series.length > 0 && p.push(P.draw(d.series, "area", d.i)), b.series.length > 0)
                                    if (i.config.chart.stacked) {
                                        var k = new Gi(this.ctx, e);
                                        p.push(k.draw(b.series, b.i))
                                    } else this.ctx.bar = new Ne(this.ctx, e), p.push(this.ctx.bar.draw(b.series, b.i));
                                if (C.series.length > 0 && p.push(P.draw(C.series, "rangeArea", C.i, C.seriesRangeEnd)), h.series.length > 0 && p.push(P.draw(h.series, "line", h.i)), v.series.length > 0 && p.push(T.draw(v.series, "candlestick", v.i)), w.series.length > 0 && p.push(T.draw(w.series, "boxPlot", w.i)), S.series.length > 0 && p.push(this.ctx.rangeBar.draw(S.series, S.i)), g.series.length > 0) {
                                    var M = new st(this.ctx, e, !0);
                                    p.push(M.draw(g.series, "scatter", g.i))
                                }
                                if (x.series.length > 0) {
                                    var D = new st(this.ctx, e, !0);
                                    p.push(D.draw(x.series, "bubble", x.i))
                                }
                            } else switch (r.chart.type) {
                                case "line":
                                    p = P.draw(l.series, "line");
                                    break;
                                case "area":
                                    p = P.draw(l.series, "area");
                                    break;
                                case "bar":
                                    r.chart.stacked ? p = new Gi(this.ctx, e).draw(l.series) : (this.ctx.bar = new Ne(this.ctx, e), p = this.ctx.bar.draw(l.series));
                                    break;
                                case "candlestick":
                                    p = new jt(this.ctx, e).draw(l.series, "candlestick");
                                    break;
                                case "boxPlot":
                                    p = new jt(this.ctx, e).draw(l.series, r.chart.type);
                                    break;
                                case "rangeBar":
                                    p = this.ctx.rangeBar.draw(l.series);
                                    break;
                                case "rangeArea":
                                    p = P.draw(l.seriesRangeStart, "rangeArea", void 0, l.seriesRangeEnd);
                                    break;
                                case "heatmap":
                                    p = new E(this.ctx, e).draw(l.series);
                                    break;
                                case "treemap":
                                    p = new Gt(this.ctx, e).draw(l.series);
                                    break;
                                case "pie":
                                case "donut":
                                case "polarArea":
                                    p = this.ctx.pie.draw(l.series);
                                    break;
                                case "radialBar":
                                    p = I.draw(l.series);
                                    break;
                                case "radar":
                                    p = R.draw(l.series);
                                    break;
                                default:
                                    p = P.draw(l.series)
                            }
                            return p
                        }
                    }, {
                        key: "setSVGDimensions",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
                            var i = q.getDimensions(this.el),
                                r = e.chart.width.toString().split(/[0-9]+/g).pop();
                            "%" === r ? q.isNumber(i[0]) && (0 === i[0].width && (i = q.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : "px" !== r && "" !== r || (t.svgWidth = parseInt(e.chart.width, 10));
                            var l = e.chart.height.toString().split(/[0-9]+/g).pop();
                            if ("auto" !== t.svgHeight && "" !== t.svgHeight)
                                if ("%" === l) {
                                    var h = q.getDimensions(this.el.parentNode);
                                    t.svgHeight = h[1] * parseInt(e.chart.height, 10) / 100
                                } else t.svgHeight = parseInt(e.chart.height, 10);
                            else t.svgHeight = t.axisCharts ? t.svgWidth / 1.61 : t.svgWidth / 1.2;
                            t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), ot.setAttrs(t.dom.Paper.node, {
                                width: t.svgWidth,
                                height: t.svgHeight
                            }), "%" !== l && (t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + (e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0) + "px"), t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px"
                        }
                    }, {
                        key: "shiftGraphPosition",
                        value: function() {
                            var t = this.w.globals;
                            ot.setAttrs(t.dom.elGraphical.node, {
                                transform: "translate(" + t.translateX + ", " + t.translateY + ")"
                            })
                        }
                    }, {
                        key: "resizeNonAxisCharts",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = 0,
                                r = t.config.chart.sparkline.enabled ? 1 : 15;
                            r += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (i = new bi(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                            var l = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
                                h = 2.05 * t.globals.radialSize;
                            if (l && !t.config.chart.sparkline.enabled && 0 !== t.config.plotOptions.radialBar.startAngle) {
                                var d = q.getBoundingClientRect(l);
                                h = d.bottom, h = Math.max(2.05 * t.globals.radialSize, d.bottom - d.top)
                            }
                            var x = h + e.translateY + i + r;
                            e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", x), t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0 || (e.dom.elWrap.style.height = x + "px", ot.setAttrs(e.dom.Paper.node, {
                                height: x
                            }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = x + "px")
                        }
                    }, {
                        key: "coreCalculations",
                        value: function() {
                            new Ae(this.ctx).init()
                        }
                    }, {
                        key: "resetGlobals",
                        value: function() {
                            var t = this,
                                e = function() {
                                    return t.w.config.series.map(function(l) {
                                        return []
                                    })
                                },
                                i = new Hi,
                                r = this.w.globals;
                            i.initGlobalVars(r), r.seriesXvalues = e(), r.seriesYvalues = e()
                        }
                    }, {
                        key: "isMultipleY",
                        value: function() {
                            if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0
                        }
                    }, {
                        key: "xySettings",
                        value: function() {
                            var t = null,
                                e = this.w;
                            if (e.globals.axisCharts) {
                                if ("back" === e.config.xaxis.crosshairs.position && new $t(this.ctx).drawXCrosshairs(), "back" === e.config.yaxis[0].crosshairs.position && new $t(this.ctx).drawYCrosshairs(), "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
                                    this.ctx.timeScale = new _e(this.ctx);
                                    var i = [];
                                    isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)
                                }
                                t = new te(this.ctx).getCalculatedRatios()
                            }
                            return t
                        }
                    }, {
                        key: "updateSourceChart",
                        value: function(t) {
                            this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                                chart: {
                                    selection: {
                                        xaxis: {
                                            min: t.w.globals.minX,
                                            max: t.w.globals.maxX
                                        }
                                    }
                                }
                            }, !1, !1)
                        }
                    }, {
                        key: "setupBrushHandler",
                        value: function() {
                            var t = this,
                                e = this.w;
                            if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
                                var i = Array.isArray(e.config.chart.brush.targets) || [e.config.chart.brush.target];
                                i.forEach(function(r) {
                                    var l = ApexCharts.getChartByID(r);
                                    l.w.globals.brushSource = t.ctx, "function" != typeof l.w.config.chart.events.zoomed && (l.w.config.chart.events.zoomed = function() {
                                        t.updateSourceChart(l)
                                    }), "function" != typeof l.w.config.chart.events.scrolled && (l.w.config.chart.events.scrolled = function() {
                                        t.updateSourceChart(l)
                                    })
                                }), e.config.chart.events.selection = function(r, l) {
                                    i.forEach(function(h) {
                                        var d = ApexCharts.getChartByID(h),
                                            g = q.clone(e.config.yaxis);
                                        if (e.config.chart.brush.autoScaleYaxis && 1 === d.w.globals.series.length) {
                                            var x = new $e(d);
                                            g = x.autoScaleY(d, g, l)
                                        }
                                        var b = d.w.config.yaxis.reduce(function(v, w, S) {
                                            return [].concat(le(v), [ut(ut({}, d.w.config.yaxis[S]), {}, {
                                                min: g[0].min,
                                                max: g[0].max
                                            })])
                                        }, []);
                                        d.ctx.updateHelpers._updateOptions({
                                            xaxis: {
                                                min: l.xaxis.min,
                                                max: l.xaxis.max
                                            },
                                            yaxis: b
                                        }, !1, !1, !1, !1)
                                    })
                                }
                            }
                        }
                    }]), _
                }(),
                ge = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "_updateOptions",
                        value: function(t) {
                            var e = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                l = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                h = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                            return new Promise(function(d) {
                                var g = [e.ctx];
                                l && (g = e.ctx.getSyncedCharts()), e.ctx.w.globals.isExecCalled && (g = [e.ctx], e.ctx.w.globals.isExecCalled = !1), g.forEach(function(x, b) {
                                    var v = x.w;
                                    if (v.globals.shouldAnimate = r, i || (v.globals.resized = !0, v.globals.dataChanged = !0, r && x.series.getPreviousPaths()), t && "object" === Zt(t) && (x.config = new Pe(t), t = te.extendArrayProps(x.config, t, v), x.w.globals.chartID !== e.ctx.w.globals.chartID && delete t.series, v.config = q.extend(v.config, t), h && (v.globals.lastXAxis = t.xaxis ? q.clone(t.xaxis) : [], v.globals.lastYAxis = t.yaxis ? q.clone(t.yaxis) : [], v.globals.initialConfig = q.extend({}, v.config), v.globals.initialSeries = q.clone(v.config.series), t.series))) {
                                        for (var w = 0; w < v.globals.collapsedSeriesIndices.length; w++) {
                                            var S = v.config.series[v.globals.collapsedSeriesIndices[w]];
                                            v.globals.collapsedSeries[w].data = v.globals.axisCharts ? S.data.slice() : S
                                        }
                                        for (var C = 0; C < v.globals.ancillaryCollapsedSeriesIndices.length; C++) {
                                            var P = v.config.series[v.globals.ancillaryCollapsedSeriesIndices[C]];
                                            v.globals.ancillaryCollapsedSeries[C].data = v.globals.axisCharts ? P.data.slice() : P
                                        }
                                        x.series.emptyCollapsedSeries(v.config.series)
                                    }
                                    return x.update(t).then(function() {
                                        b === g.length - 1 && d(x)
                                    })
                                })
                            })
                        }
                    }, {
                        key: "_updateSeries",
                        value: function(t, e) {
                            var i = this,
                                r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            return new Promise(function(l) {
                                var h, d = i.w;
                                return d.globals.shouldAnimate = e, d.globals.dataChanged = !0, e && i.ctx.series.getPreviousPaths(), d.globals.axisCharts ? (0 === (h = t.map(function(g, x) {
                                    return i._extendSeries(g, x)
                                })).length && (h = [{
                                    data: []
                                }]), d.config.series = h) : d.config.series = t.slice(), r && (d.globals.initialConfig.series = q.clone(d.config.series), d.globals.initialSeries = q.clone(d.config.series)), i.ctx.update().then(function() {
                                    l(i.ctx)
                                })
                            })
                        }
                    }, {
                        key: "_extendSeries",
                        value: function(t, e) {
                            var i = this.w,
                                r = i.config.series[e];
                            return ut(ut({}, i.config.series[e]), {}, {
                                name: t.name ? t.name : r && r.name,
                                color: t.color ? t.color : r && r.color,
                                type: t.type ? t.type : r && r.type,
                                group: t.group ? t.group : r && r.group,
                                data: t.data ? t.data : r && r.data
                            })
                        }
                    }, {
                        key: "toggleDataPointSelection",
                        value: function(t, e) {
                            var i = this.w,
                                r = null,
                                l = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
                            return i.globals.axisCharts ? r = i.globals.dom.Paper.select("".concat(l, " path[j='").concat(e, "'], ").concat(l, " circle[j='").concat(e, "'], ").concat(l, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (r = i.globals.dom.Paper.select("".concat(l, " path[j='").concat(t, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t)), r ? (new ot(this.ctx).pathMouseDown(r, null), r.node ? r.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null)
                        }
                    }, {
                        key: "forceXAxisUpdate",
                        value: function(t) {
                            var e = this.w;
                            if (["min", "max"].forEach(function(r) {
                                    void 0 !== t.xaxis[r] && (e.config.xaxis[r] = t.xaxis[r], e.globals.lastXAxis[r] = t.xaxis[r])
                                }), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
                                var i = new Ze(t);
                                t = i.convertCatToNumericXaxis(t, this.ctx)
                            }
                            return t
                        }
                    }, {
                        key: "forceYAxisUpdate",
                        value: function(t) {
                            return t.chart && t.chart.stacked && "100%" === t.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function(e, i) {
                                t.yaxis[i].min = 0, t.yaxis[i].max = 100
                            }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t
                        }
                    }, {
                        key: "revertDefaultAxisMinMax",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                r = i.globals.lastXAxis,
                                l = i.globals.lastYAxis;
                            t && t.xaxis && (r = t.xaxis), t && t.yaxis && (l = t.yaxis), i.config.xaxis.min = r.min, i.config.xaxis.max = r.max, i.config.yaxis.map(function(d, g) {
                                i.globals.zoomed || void 0 !== l[g] ? function(d) {
                                    void 0 !== l[d] && (i.config.yaxis[d].min = l[d].min, i.config.yaxis[d].max = l[d].max)
                                }(g) : void 0 !== e.ctx.opts.yaxis[g] && (d.min = e.ctx.opts.yaxis[g].min, d.max = e.ctx.opts.yaxis[g].max)
                            })
                        }
                    }]), _
                }();
            kt = typeof window < "u" ? window : void 0, gt = function(_, t) {
                    var e = (void 0 !== this ? this : _).SVG = function(p) {
                        if (e.supported) return p = new e.Doc(p), e.parser.draw || e.prepare(), p
                    };
                    if (e.ns = "http://www.w3.org/2000/svg", e.xmlns = "http://www.w3.org/2000/xmlns/", e.xlink = "http://www.w3.org/1999/xlink", e.svgjs = "http://svgjs.dev", e.supported = !0, !e.supported) return !1;
                    e.did = 1e3, e.eid = function(p) {
                        return "Svgjs" + b(p) + e.did++
                    }, e.create = function(p) {
                        var k = t.createElementNS(this.ns, p);
                        return k.setAttribute("id", this.eid(p)), k
                    }, e.extend = function() {
                        var p, k;
                        k = (p = [].slice.call(arguments)).pop();
                        for (var M = p.length - 1; M >= 0; M--)
                            if (p[M])
                                for (var D in k) p[M].prototype[D] = k[D];
                        e.Set && e.Set.inherit && e.Set.inherit()
                    }, e.invent = function(p) {
                        var k = "function" == typeof p.create ? p.create : function() {
                            this.constructor.call(this, e.create(p.create))
                        };
                        return p.inherit && (k.prototype = new p.inherit), p.extend && e.extend(k, p.extend), p.construct && e.extend(p.parent || e.Container, p.construct), k
                    }, e.adopt = function(p) {
                        return p ? p.instance ? p.instance : ((k = "svg" == p.nodeName ? p.parentNode instanceof _.SVGElement ? new e.Nested : new e.Doc : "linearGradient" == p.nodeName ? new e.Gradient("linear") : "radialGradient" == p.nodeName ? new e.Gradient("radial") : e[b(p.nodeName)] ? new(e[b(p.nodeName)]) : new e.Element(p)).type = p.nodeName, k.node = p, p.instance = k, k instanceof e.Doc && k.namespace().defs(), k.setData(JSON.parse(p.getAttribute("svgjs:data")) || {}), k) : null;
                        var k
                    }, e.prepare = function() {
                        var p = t.getElementsByTagName("body")[0],
                            k = (p ? new e.Doc(p) : e.adopt(t.documentElement).nested()).size(2, 0);
                        e.parser = {
                            body: p || t.documentElement,
                            draw: k.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                            poly: k.polyline().node,
                            path: k.path().node,
                            native: e.create("svg")
                        }
                    }, e.parser = {
                        native: e.create("svg")
                    }, t.addEventListener("DOMContentLoaded", function() {
                        e.parser.draw || e.prepare()
                    }, !1), e.regex = {
                        numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
                        hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                        rgb: /rgb\((\d+),(\d+),(\d+)\)/,
                        reference: /#([a-z0-9\-_]+)/i,
                        transforms: /\)\s*,?\s*/,
                        whitespace: /\s/g,
                        isHex: /^#[a-f0-9]{3,6}$/i,
                        isRgb: /^rgb\(/,
                        isCss: /[^:]+:[^;]+;?/,
                        isBlank: /^(\s+)?$/,
                        isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
                        isPercent: /^-?[\d\.]+%$/,
                        isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
                        delimiter: /[\s,]+/,
                        hyphen: /([^e])\-/gi,
                        pathLetters: /[MLHVCSQTAZ]/gi,
                        isPathLetter: /[MLHVCSQTAZ]/i,
                        numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
                        dots: /\./g
                    }, e.utils = {
                        map: function(p, k) {
                            for (var M = p.length, D = [], X = 0; X < M; X++) D.push(k(p[X]));
                            return D
                        },
                        filter: function(p, k) {
                            for (var M = p.length, D = [], X = 0; X < M; X++) k(p[X]) && D.push(p[X]);
                            return D
                        },
                        filterSVGElements: function(p) {
                            return this.filter(p, function(k) {
                                return k instanceof _.SVGElement
                            })
                        }
                    }, e.defaults = {
                        attrs: {
                            "fill-opacity": 1,
                            "stroke-opacity": 1,
                            "stroke-width": 0,
                            "stroke-linejoin": "miter",
                            "stroke-linecap": "butt",
                            fill: "#000000",
                            stroke: "#000000",
                            opacity: 1,
                            x: 0,
                            y: 0,
                            cx: 0,
                            cy: 0,
                            width: 0,
                            height: 0,
                            r: 0,
                            rx: 0,
                            ry: 0,
                            offset: 0,
                            "stop-opacity": 1,
                            "stop-color": "#000000",
                            "font-size": 16,
                            "font-family": "Helvetica, Arial, sans-serif",
                            "text-anchor": "start"
                        }
                    }, e.Color = function(p) {
                        var k, M;
                        this.r = 0, this.g = 0, this.b = 0, p && ("string" == typeof p ? e.regex.isRgb.test(p) ? (k = e.regex.rgb.exec(p.replace(e.regex.whitespace, "")), this.r = parseInt(k[1]), this.g = parseInt(k[2]), this.b = parseInt(k[3])) : e.regex.isHex.test(p) && (k = e.regex.hex.exec(4 == (M = p).length ? ["#", M.substring(1, 2), M.substring(1, 2), M.substring(2, 3), M.substring(2, 3), M.substring(3, 4), M.substring(3, 4)].join("") : M), this.r = parseInt(k[1], 16), this.g = parseInt(k[2], 16), this.b = parseInt(k[3], 16)) : "object" === Zt(p) && (this.r = p.r, this.g = p.g, this.b = p.b))
                    }, e.extend(e.Color, {
                        toString: function() {
                            return this.toHex()
                        },
                        toHex: function() {
                            return "#" + v(this.r) + v(this.g) + v(this.b)
                        },
                        toRgb: function() {
                            return "rgb(" + [this.r, this.g, this.b].join() + ")"
                        },
                        brightness: function() {
                            return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
                        },
                        morph: function(p) {
                            return this.destination = new e.Color(p), this
                        },
                        at: function(p) {
                            return this.destination ? new e.Color({
                                r: ~~(this.r + (this.destination.r - this.r) * (p = p < 0 ? 0 : p > 1 ? 1 : p)),
                                g: ~~(this.g + (this.destination.g - this.g) * p),
                                b: ~~(this.b + (this.destination.b - this.b) * p)
                            }) : this
                        }
                    }), e.Color.test = function(p) {
                        return e.regex.isHex.test(p += "") || e.regex.isRgb.test(p)
                    }, e.Color.isRgb = function(p) {
                        return p && "number" == typeof p.r && "number" == typeof p.g && "number" == typeof p.b
                    }, e.Color.isColor = function(p) {
                        return e.Color.isRgb(p) || e.Color.test(p)
                    }, e.Array = function(p, k) {
                        0 == (p = (p || []).valueOf()).length && k && (p = k.valueOf()), this.value = this.parse(p)
                    }, e.extend(e.Array, {
                        toString: function() {
                            return this.value.join(" ")
                        },
                        valueOf: function() {
                            return this.value
                        },
                        parse: function(p) {
                            return p = p.valueOf(), Array.isArray(p) ? p : this.split(p)
                        }
                    }), e.PointArray = function(p, k) {
                        e.Array.call(this, p, k || [
                            [0, 0]
                        ])
                    }, e.PointArray.prototype = new e.Array, e.PointArray.prototype.constructor = e.PointArray;
                    for (var i = {
                            M: function(p, k, M) {
                                return k.x = M.x = p[0], k.y = M.y = p[1], ["M", k.x, k.y]
                            },
                            L: function(p, k) {
                                return k.x = p[0], k.y = p[1], ["L", p[0], p[1]]
                            },
                            H: function(p, k) {
                                return k.x = p[0], ["H", p[0]]
                            },
                            V: function(p, k) {
                                return k.y = p[0], ["V", p[0]]
                            },
                            C: function(p, k) {
                                return k.x = p[4], k.y = p[5], ["C", p[0], p[1], p[2], p[3], p[4], p[5]]
                            },
                            Q: function(p, k) {
                                return k.x = p[2], k.y = p[3], ["Q", p[0], p[1], p[2], p[3]]
                            },
                            S: function(p, k) {
                                return k.x = p[2], k.y = p[3], ["S", p[0], p[1], p[2], p[3]]
                            },
                            Z: function(p, k, M) {
                                return k.x = M.x, k.y = M.y, ["Z"]
                            }
                        }, r = "mlhvqtcsaz".split(""), l = 0, h = r.length; l < h; ++l) i[r[l]] = function(p) {
                        return function(k, M, D) {
                            if ("H" == p) k[0] = k[0] + M.x;
                            else if ("V" == p) k[0] = k[0] + M.y;
                            else if ("A" == p) k[5] = k[5] + M.x, k[6] = k[6] + M.y;
                            else
                                for (var X = 0, H = k.length; X < H; ++X) k[X] = k[X] + (X % 2 ? M.y : M.x);
                            if (i && "function" == typeof i[p]) return i[p](k, M, D)
                        }
                    }(r[l].toUpperCase());
                    e.PathArray = function(p, k) {
                        e.Array.call(this, p, k || [
                            ["M", 0, 0]
                        ])
                    }, e.PathArray.prototype = new e.Array, e.PathArray.prototype.constructor = e.PathArray, e.extend(e.PathArray, {
                        toString: function() {
                            return function(p) {
                                for (var k = 0, M = p.length, D = ""; k < M; k++) D += p[k][0], null != p[k][1] && (D += p[k][1], null != p[k][2] && (D += " ", D += p[k][2], null != p[k][3] && (D += " ", D += p[k][3], D += " ", D += p[k][4], null != p[k][5] && (D += " ", D += p[k][5], D += " ", D += p[k][6], null != p[k][7] && (D += " ", D += p[k][7])))));
                                return D + " "
                            }(this.value)
                        },
                        move: function(p, k) {
                            return this.bbox(), this
                        },
                        at: function(p) {
                            if (!this.destination) return this;
                            for (var k = this.value, M = this.destination.value, D = [], X = new e.PathArray, H = 0, j = k.length; H < j; H++) {
                                D[H] = [k[H][0]];
                                for (var U = 1, Q = k[H].length; U < Q; U++) D[H][U] = k[H][U] + (M[H][U] - k[H][U]) * p;
                                "A" === D[H][0] && (D[H][4] = +(0 != D[H][4]), D[H][5] = +(0 != D[H][5]))
                            }
                            return X.value = D, X
                        },
                        parse: function(p) {
                            if (p instanceof e.PathArray) return p.valueOf();
                            var k, M = {
                                M: 2,
                                L: 2,
                                H: 1,
                                V: 1,
                                C: 6,
                                S: 4,
                                Q: 4,
                                T: 2,
                                A: 7,
                                Z: 0
                            };
                            p = "string" == typeof p ? p.replace(e.regex.numbersWithDots, g).replace(e.regex.pathLetters, " $& ").replace(e.regex.hyphen, "$1 -").trim().split(e.regex.delimiter) : p.reduce(function(Q, at) {
                                return [].concat.call(Q, at)
                            }, []);
                            var D = [],
                                X = new e.Point,
                                H = new e.Point,
                                j = 0,
                                U = p.length;
                            do {
                                e.regex.isPathLetter.test(p[j]) ? (k = p[j], ++j) : "M" == k ? k = "L" : "m" == k && (k = "l"), D.push(i[k].call(null, p.slice(j, j += M[k.toUpperCase()]).map(parseFloat), X, H))
                            } while (U > j);
                            return D
                        },
                        bbox: function() {
                            return e.parser.draw || e.prepare(), e.parser.path.setAttribute("d", this.toString()), e.parser.path.getBBox()
                        }
                    }), e.Number = e.invent({
                        create: function(p, k) {
                            this.value = 0, this.unit = k || "", "number" == typeof p ? this.value = isNaN(p) ? 0 : isFinite(p) ? p : p < 0 ? -34e37 : 34e37 : "string" == typeof p ? (k = p.match(e.regex.numberAndUnit)) && (this.value = parseFloat(k[1]), "%" == k[5] ? this.value /= 100 : "s" == k[5] && (this.value *= 1e3), this.unit = k[5]) : p instanceof e.Number && (this.value = p.valueOf(), this.unit = p.unit)
                        },
                        extend: {
                            toString: function() {
                                return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                            },
                            toJSON: function() {
                                return this.toString()
                            },
                            valueOf: function() {
                                return this.value
                            },
                            plus: function(p) {
                                return p = new e.Number(p), new e.Number(this + p, this.unit || p.unit)
                            },
                            minus: function(p) {
                                return p = new e.Number(p), new e.Number(this - p, this.unit || p.unit)
                            },
                            times: function(p) {
                                return p = new e.Number(p), new e.Number(this * p, this.unit || p.unit)
                            },
                            divide: function(p) {
                                return p = new e.Number(p), new e.Number(this / p, this.unit || p.unit)
                            },
                            to: function(p) {
                                var k = new e.Number(this);
                                return "string" == typeof p && (k.unit = p), k
                            },
                            morph: function(p) {
                                return this.destination = new e.Number(p), p.relative && (this.destination.value += this.value), this
                            },
                            at: function(p) {
                                return this.destination ? new e.Number(this.destination).minus(this).times(p).plus(this) : this
                            }
                        }
                    }), e.Element = e.invent({
                        create: function(p) {
                            this._stroke = e.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = p) && (this.type = p.nodeName, this.node.instance = this, this._stroke = p.getAttribute("stroke") || this._stroke)
                        },
                        extend: {
                            x: function(p) {
                                return this.attr("x", p)
                            },
                            y: function(p) {
                                return this.attr("y", p)
                            },
                            cx: function(p) {
                                return null == p ? this.x() + this.width() / 2 : this.x(p - this.width() / 2)
                            },
                            cy: function(p) {
                                return null == p ? this.y() + this.height() / 2 : this.y(p - this.height() / 2)
                            },
                            move: function(p, k) {
                                return this.x(p).y(k)
                            },
                            center: function(p, k) {
                                return this.cx(p).cy(k)
                            },
                            width: function(p) {
                                return this.attr("width", p)
                            },
                            height: function(p) {
                                return this.attr("height", p)
                            },
                            size: function(p, k) {
                                var M = w(this, p, k);
                                return this.width(new e.Number(M.width)).height(new e.Number(M.height))
                            },
                            clone: function(p) {
                                this.writeDataToDom();
                                var k = P(this.node.cloneNode(!0));
                                return p ? p.add(k) : this.after(k), k
                            },
                            remove: function() {
                                return this.parent() && this.parent().removeElement(this), this
                            },
                            replace: function(p) {
                                return this.after(p).remove(), p
                            },
                            addTo: function(p) {
                                return p.put(this)
                            },
                            putIn: function(p) {
                                return p.add(this)
                            },
                            id: function(p) {
                                return this.attr("id", p)
                            },
                            show: function() {
                                return this.style("display", "")
                            },
                            hide: function() {
                                return this.style("display", "none")
                            },
                            visible: function() {
                                return "none" != this.style("display")
                            },
                            toString: function() {
                                return this.attr("id")
                            },
                            classes: function() {
                                var p = this.attr("class");
                                return null == p ? [] : p.trim().split(e.regex.delimiter)
                            },
                            hasClass: function(p) {
                                return -1 != this.classes().indexOf(p)
                            },
                            addClass: function(p) {
                                if (!this.hasClass(p)) {
                                    var k = this.classes();
                                    k.push(p), this.attr("class", k.join(" "))
                                }
                                return this
                            },
                            removeClass: function(p) {
                                return this.hasClass(p) && this.attr("class", this.classes().filter(function(k) {
                                    return k != p
                                }).join(" ")), this
                            },
                            toggleClass: function(p) {
                                return this.hasClass(p) ? this.removeClass(p) : this.addClass(p)
                            },
                            reference: function(p) {
                                return e.get(this.attr(p))
                            },
                            parent: function(p) {
                                var k = this;
                                if (!k.node.parentNode) return null;
                                if (k = e.adopt(k.node.parentNode), !p) return k;
                                for (; k && k.node instanceof _.SVGElement;) {
                                    if ("string" == typeof p ? k.matches(p) : k instanceof p) return k;
                                    if (!k.node.parentNode || "#document" == k.node.parentNode.nodeName) return null;
                                    k = e.adopt(k.node.parentNode)
                                }
                            },
                            doc: function() {
                                return this instanceof e.Doc ? this : this.parent(e.Doc)
                            },
                            parents: function(p) {
                                var k = [],
                                    M = this;
                                do {
                                    if (!(M = M.parent(p)) || !M.node) break;
                                    k.push(M)
                                } while (M.parent);
                                return k
                            },
                            matches: function(p) {
                                return ((k = this.node).matches || k.matchesSelector || k.msMatchesSelector || k.mozMatchesSelector || k.webkitMatchesSelector || k.oMatchesSelector).call(k, p);
                                var k
                            },
                            native: function() {
                                return this.node
                            },
                            svg: function(p) {
                                var k = t.createElement("svg");
                                if (!(p && this instanceof e.Parent)) return k.appendChild(p = t.createElement("svg")), this.writeDataToDom(), p.appendChild(this.node.cloneNode(!0)), k.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                                k.innerHTML = "<svg>" + p.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                                for (var M = 0, D = k.firstChild.childNodes.length; M < D; M++) this.node.appendChild(k.firstChild.firstChild);
                                return this
                            },
                            writeDataToDom: function() {
                                return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
                                    this.writeDataToDom()
                                }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
                            },
                            setData: function(p) {
                                return this.dom = p, this
                            },
                            is: function(p) {
                                return this instanceof p
                            }
                        }
                    }), e.easing = {
                        "-": function(p) {
                            return p
                        },
                        "<>": function(p) {
                            return -Math.cos(p * Math.PI) / 2 + .5
                        },
                        ">": function(p) {
                            return Math.sin(p * Math.PI / 2)
                        },
                        "<": function(p) {
                            return 1 - Math.cos(p * Math.PI / 2)
                        }
                    }, e.morph = function(p) {
                        return function(k, M) {
                            return new e.MorphObj(k, M).at(p)
                        }
                    }, e.Situation = e.invent({
                        create: function(p) {
                            this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new e.Number(p.duration).valueOf(), this.delay = new e.Number(p.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = p.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
                        }
                    }), e.FX = e.invent({
                        create: function(p) {
                            this._target = p, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
                        },
                        extend: {
                            animate: function(p, k, M) {
                                "object" === Zt(p) && (k = p.ease, M = p.delay, p = p.duration);
                                var D = new e.Situation({
                                    duration: p || 1e3,
                                    delay: M || 0,
                                    ease: e.easing[k || "-"] || k
                                });
                                return this.queue(D), this
                            },
                            target: function(p) {
                                return p && p instanceof e.Element ? (this._target = p, this) : this._target
                            },
                            timeToAbsPos: function(p) {
                                return (p - this.situation.start) / (this.situation.duration / this._speed)
                            },
                            absPosToTime: function(p) {
                                return this.situation.duration / this._speed * p + this.situation.start
                            },
                            startAnimFrame: function() {
                                this.stopAnimFrame(), this.animationFrame = _.requestAnimationFrame(function() {
                                    this.step()
                                }.bind(this))
                            },
                            stopAnimFrame: function() {
                                _.cancelAnimationFrame(this.animationFrame)
                            },
                            start: function() {
                                return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
                            },
                            startCurrent: function() {
                                return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
                            },
                            queue: function(p) {
                                return ("function" == typeof p || p instanceof e.Situation) && this.situations.push(p), this.situation || (this.situation = this.situations.shift()), this
                            },
                            dequeue: function() {
                                return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof e.Situation ? this.start() : this.situation.call(this)), this
                            },
                            initAnimations: function() {
                                var p, k = this.situation;
                                if (k.init) return this;
                                for (var M in k.animations) {
                                    p = this.target()[M](), Array.isArray(p) || (p = [p]), Array.isArray(k.animations[M]) || (k.animations[M] = [k.animations[M]]);
                                    for (var D = p.length; D--;) k.animations[M][D] instanceof e.Number && (p[D] = new e.Number(p[D])), k.animations[M][D] = p[D].morph(k.animations[M][D])
                                }
                                for (var M in k.attrs) k.attrs[M] = new e.MorphObj(this.target().attr(M), k.attrs[M]);
                                for (var M in k.styles) k.styles[M] = new e.MorphObj(this.target().style(M), k.styles[M]);
                                return k.initialTransformation = this.target().matrixify(), k.init = !0, this
                            },
                            clearQueue: function() {
                                return this.situations = [], this
                            },
                            clearCurrent: function() {
                                return this.situation = null, this
                            },
                            stop: function(p, k) {
                                var M = this.active;
                                return this.active = !1, k && this.clearQueue(), p && this.situation && (!M && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
                            },
                            after: function(p) {
                                var k = this.last();
                                return this.target().on("finished.fx", function M(D) {
                                    D.detail.situation == k && (p.call(this, k), this.off("finished.fx", M))
                                }), this._callStart()
                            },
                            during: function(p) {
                                var k = this.last(),
                                    M = function(D) {
                                        D.detail.situation == k && p.call(this, D.detail.pos, e.morph(D.detail.pos), D.detail.eased, k)
                                    };
                                return this.target().off("during.fx", M).on("during.fx", M), this.after(function() {
                                    this.off("during.fx", M)
                                }), this._callStart()
                            },
                            afterAll: function(p) {
                                var k = function M(D) {
                                    p.call(this), this.off("allfinished.fx", M)
                                };
                                return this.target().off("allfinished.fx", k).on("allfinished.fx", k), this._callStart()
                            },
                            last: function() {
                                return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                            },
                            add: function(p, k, M) {
                                return this.last()[M || "animations"][p] = k, this._callStart()
                            },
                            step: function(p) {
                                var k, M, D;
                                p || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (k = Math.max(this.absPos, 0), M = Math.floor(k), !0 === this.situation.loops || M < this.situation.loops ? (this.pos = k - M, D = this.situation.loop, this.situation.loop = M) : (this.absPos = this.situation.loops, this.pos = 1, D = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - D) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                                var X = this.situation.ease(this.pos);
                                for (var H in this.situation.once) H > this.lastPos && H <= X && (this.situation.once[H].call(this.target(), this.pos, X), delete this.situation.once[H]);
                                return this.active && this.target().fire("during", {
                                    pos: this.pos,
                                    eased: X,
                                    fx: this,
                                    situation: this.situation
                                }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                                    fx: this,
                                    situation: this.situation
                                }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = X, this) : this
                            },
                            eachAt: function() {
                                var p, k = this,
                                    M = this.target(),
                                    D = this.situation;
                                for (var X in D.animations) p = [].concat(D.animations[X]).map(function(U) {
                                    return "string" != typeof U && U.at ? U.at(D.ease(k.pos), k.pos) : U
                                }), M[X].apply(M, p);
                                for (var X in D.attrs) p = [X].concat(D.attrs[X]).map(function(Q) {
                                    return "string" != typeof Q && Q.at ? Q.at(D.ease(k.pos), k.pos) : Q
                                }), M.attr.apply(M, p);
                                for (var X in D.styles) p = [X].concat(D.styles[X]).map(function(Q) {
                                    return "string" != typeof Q && Q.at ? Q.at(D.ease(k.pos), k.pos) : Q
                                }), M.style.apply(M, p);
                                if (D.transforms.length) {
                                    p = D.initialTransformation, X = 0;
                                    for (var H = D.transforms.length; X < H; X++) {
                                        var j = D.transforms[X];
                                        j instanceof e.Matrix ? p = j.relative ? p.multiply((new e.Matrix).morph(j).at(D.ease(this.pos))) : p.morph(j).at(D.ease(this.pos)) : (j.relative || j.undo(p.extract()), p = p.multiply(j.at(D.ease(this.pos))))
                                    }
                                    M.matrix(p)
                                }
                                return this
                            },
                            once: function(p, k, M) {
                                var D = this.last();
                                return M || (p = D.ease(p)), D.once[p] = k, this
                            },
                            _callStart: function() {
                                return setTimeout(function() {
                                    this.start()
                                }.bind(this), 0), this
                            }
                        },
                        parent: e.Element,
                        construct: {
                            animate: function(p, k, M) {
                                return (this.fx || (this.fx = new e.FX(this))).animate(p, k, M)
                            },
                            delay: function(p) {
                                return (this.fx || (this.fx = new e.FX(this))).delay(p)
                            },
                            stop: function(p, k) {
                                return this.fx && this.fx.stop(p, k), this
                            },
                            finish: function() {
                                return this.fx && this.fx.finish(), this
                            }
                        }
                    }), e.MorphObj = e.invent({
                        create: function(p, k) {
                            return e.Color.isColor(k) ? new e.Color(p).morph(k) : e.regex.delimiter.test(p) ? e.regex.pathLetters.test(p) ? new e.PathArray(p).morph(k) : new e.Array(p).morph(k) : e.regex.numberAndUnit.test(k) ? new e.Number(p).morph(k) : (this.value = p, void(this.destination = k))
                        },
                        extend: {
                            at: function(p, k) {
                                return k < 1 ? this.value : this.destination
                            },
                            valueOf: function() {
                                return this.value
                            }
                        }
                    }), e.extend(e.FX, {
                        attr: function(p, k, M) {
                            if ("object" === Zt(p))
                                for (var D in p) this.attr(D, p[D]);
                            else this.add(p, k, "attrs");
                            return this
                        },
                        plot: function(p, k, M, D) {
                            return 4 == arguments.length ? this.plot([p, k, M, D]) : this.add("plot", new(this.target().morphArray)(p))
                        }
                    }), e.Box = e.invent({
                        create: function(p, k, M, D) {
                            if (!("object" !== Zt(p) || p instanceof e.Element)) return e.Box.call(this, null != p.left ? p.left : p.x, null != p.top ? p.top : p.y, p.width, p.height);
                            var X;
                            4 == arguments.length && (this.x = p, this.y = k, this.width = M, this.height = D), null == (X = this).x && (X.x = 0, X.y = 0, X.width = 0, X.height = 0), X.w = X.width, X.h = X.height, X.x2 = X.x + X.width, X.y2 = X.y + X.height, X.cx = X.x + X.width / 2, X.cy = X.y + X.height / 2
                        }
                    }), e.BBox = e.invent({
                        create: function(p) {
                            if (e.Box.apply(this, [].slice.call(arguments)), p instanceof e.Element) {
                                var k;
                                try {
                                    if (!t.documentElement.contains) {
                                        for (var M = p.node; M.parentNode;) M = M.parentNode;
                                        if (M != t) throw new Error("Element not in the dom")
                                    }
                                    k = p.node.getBBox()
                                } catch {
                                    if (p instanceof e.Shape) {
                                        e.parser.draw || e.prepare();
                                        var D = p.clone(e.parser.draw.instance).show();
                                        D && D.node && "function" == typeof D.node.getBBox && (k = D.node.getBBox()), D && "function" == typeof D.remove && D.remove()
                                    } else k = {
                                        x: p.node.clientLeft,
                                        y: p.node.clientTop,
                                        width: p.node.clientWidth,
                                        height: p.node.clientHeight
                                    }
                                }
                                e.Box.call(this, k)
                            }
                        },
                        inherit: e.Box,
                        parent: e.Element,
                        construct: {
                            bbox: function() {
                                return new e.BBox(this)
                            }
                        }
                    }), e.BBox.prototype.constructor = e.BBox, e.Matrix = e.invent({
                        create: function(p) {
                            var k = C([1, 0, 0, 1, 0, 0]);
                            p = null === p ? k : p instanceof e.Element ? p.matrixify() : "string" == typeof p ? C(p.split(e.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? C([].slice.call(arguments)) : Array.isArray(p) ? C(p) : p && "object" === Zt(p) ? p : k;
                            for (var M = I.length - 1; M >= 0; --M) this[I[M]] = null != p[I[M]] ? p[I[M]] : k[I[M]]
                        },
                        extend: {
                            extract: function() {
                                var p = S(this, 0, 1);
                                S(this, 1, 0);
                                var k = 180 / Math.PI * Math.atan2(p.y, p.x) - 90;
                                return {
                                    x: this.e,
                                    y: this.f,
                                    transformedX: (this.e * Math.cos(k * Math.PI / 180) + this.f * Math.sin(k * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                                    transformedY: (this.f * Math.cos(k * Math.PI / 180) + this.e * Math.sin(-k * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                                    rotation: k,
                                    a: this.a,
                                    b: this.b,
                                    c: this.c,
                                    d: this.d,
                                    e: this.e,
                                    f: this.f,
                                    matrix: new e.Matrix(this)
                                }
                            },
                            clone: function() {
                                return new e.Matrix(this)
                            },
                            morph: function(p) {
                                return this.destination = new e.Matrix(p), this
                            },
                            multiply: function(p) {
                                return new e.Matrix(this.native().multiply((k = p, k instanceof e.Matrix || (k = new e.Matrix(k)), k).native()));
                                var k
                            },
                            inverse: function() {
                                return new e.Matrix(this.native().inverse())
                            },
                            translate: function(p, k) {
                                return new e.Matrix(this.native().translate(p || 0, k || 0))
                            },
                            native: function() {
                                for (var p = e.parser.native.createSVGMatrix(), k = I.length - 1; k >= 0; k--) p[I[k]] = this[I[k]];
                                return p
                            },
                            toString: function() {
                                return "matrix(" + T(this.a) + "," + T(this.b) + "," + T(this.c) + "," + T(this.d) + "," + T(this.e) + "," + T(this.f) + ")"
                            }
                        },
                        parent: e.Element,
                        construct: {
                            ctm: function() {
                                return new e.Matrix(this.node.getCTM())
                            },
                            screenCTM: function() {
                                if (this instanceof e.Nested) {
                                    var p = this.rect(1, 1),
                                        k = p.node.getScreenCTM();
                                    return p.remove(), new e.Matrix(k)
                                }
                                return new e.Matrix(this.node.getScreenCTM())
                            }
                        }
                    }), e.Point = e.invent({
                        create: function(p, k) {
                            var M;
                            M = Array.isArray(p) ? {
                                x: p[0],
                                y: p[1]
                            } : "object" === Zt(p) ? {
                                x: p.x,
                                y: p.y
                            } : null != p ? {
                                x: p,
                                y: k ? ? p
                            } : {
                                x: 0,
                                y: 0
                            }, this.x = M.x, this.y = M.y
                        },
                        extend: {
                            clone: function() {
                                return new e.Point(this)
                            },
                            morph: function(p, k) {
                                return this.destination = new e.Point(p, k), this
                            }
                        }
                    }), e.extend(e.Element, {
                        point: function(p, k) {
                            return new e.Point(p, k).transform(this.screenCTM().inverse())
                        }
                    }), e.extend(e.Element, {
                        attr: function(p, k, M) {
                            if (null == p) {
                                for (p = {}, M = (k = this.node.attributes).length - 1; M >= 0; M--) p[k[M].nodeName] = e.regex.isNumber.test(k[M].nodeValue) ? parseFloat(k[M].nodeValue) : k[M].nodeValue;
                                return p
                            }
                            if ("object" === Zt(p))
                                for (var D in p) this.attr(D, p[D]);
                            else if (null === k) this.node.removeAttribute(p);
                            else {
                                if (null == k) return null == (k = this.node.getAttribute(p)) ? e.defaults.attrs[p] : e.regex.isNumber.test(k) ? parseFloat(k) : k;
                                "stroke-width" == p ? this.attr("stroke", parseFloat(k) > 0 ? this._stroke : null) : "stroke" == p && (this._stroke = k), "fill" != p && "stroke" != p || (e.regex.isImage.test(k) && (k = this.doc().defs().image(k, 0, 0)), k instanceof e.Image && (k = this.doc().defs().pattern(0, 0, function() {
                                    this.add(k)
                                }))), "number" == typeof k ? k = new e.Number(k) : e.Color.isColor(k) ? k = new e.Color(k) : Array.isArray(k) && (k = new e.Array(k)), "leading" == p ? this.leading && this.leading(k) : "string" == typeof M ? this.node.setAttributeNS(M, p, k.toString()) : this.node.setAttribute(p, k.toString()), !this.rebuild || "font-size" != p && "x" != p || this.rebuild(p, k)
                            }
                            return this
                        }
                    }), e.extend(e.Element, {
                        transform: function(p, k) {
                            var M;
                            return "object" !== Zt(p) ? (M = new e.Matrix(this).extract(), "string" == typeof p ? M[p] : M) : (M = new e.Matrix(this), k = !!k || !!p.relative, null != p.a && (M = k ? M.multiply(new e.Matrix(p)) : new e.Matrix(p)), this.attr("transform", M))
                        }
                    }), e.extend(e.Element, {
                        untransform: function() {
                            return this.attr("transform", null)
                        },
                        matrixify: function() {
                            return (this.attr("transform") || "").split(e.regex.transforms).slice(0, -1).map(function(p) {
                                var k = p.trim().split("(");
                                return [k[0], k[1].split(e.regex.delimiter).map(function(M) {
                                    return parseFloat(M)
                                })]
                            }).reduce(function(p, k) {
                                return "matrix" == k[0] ? p.multiply(C(k[1])) : p[k[0]].apply(p, k[1])
                            }, new e.Matrix)
                        },
                        toParent: function(p) {
                            if (this == p) return this;
                            var k = this.screenCTM(),
                                M = p.screenCTM().inverse();
                            return this.addTo(p).untransform().transform(M.multiply(k)), this
                        },
                        toDoc: function() {
                            return this.toParent(this.doc())
                        }
                    }), e.Transformation = e.invent({
                        create: function(p, k) {
                            if (arguments.length > 1 && "boolean" != typeof k) return this.constructor.call(this, [].slice.call(arguments));
                            if (Array.isArray(p))
                                for (var M = 0, D = this.arguments.length; M < D; ++M) this[this.arguments[M]] = p[M];
                            else if (p && "object" === Zt(p))
                                for (M = 0, D = this.arguments.length; M < D; ++M) this[this.arguments[M]] = p[this.arguments[M]];
                            this.inversed = !1, !0 === k && (this.inversed = !0)
                        }
                    }), e.Translate = e.invent({
                        parent: e.Matrix,
                        inherit: e.Transformation,
                        create: function(p, k) {
                            this.constructor.apply(this, [].slice.call(arguments))
                        },
                        extend: {
                            arguments: ["transformedX", "transformedY"],
                            method: "translate"
                        }
                    }), e.extend(e.Element, {
                        style: function(p, k) {
                            if (0 == arguments.length) return this.node.style.cssText || "";
                            if (arguments.length < 2)
                                if ("object" === Zt(p))
                                    for (var M in p) this.style(M, p[M]);
                                else {
                                    if (!e.regex.isCss.test(p)) return this.node.style[x(p)];
                                    for (p = p.split(/\s*;\s*/).filter(function(D) {
                                            return !!D
                                        }).map(function(D) {
                                            return D.split(/\s*:\s*/)
                                        }); k = p.pop();) this.style(k[0], k[1])
                                }
                            else this.node.style[x(p)] = null === k || e.regex.isBlank.test(k) ? "" : k;
                            return this
                        }
                    }), e.Parent = e.invent({
                        create: function(p) {
                            this.constructor.call(this, p)
                        },
                        inherit: e.Element,
                        extend: {
                            children: function() {
                                return e.utils.map(e.utils.filterSVGElements(this.node.childNodes), function(p) {
                                    return e.adopt(p)
                                })
                            },
                            add: function(p, k) {
                                return null == k ? this.node.appendChild(p.node) : p.node != this.node.childNodes[k] && this.node.insertBefore(p.node, this.node.childNodes[k]), this
                            },
                            put: function(p, k) {
                                return this.add(p, k), p
                            },
                            has: function(p) {
                                return this.index(p) >= 0
                            },
                            index: function(p) {
                                return [].slice.call(this.node.childNodes).indexOf(p.node)
                            },
                            get: function(p) {
                                return e.adopt(this.node.childNodes[p])
                            },
                            first: function() {
                                return this.get(0)
                            },
                            last: function() {
                                return this.get(this.node.childNodes.length - 1)
                            },
                            each: function(p, k) {
                                for (var M = this.children(), D = 0, X = M.length; D < X; D++) M[D] instanceof e.Element && p.apply(M[D], [D, M]), k && M[D] instanceof e.Container && M[D].each(p, k);
                                return this
                            },
                            removeElement: function(p) {
                                return this.node.removeChild(p.node), this
                            },
                            clear: function() {
                                for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                return delete this._defs, this
                            },
                            defs: function() {
                                return this.doc().defs()
                            }
                        }
                    }), e.extend(e.Parent, {
                        ungroup: function(p, k) {
                            return 0 === k || this instanceof e.Defs || this.node == e.parser.draw || (p = p || (this instanceof e.Doc ? this : this.parent(e.Parent)), k = k || 1 / 0, this.each(function() {
                                return this instanceof e.Defs ? this : this instanceof e.Parent ? this.ungroup(p, k - 1) : this.toParent(p)
                            }), this.node.firstChild || this.remove()), this
                        },
                        flatten: function(p, k) {
                            return this.ungroup(p, k)
                        }
                    }), e.Container = e.invent({
                        create: function(p) {
                            this.constructor.call(this, p)
                        },
                        inherit: e.Parent
                    }), e.ViewBox = e.invent({
                        parent: e.Container,
                        construct: {}
                    }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(p) {
                        e.Element.prototype[p] = function(k) {
                            return e.on(this.node, p, k), this
                        }
                    }), e.listeners = [], e.handlerMap = [], e.listenerId = 0, e.on = function(p, k, M, D, X) {
                        var H = M.bind(D || p.instance || p),
                            j = (e.handlerMap.indexOf(p) + 1 || e.handlerMap.push(p)) - 1,
                            U = k.split(".")[0],
                            Q = k.split(".")[1] || "*";
                        e.listeners[j] = e.listeners[j] || {}, e.listeners[j][U] = e.listeners[j][U] || {}, e.listeners[j][U][Q] = e.listeners[j][U][Q] || {}, M._svgjsListenerId || (M._svgjsListenerId = ++e.listenerId), e.listeners[j][U][Q][M._svgjsListenerId] = H, p.addEventListener(U, H, X || {
                            passive: !0
                        })
                    }, e.off = function(p, k, M) {
                        var D = e.handlerMap.indexOf(p),
                            X = k && k.split(".")[0],
                            H = k && k.split(".")[1],
                            j = "";
                        if (-1 != D)
                            if (M) {
                                if ("function" == typeof M && (M = M._svgjsListenerId), !M) return;
                                e.listeners[D][X] && e.listeners[D][X][H || "*"] && (p.removeEventListener(X, e.listeners[D][X][H || "*"][M], !1), delete e.listeners[D][X][H || "*"][M])
                            } else if (H && X) {
                            if (e.listeners[D][X] && e.listeners[D][X][H]) {
                                for (var U in e.listeners[D][X][H]) e.off(p, [X, H].join("."), U);
                                delete e.listeners[D][X][H]
                            }
                        } else if (H)
                            for (var Q in e.listeners[D])
                                for (var j in e.listeners[D][Q]) H === j && e.off(p, [Q, H].join("."));
                        else if (X) {
                            if (e.listeners[D][X]) {
                                for (var j in e.listeners[D][X]) e.off(p, [X, j].join("."));
                                delete e.listeners[D][X]
                            }
                        } else {
                            for (var Q in e.listeners[D]) e.off(p, Q);
                            delete e.listeners[D], delete e.handlerMap[D]
                        }
                    }, e.extend(e.Element, {
                        on: function(p, k, M, D) {
                            return e.on(this.node, p, k, M, D), this
                        },
                        off: function(p, k) {
                            return e.off(this.node, p, k), this
                        },
                        fire: function(p, k) {
                            return this.node.dispatchEvent(p instanceof _.Event ? p : p = new e.CustomEvent(p, {
                                detail: k,
                                cancelable: !0
                            })), this._event = p, this
                        },
                        event: function() {
                            return this._event
                        }
                    }), e.Defs = e.invent({
                        create: "defs",
                        inherit: e.Container
                    }), e.G = e.invent({
                        create: "g",
                        inherit: e.Container,
                        extend: {
                            x: function(p) {
                                return null == p ? this.transform("x") : this.transform({
                                    x: p - this.x()
                                }, !0)
                            }
                        },
                        construct: {
                            group: function() {
                                return this.put(new e.G)
                            }
                        }
                    }), e.Doc = e.invent({
                        create: function(p) {
                            p && ("svg" == (p = "string" == typeof p ? t.getElementById(p) : p).nodeName ? this.constructor.call(this, p) : (this.constructor.call(this, e.create("svg")), p.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
                        },
                        inherit: e.Container,
                        extend: {
                            namespace: function() {
                                return this.attr({
                                    xmlns: e.ns,
                                    version: "1.1"
                                }).attr("xmlns:xlink", e.xlink, e.xmlns).attr("xmlns:svgjs", e.svgjs, e.xmlns)
                            },
                            defs: function() {
                                var p;
                                return this._defs || (this._defs = (p = this.node.getElementsByTagName("defs")[0]) ? e.adopt(p) : new e.Defs, this.node.appendChild(this._defs.node)), this._defs
                            },
                            parent: function() {
                                return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                            },
                            remove: function() {
                                return this.parent() && this.parent().removeChild(this.node), this
                            },
                            clear: function() {
                                for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                return delete this._defs, e.parser.draw && !e.parser.draw.parentNode && this.node.appendChild(e.parser.draw), this
                            },
                            clone: function(p) {
                                this.writeDataToDom();
                                var k = this.node,
                                    M = P(k.cloneNode(!0));
                                return p ? (p.node || p).appendChild(M.node) : k.parentNode.insertBefore(M.node, k.nextSibling), M
                            }
                        }
                    }), e.extend(e.Element, {}), e.Gradient = e.invent({
                        create: function(p) {
                            this.constructor.call(this, e.create(p + "Gradient")), this.type = p
                        },
                        inherit: e.Container,
                        extend: {
                            at: function(p, k, M) {
                                return this.put(new e.Stop).update(p, k, M)
                            },
                            update: function(p) {
                                return this.clear(), "function" == typeof p && p.call(this, this), this
                            },
                            fill: function() {
                                return "url(#" + this.id() + ")"
                            },
                            toString: function() {
                                return this.fill()
                            },
                            attr: function(p, k, M) {
                                return "transform" == p && (p = "gradientTransform"), e.Container.prototype.attr.call(this, p, k, M)
                            }
                        },
                        construct: {
                            gradient: function(p, k) {
                                return this.defs().gradient(p, k)
                            }
                        }
                    }), e.extend(e.Gradient, e.FX, {
                        from: function(p, k) {
                            return this.attr("radial" == (this._target || this).type ? {
                                fx: new e.Number(p),
                                fy: new e.Number(k)
                            } : {
                                x1: new e.Number(p),
                                y1: new e.Number(k)
                            })
                        },
                        to: function(p, k) {
                            return this.attr("radial" == (this._target || this).type ? {
                                cx: new e.Number(p),
                                cy: new e.Number(k)
                            } : {
                                x2: new e.Number(p),
                                y2: new e.Number(k)
                            })
                        }
                    }), e.extend(e.Defs, {
                        gradient: function(p, k) {
                            return this.put(new e.Gradient(p)).update(k)
                        }
                    }), e.Stop = e.invent({
                        create: "stop",
                        inherit: e.Element,
                        extend: {
                            update: function(p) {
                                return ("number" == typeof p || p instanceof e.Number) && (p = {
                                    offset: arguments[0],
                                    color: arguments[1],
                                    opacity: arguments[2]
                                }), null != p.opacity && this.attr("stop-opacity", p.opacity), null != p.color && this.attr("stop-color", p.color), null != p.offset && this.attr("offset", new e.Number(p.offset)), this
                            }
                        }
                    }), e.Pattern = e.invent({
                        create: "pattern",
                        inherit: e.Container,
                        extend: {
                            fill: function() {
                                return "url(#" + this.id() + ")"
                            },
                            update: function(p) {
                                return this.clear(), "function" == typeof p && p.call(this, this), this
                            },
                            toString: function() {
                                return this.fill()
                            },
                            attr: function(p, k, M) {
                                return "transform" == p && (p = "patternTransform"), e.Container.prototype.attr.call(this, p, k, M)
                            }
                        },
                        construct: {
                            pattern: function(p, k, M) {
                                return this.defs().pattern(p, k, M)
                            }
                        }
                    }), e.extend(e.Defs, {
                        pattern: function(p, k, M) {
                            return this.put(new e.Pattern).update(M).attr({
                                x: 0,
                                y: 0,
                                width: p,
                                height: k,
                                patternUnits: "userSpaceOnUse"
                            })
                        }
                    }), e.Shape = e.invent({
                        create: function(p) {
                            this.constructor.call(this, p)
                        },
                        inherit: e.Element
                    }), e.Symbol = e.invent({
                        create: "symbol",
                        inherit: e.Container,
                        construct: {
                            symbol: function() {
                                return this.put(new e.Symbol)
                            }
                        }
                    }), e.Use = e.invent({
                        create: "use",
                        inherit: e.Shape,
                        extend: {
                            element: function(p, k) {
                                return this.attr("href", (k || "") + "#" + p, e.xlink)
                            }
                        },
                        construct: {
                            use: function(p, k) {
                                return this.put(new e.Use).element(p, k)
                            }
                        }
                    }), e.Rect = e.invent({
                        create: "rect",
                        inherit: e.Shape,
                        construct: {
                            rect: function(p, k) {
                                return this.put(new e.Rect).size(p, k)
                            }
                        }
                    }), e.Circle = e.invent({
                        create: "circle",
                        inherit: e.Shape,
                        construct: {
                            circle: function(p) {
                                return this.put(new e.Circle).rx(new e.Number(p).divide(2)).move(0, 0)
                            }
                        }
                    }), e.extend(e.Circle, e.FX, {
                        rx: function(p) {
                            return this.attr("r", p)
                        },
                        ry: function(p) {
                            return this.rx(p)
                        }
                    }), e.Ellipse = e.invent({
                        create: "ellipse",
                        inherit: e.Shape,
                        construct: {
                            ellipse: function(p, k) {
                                return this.put(new e.Ellipse).size(p, k).move(0, 0)
                            }
                        }
                    }), e.extend(e.Ellipse, e.Rect, e.FX, {
                        rx: function(p) {
                            return this.attr("rx", p)
                        },
                        ry: function(p) {
                            return this.attr("ry", p)
                        }
                    }), e.extend(e.Circle, e.Ellipse, {
                        x: function(p) {
                            return null == p ? this.cx() - this.rx() : this.cx(p + this.rx())
                        },
                        y: function(p) {
                            return null == p ? this.cy() - this.ry() : this.cy(p + this.ry())
                        },
                        cx: function(p) {
                            return null == p ? this.attr("cx") : this.attr("cx", p)
                        },
                        cy: function(p) {
                            return null == p ? this.attr("cy") : this.attr("cy", p)
                        },
                        width: function(p) {
                            return null == p ? 2 * this.rx() : this.rx(new e.Number(p).divide(2))
                        },
                        height: function(p) {
                            return null == p ? 2 * this.ry() : this.ry(new e.Number(p).divide(2))
                        },
                        size: function(p, k) {
                            var M = w(this, p, k);
                            return this.rx(new e.Number(M.width).divide(2)).ry(new e.Number(M.height).divide(2))
                        }
                    }), e.Line = e.invent({
                        create: "line",
                        inherit: e.Shape,
                        extend: {
                            array: function() {
                                return new e.PointArray([
                                    [this.attr("x1"), this.attr("y1")],
                                    [this.attr("x2"), this.attr("y2")]
                                ])
                            },
                            plot: function(p, k, M, D) {
                                return null == p ? this.array() : (p = void 0 !== k ? {
                                    x1: p,
                                    y1: k,
                                    x2: M,
                                    y2: D
                                } : new e.PointArray(p).toLine(), this.attr(p))
                            },
                            move: function(p, k) {
                                return this.attr(this.array().move(p, k).toLine())
                            },
                            size: function(p, k) {
                                var M = w(this, p, k);
                                return this.attr(this.array().size(M.width, M.height).toLine())
                            }
                        },
                        construct: {
                            line: function(p, k, M, D) {
                                return e.Line.prototype.plot.apply(this.put(new e.Line), null != p ? [p, k, M, D] : [0, 0, 0, 0])
                            }
                        }
                    }), e.Polyline = e.invent({
                        create: "polyline",
                        inherit: e.Shape,
                        construct: {
                            polyline: function(p) {
                                return this.put(new e.Polyline).plot(p || new e.PointArray)
                            }
                        }
                    }), e.Polygon = e.invent({
                        create: "polygon",
                        inherit: e.Shape,
                        construct: {
                            polygon: function(p) {
                                return this.put(new e.Polygon).plot(p || new e.PointArray)
                            }
                        }
                    }), e.extend(e.Polyline, e.Polygon, {
                        array: function() {
                            return this._array || (this._array = new e.PointArray(this.attr("points")))
                        },
                        plot: function(p) {
                            return null == p ? this.array() : this.clear().attr("points", "string" == typeof p ? p : this._array = new e.PointArray(p))
                        },
                        clear: function() {
                            return delete this._array, this
                        },
                        move: function(p, k) {
                            return this.attr("points", this.array().move(p, k))
                        },
                        size: function(p, k) {
                            var M = w(this, p, k);
                            return this.attr("points", this.array().size(M.width, M.height))
                        }
                    }), e.extend(e.Line, e.Polyline, e.Polygon, {
                        morphArray: e.PointArray,
                        x: function(p) {
                            return null == p ? this.bbox().x : this.move(p, this.bbox().y)
                        },
                        y: function(p) {
                            return null == p ? this.bbox().y : this.move(this.bbox().x, p)
                        },
                        width: function(p) {
                            var k = this.bbox();
                            return null == p ? k.width : this.size(p, k.height)
                        },
                        height: function(p) {
                            var k = this.bbox();
                            return null == p ? k.height : this.size(k.width, p)
                        }
                    }), e.Path = e.invent({
                        create: "path",
                        inherit: e.Shape,
                        extend: {
                            morphArray: e.PathArray,
                            array: function() {
                                return this._array || (this._array = new e.PathArray(this.attr("d")))
                            },
                            plot: function(p) {
                                return null == p ? this.array() : this.clear().attr("d", "string" == typeof p ? p : this._array = new e.PathArray(p))
                            },
                            clear: function() {
                                return delete this._array, this
                            }
                        },
                        construct: {
                            path: function(p) {
                                return this.put(new e.Path).plot(p || new e.PathArray)
                            }
                        }
                    }), e.Image = e.invent({
                        create: "image",
                        inherit: e.Shape,
                        extend: {
                            load: function(p) {
                                if (!p) return this;
                                var k = this,
                                    M = new _.Image;
                                return e.on(M, "load", function() {
                                    e.off(M);
                                    var D = k.parent(e.Pattern);
                                    null !== D && (0 == k.width() && 0 == k.height() && k.size(M.width, M.height), D && 0 == D.width() && 0 == D.height() && D.size(k.width(), k.height()), "function" == typeof k._loaded && k._loaded.call(k, {
                                        width: M.width,
                                        height: M.height,
                                        ratio: M.width / M.height,
                                        url: p
                                    }))
                                }), e.on(M, "error", function(D) {
                                    e.off(M), "function" == typeof k._error && k._error.call(k, D)
                                }), this.attr("href", M.src = this.src = p, e.xlink)
                            },
                            loaded: function(p) {
                                return this._loaded = p, this
                            },
                            error: function(p) {
                                return this._error = p, this
                            }
                        },
                        construct: {
                            image: function(p, k, M) {
                                return this.put(new e.Image).load(p).size(k || 0, M || k || 0)
                            }
                        }
                    }), e.Text = e.invent({
                        create: function() {
                            this.constructor.call(this, e.create("text")), this.dom.leading = new e.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", e.defaults.attrs["font-family"])
                        },
                        inherit: e.Shape,
                        extend: {
                            x: function(p) {
                                return null == p ? this.attr("x") : this.attr("x", p)
                            },
                            text: function(p) {
                                if (void 0 === p) {
                                    p = "";
                                    for (var k = this.node.childNodes, M = 0, D = k.length; M < D; ++M) 0 != M && 3 != k[M].nodeType && 1 == e.adopt(k[M]).dom.newLined && (p += "\n"), p += k[M].textContent;
                                    return p
                                }
                                if (this.clear().build(!0), "function" == typeof p) p.call(this, this);
                                else {
                                    M = 0;
                                    for (var X = (p = p.split("\n")).length; M < X; M++) this.tspan(p[M]).newLine()
                                }
                                return this.build(!1).rebuild()
                            },
                            size: function(p) {
                                return this.attr("font-size", p).rebuild()
                            },
                            leading: function(p) {
                                return null == p ? this.dom.leading : (this.dom.leading = new e.Number(p), this.rebuild())
                            },
                            lines: function() {
                                var p = (this.textPath && this.textPath() || this).node,
                                    k = e.utils.map(e.utils.filterSVGElements(p.childNodes), function(M) {
                                        return e.adopt(M)
                                    });
                                return new e.Set(k)
                            },
                            rebuild: function(p) {
                                if ("boolean" == typeof p && (this._rebuild = p), this._rebuild) {
                                    var k = this,
                                        M = 0,
                                        D = this.dom.leading * new e.Number(this.attr("font-size"));
                                    this.lines().each(function() {
                                        this.dom.newLined && (k.textPath() || this.attr("x", k.attr("x")), "\n" == this.text() ? M += D : (this.attr("dy", D + M), M = 0))
                                    }), this.fire("rebuild")
                                }
                                return this
                            },
                            build: function(p) {
                                return this._build = !!p, this
                            },
                            setData: function(p) {
                                return this.dom = p, this.dom.leading = new e.Number(p.leading || 1.3), this
                            }
                        },
                        construct: {
                            text: function(p) {
                                return this.put(new e.Text).text(p)
                            },
                            plain: function(p) {
                                return this.put(new e.Text).plain(p)
                            }
                        }
                    }), e.Tspan = e.invent({
                        create: "tspan",
                        inherit: e.Shape,
                        extend: {
                            text: function(p) {
                                return null == p ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof p ? p.call(this, this) : this.plain(p), this)
                            },
                            dx: function(p) {
                                return this.attr("dx", p)
                            },
                            dy: function(p) {
                                return this.attr("dy", p)
                            },
                            newLine: function() {
                                var p = this.parent(e.Text);
                                return this.dom.newLined = !0, this.dy(p.dom.leading * p.attr("font-size")).attr("x", p.x())
                            }
                        }
                    }), e.extend(e.Text, e.Tspan, {
                        plain: function(p) {
                            return !1 === this._build && this.clear(), this.node.appendChild(t.createTextNode(p)), this
                        },
                        tspan: function(p) {
                            var k = (this.textPath && this.textPath() || this).node,
                                M = new e.Tspan;
                            return !1 === this._build && this.clear(), k.appendChild(M.node), M.text(p)
                        },
                        clear: function() {
                            for (var p = (this.textPath && this.textPath() || this).node; p.hasChildNodes();) p.removeChild(p.lastChild);
                            return this
                        },
                        length: function() {
                            return this.node.getComputedTextLength()
                        }
                    }), e.TextPath = e.invent({
                        create: "textPath",
                        inherit: e.Parent,
                        parent: e.Text,
                        construct: {
                            morphArray: e.PathArray,
                            array: function() {
                                var p = this.track();
                                return p ? p.array() : null
                            },
                            plot: function(p) {
                                var k = this.track(),
                                    M = null;
                                return k && (M = k.plot(p)), null == p ? M : this
                            },
                            track: function() {
                                var p = this.textPath();
                                if (p) return p.reference("href")
                            },
                            textPath: function() {
                                if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return e.adopt(this.node.firstChild)
                            }
                        }
                    }), e.Nested = e.invent({
                        create: function() {
                            this.constructor.call(this, e.create("svg")), this.style("overflow", "visible")
                        },
                        inherit: e.Container,
                        construct: {
                            nested: function() {
                                return this.put(new e.Nested)
                            }
                        }
                    });
                    var d = {
                        stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
                        fill: ["color", "opacity", "rule"],
                        prefix: function(p, k) {
                            return "color" == k ? p : p + "-" + k
                        }
                    };

                    function g(p, k, M, D) {
                        return M + D.replace(e.regex.dots, " .")
                    }

                    function x(p) {
                        return p.toLowerCase().replace(/-(.)/g, function(k, M) {
                            return M.toUpperCase()
                        })
                    }

                    function b(p) {
                        return p.charAt(0).toUpperCase() + p.slice(1)
                    }

                    function v(p) {
                        var k = p.toString(16);
                        return 1 == k.length ? "0" + k : k
                    }

                    function w(p, k, M) {
                        if (null == k || null == M) {
                            var D = p.bbox();
                            null == k ? k = D.width / D.height * M : null == M && (M = D.height / D.width * k)
                        }
                        return {
                            width: k,
                            height: M
                        }
                    }

                    function S(p, k, M) {
                        return {
                            x: k * p.a + M * p.c + 0,
                            y: k * p.b + M * p.d + 0
                        }
                    }

                    function C(p) {
                        return {
                            a: p[0],
                            b: p[1],
                            c: p[2],
                            d: p[3],
                            e: p[4],
                            f: p[5]
                        }
                    }

                    function P(p) {
                        for (var k = p.childNodes.length - 1; k >= 0; k--) p.childNodes[k] instanceof _.SVGElement && P(p.childNodes[k]);
                        return e.adopt(p).id(e.eid(p.nodeName))
                    }

                    function T(p) {
                        return Math.abs(p) > 1e-37 ? p : 0
                    }["fill", "stroke"].forEach(function(p) {
                        var k = {};
                        k[p] = function(M) {
                            if (void 0 === M) return this;
                            if ("string" == typeof M || e.Color.isRgb(M) || M && "function" == typeof M.fill) this.attr(p, M);
                            else
                                for (var D = d[p].length - 1; D >= 0; D--) null != M[d[p][D]] && this.attr(d.prefix(p, d[p][D]), M[d[p][D]]);
                            return this
                        }, e.extend(e.Element, e.FX, k)
                    }), e.extend(e.Element, e.FX, {
                        translate: function(p, k) {
                            return this.transform({
                                x: p,
                                y: k
                            })
                        },
                        matrix: function(p) {
                            return this.attr("transform", new e.Matrix(6 == arguments.length ? [].slice.call(arguments) : p))
                        },
                        opacity: function(p) {
                            return this.attr("opacity", p)
                        },
                        dx: function(p) {
                            return this.x(new e.Number(p).plus(this instanceof e.FX ? 0 : this.x()), !0)
                        },
                        dy: function(p) {
                            return this.y(new e.Number(p).plus(this instanceof e.FX ? 0 : this.y()), !0)
                        }
                    }), e.extend(e.Path, {
                        length: function() {
                            return this.node.getTotalLength()
                        },
                        pointAt: function(p) {
                            return this.node.getPointAtLength(p)
                        }
                    }), e.Set = e.invent({
                        create: function(p) {
                            Array.isArray(p) ? this.members = p : this.clear()
                        },
                        extend: {
                            add: function() {
                                for (var p = [].slice.call(arguments), k = 0, M = p.length; k < M; k++) this.members.push(p[k]);
                                return this
                            },
                            remove: function(p) {
                                var k = this.index(p);
                                return k > -1 && this.members.splice(k, 1), this
                            },
                            each: function(p) {
                                for (var k = 0, M = this.members.length; k < M; k++) p.apply(this.members[k], [k, this.members]);
                                return this
                            },
                            clear: function() {
                                return this.members = [], this
                            },
                            length: function() {
                                return this.members.length
                            },
                            has: function(p) {
                                return this.index(p) >= 0
                            },
                            index: function(p) {
                                return this.members.indexOf(p)
                            },
                            get: function(p) {
                                return this.members[p]
                            },
                            first: function() {
                                return this.get(0)
                            },
                            last: function() {
                                return this.get(this.members.length - 1)
                            },
                            valueOf: function() {
                                return this.members
                            }
                        },
                        construct: {
                            set: function(p) {
                                return new e.Set(p)
                            }
                        }
                    }), e.FX.Set = e.invent({
                        create: function(p) {
                            this.set = p
                        }
                    }), e.Set.inherit = function() {
                        var p = [];
                        for (var k in e.Shape.prototype) "function" == typeof e.Shape.prototype[k] && "function" != typeof e.Set.prototype[k] && p.push(k);
                        for (var k in p.forEach(function(D) {
                                e.Set.prototype[D] = function() {
                                    for (var X = 0, H = this.members.length; X < H; X++) this.members[X] && "function" == typeof this.members[X][D] && this.members[X][D].apply(this.members[X], arguments);
                                    return "animate" == D ? this.fx || (this.fx = new e.FX.Set(this)) : this
                                }
                            }), p = [], e.FX.prototype) "function" == typeof e.FX.prototype[k] && "function" != typeof e.FX.Set.prototype[k] && p.push(k);
                        p.forEach(function(M) {
                            e.FX.Set.prototype[M] = function() {
                                for (var D = 0, X = this.set.members.length; D < X; D++) this.set.members[D].fx[M].apply(this.set.members[D].fx, arguments);
                                return this
                            }
                        })
                    }, e.extend(e.Element, {}), e.extend(e.Element, {
                        remember: function(p, k) {
                            if ("object" === Zt(arguments[0]))
                                for (var M in p) this.remember(M, p[M]);
                            else {
                                if (1 == arguments.length) return this.memory()[p];
                                this.memory()[p] = k
                            }
                            return this
                        },
                        forget: function() {
                            if (0 == arguments.length) this._memory = {};
                            else
                                for (var p = arguments.length - 1; p >= 0; p--) delete this.memory()[arguments[p]];
                            return this
                        },
                        memory: function() {
                            return this._memory || (this._memory = {})
                        }
                    }), e.get = function(p) {
                        var k = t.getElementById(function(M) {
                            var D = (M || "").toString().match(e.regex.reference);
                            if (D) return D[1]
                        }(p) || p);
                        return e.adopt(k)
                    }, e.select = function(p, k) {
                        return new e.Set(e.utils.map((k || t).querySelectorAll(p), function(M) {
                            return e.adopt(M)
                        }))
                    }, e.extend(e.Parent, {
                        select: function(p) {
                            return e.select(p, this.node)
                        }
                    });
                    var I = "abcdef".split("");
                    if ("function" != typeof _.CustomEvent) {
                        var R = function(p, k) {
                            k = k || {
                                bubbles: !1,
                                cancelable: !1,
                                detail: void 0
                            };
                            var M = t.createEvent("CustomEvent");
                            return M.initCustomEvent(p, k.bubbles, k.cancelable, k.detail), M
                        };
                        R.prototype = _.Event.prototype, e.CustomEvent = R
                    } else e.CustomEvent = _.CustomEvent;
                    return e
                }, void 0 !== (_t = function() {
                    return gt(kt, kt.document)
                }.call(je, Nt, je, Mi)) && (Mi.exports = _t),
                /*! svg.filter.js - v2.0.2 - 2016-02-24
                 * https://github.com/wout/svg.filter.js
                 * Copyright (c) 2016 Wout Fierens; Licensed MIT */
                function() {
                    SVG.Filter = SVG.invent({
                        create: "filter",
                        inherit: SVG.Parent,
                        extend: {
                            source: "SourceGraphic",
                            sourceAlpha: "SourceAlpha",
                            background: "BackgroundImage",
                            backgroundAlpha: "BackgroundAlpha",
                            fill: "FillPaint",
                            stroke: "StrokePaint",
                            autoSetIn: !0,
                            put: function(h, d) {
                                return this.add(h, d), !h.attr("in") && this.autoSetIn && h.attr("in", this.source), h.attr("result") || h.attr("result", h), h
                            },
                            blend: function(h, d, g) {
                                return this.put(new SVG.BlendEffect(h, d, g))
                            },
                            colorMatrix: function(h, d) {
                                return this.put(new SVG.ColorMatrixEffect(h, d))
                            },
                            convolveMatrix: function(h) {
                                return this.put(new SVG.ConvolveMatrixEffect(h))
                            },
                            componentTransfer: function(h) {
                                return this.put(new SVG.ComponentTransferEffect(h))
                            },
                            composite: function(h, d, g) {
                                return this.put(new SVG.CompositeEffect(h, d, g))
                            },
                            flood: function(h, d) {
                                return this.put(new SVG.FloodEffect(h, d))
                            },
                            offset: function(h, d) {
                                return this.put(new SVG.OffsetEffect(h, d))
                            },
                            image: function(h) {
                                return this.put(new SVG.ImageEffect(h))
                            },
                            merge: function() {
                                var h = [void 0];
                                for (var d in arguments) h.push(arguments[d]);
                                return this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect, h)))
                            },
                            gaussianBlur: function(h, d) {
                                return this.put(new SVG.GaussianBlurEffect(h, d))
                            },
                            morphology: function(h, d) {
                                return this.put(new SVG.MorphologyEffect(h, d))
                            },
                            diffuseLighting: function(h, d, g) {
                                return this.put(new SVG.DiffuseLightingEffect(h, d, g))
                            },
                            displacementMap: function(h, d, g, x, b) {
                                return this.put(new SVG.DisplacementMapEffect(h, d, g, x, b))
                            },
                            specularLighting: function(h, d, g, x) {
                                return this.put(new SVG.SpecularLightingEffect(h, d, g, x))
                            },
                            tile: function() {
                                return this.put(new SVG.TileEffect)
                            },
                            turbulence: function(h, d, g, x, b) {
                                return this.put(new SVG.TurbulenceEffect(h, d, g, x, b))
                            },
                            toString: function() {
                                return "url(#" + this.attr("id") + ")"
                            }
                        }
                    }), SVG.extend(SVG.Defs, {
                        filter: function(h) {
                            var d = this.put(new SVG.Filter);
                            return "function" == typeof h && h.call(d, d), d
                        }
                    }), SVG.extend(SVG.Container, {
                        filter: function(h) {
                            return this.defs().filter(h)
                        }
                    }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
                        filter: function(h) {
                            return this.filterer = h instanceof SVG.Element ? h : this.doc().filter(h), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
                        },
                        unfilter: function(h) {
                            return this.filterer && !0 === h && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
                        }
                    }), SVG.Effect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Element,
                        extend: { in: function(h) {
                                return null == h ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", h)
                            },
                            result: function(h) {
                                return null == h ? this.attr("result") : this.attr("result", h)
                            },
                            toString: function() {
                                return this.result()
                            }
                        }
                    }), SVG.ParentEffect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Parent,
                        extend: { in: function(h) {
                                return null == h ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", h)
                            },
                            result: function(h) {
                                return null == h ? this.attr("result") : this.attr("result", h)
                            },
                            toString: function() {
                                return this.result()
                            }
                        }
                    });
                    var _ = {
                        blend: function(h, d) {
                            return this.parent() && this.parent().blend(this, h, d)
                        },
                        colorMatrix: function(h, d) {
                            return this.parent() && this.parent().colorMatrix(h, d).in(this)
                        },
                        convolveMatrix: function(h) {
                            return this.parent() && this.parent().convolveMatrix(h).in(this)
                        },
                        componentTransfer: function(h) {
                            return this.parent() && this.parent().componentTransfer(h).in(this)
                        },
                        composite: function(h, d) {
                            return this.parent() && this.parent().composite(this, h, d)
                        },
                        flood: function(h, d) {
                            return this.parent() && this.parent().flood(h, d)
                        },
                        offset: function(h, d) {
                            return this.parent() && this.parent().offset(h, d).in(this)
                        },
                        image: function(h) {
                            return this.parent() && this.parent().image(h)
                        },
                        merge: function() {
                            return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
                        },
                        gaussianBlur: function(h, d) {
                            return this.parent() && this.parent().gaussianBlur(h, d).in(this)
                        },
                        morphology: function(h, d) {
                            return this.parent() && this.parent().morphology(h, d).in(this)
                        },
                        diffuseLighting: function(h, d, g) {
                            return this.parent() && this.parent().diffuseLighting(h, d, g).in(this)
                        },
                        displacementMap: function(h, d, g, x) {
                            return this.parent() && this.parent().displacementMap(this, h, d, g, x)
                        },
                        specularLighting: function(h, d, g, x) {
                            return this.parent() && this.parent().specularLighting(h, d, g, x).in(this)
                        },
                        tile: function() {
                            return this.parent() && this.parent().tile().in(this)
                        },
                        turbulence: function(h, d, g, x, b) {
                            return this.parent() && this.parent().turbulence(h, d, g, x, b).in(this)
                        }
                    };
                    SVG.extend(SVG.Effect, _), SVG.extend(SVG.ParentEffect, _), SVG.ChildEffect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Element,
                        extend: { in: function(h) {
                                this.attr("in", h)
                            }
                        }
                    });
                    var t = {
                            blend: function(h, d, g) {
                                this.attr({ in: h,
                                    in2: d,
                                    mode: g || "normal"
                                })
                            },
                            colorMatrix: function(h, d) {
                                "matrix" == h && (d = r(d)), this.attr({
                                    type: h,
                                    values: void 0 === d ? null : d
                                })
                            },
                            convolveMatrix: function(h) {
                                h = r(h), this.attr({
                                    order: Math.sqrt(h.split(" ").length),
                                    kernelMatrix: h
                                })
                            },
                            composite: function(h, d, g) {
                                this.attr({ in: h,
                                    in2: d,
                                    operator: g
                                })
                            },
                            flood: function(h, d) {
                                this.attr("flood-color", h), null != d && this.attr("flood-opacity", d)
                            },
                            offset: function(h, d) {
                                this.attr({
                                    dx: h,
                                    dy: d
                                })
                            },
                            image: function(h) {
                                this.attr("href", h, SVG.xlink)
                            },
                            displacementMap: function(h, d, g, x, b) {
                                this.attr({ in: h,
                                    in2: d,
                                    scale: g,
                                    xChannelSelector: x,
                                    yChannelSelector: b
                                })
                            },
                            gaussianBlur: function(h, d) {
                                this.attr("stdDeviation", null != h || null != d ? function(g) {
                                    if (!Array.isArray(g)) return g;
                                    for (var x = 0, b = g.length, v = []; x < b; x++) v.push(g[x]);
                                    return v.join(" ")
                                }(Array.prototype.slice.call(arguments)) : "0 0")
                            },
                            morphology: function(h, d) {
                                this.attr({
                                    operator: h,
                                    radius: d
                                })
                            },
                            tile: function() {},
                            turbulence: function(h, d, g, x, b) {
                                this.attr({
                                    numOctaves: d,
                                    seed: g,
                                    stitchTiles: x,
                                    baseFrequency: h,
                                    type: b
                                })
                            }
                        },
                        e = {
                            merge: function() {
                                var h;
                                if (arguments[0] instanceof SVG.Set) {
                                    var d = this;
                                    arguments[0].each(function(x) {
                                        this instanceof SVG.MergeNode ? d.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && d.put(new SVG.MergeNode(this))
                                    })
                                } else {
                                    h = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                                    for (var g = 0; g < h.length; g++) h[g] instanceof SVG.MergeNode ? this.put(h[g]) : this.put(new SVG.MergeNode(h[g]))
                                }
                            },
                            componentTransfer: function(h) {
                                if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach(function(g) {
                                        this[g] = new(SVG["Func" + g.toUpperCase()])("identity"), this.rgb.add(this[g]), this.node.appendChild(this[g].node)
                                    }.bind(this)), h)
                                    for (var d in h.rgb && (["r", "g", "b"].forEach(function(g) {
                                            this[g].attr(h.rgb)
                                        }.bind(this)), delete h.rgb), h) this[d].attr(h[d])
                            },
                            diffuseLighting: function(h, d, g) {
                                this.attr({
                                    surfaceScale: h,
                                    diffuseConstant: d,
                                    kernelUnitLength: g
                                })
                            },
                            specularLighting: function(h, d, g, x) {
                                this.attr({
                                    surfaceScale: h,
                                    diffuseConstant: d,
                                    specularExponent: g,
                                    kernelUnitLength: x
                                })
                            }
                        },
                        i = {
                            distantLight: function(h, d) {
                                this.attr({
                                    azimuth: h,
                                    elevation: d
                                })
                            },
                            pointLight: function(h, d, g) {
                                this.attr({
                                    x: h,
                                    y: d,
                                    z: g
                                })
                            },
                            spotLight: function(h, d, g, x, b, v) {
                                this.attr({
                                    x: h,
                                    y: d,
                                    z: g,
                                    pointsAtX: x,
                                    pointsAtY: b,
                                    pointsAtZ: v
                                })
                            },
                            mergeNode: function(h) {
                                this.attr("in", h)
                            }
                        };

                    function r(h) {
                        return Array.isArray(h) && (h = new SVG.Array(h)), h.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
                    }

                    function l() {
                        var h = function() {};
                        for (var d in "function" == typeof arguments[arguments.length - 1] && (h = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
                            for (var g in arguments[d]) h(arguments[d][g], g, arguments[d])
                    }["r", "g", "b", "a"].forEach(function(h) {
                        i["Func" + h.toUpperCase()] = function(d) {
                            switch (this.attr("type", d), d) {
                                case "table":
                                    this.attr("tableValues", arguments[1]);
                                    break;
                                case "linear":
                                    this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                                    break;
                                case "gamma":
                                    this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
                            }
                        }
                    }), l(t, function(h, d) {
                        var g = d.charAt(0).toUpperCase() + d.slice(1);
                        SVG[g + "Effect"] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + g)), h.apply(this, arguments), this.result(this.attr("id") + "Out")
                            },
                            inherit: SVG.Effect,
                            extend: {}
                        })
                    }), l(e, function(h, d) {
                        var g = d.charAt(0).toUpperCase() + d.slice(1);
                        SVG[g + "Effect"] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + g)), h.apply(this, arguments), this.result(this.attr("id") + "Out")
                            },
                            inherit: SVG.ParentEffect,
                            extend: {}
                        })
                    }), l(i, function(h, d) {
                        var g = d.charAt(0).toUpperCase() + d.slice(1);
                        SVG[g] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + g)), h.apply(this, arguments)
                            },
                            inherit: SVG.ChildEffect,
                            extend: {}
                        })
                    }), SVG.extend(SVG.MergeEffect, { in: function(h) {
                            return h instanceof SVG.MergeNode ? this.add(h, 0) : this.add(new SVG.MergeNode(h), 0), this
                        }
                    }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
                        in2: function(h) {
                            return null == h ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", h)
                        }
                    }), SVG.filter = {
                        sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
                    }
                }.call(void 0),
                function() {
                    function _(l, h, d, g, x, b, v) {
                        for (var w = l.slice(h, d || v), S = g.slice(x, b || v), C = 0, P = {
                                pos: [0, 0],
                                start: [0, 0]
                            }, T = {
                                pos: [0, 0],
                                start: [0, 0]
                            }; w[C] = t.call(P, w[C]), S[C] = t.call(T, S[C]), w[C][0] != S[C][0] || "M" == w[C][0] || "A" == w[C][0] && (w[C][4] != S[C][4] || w[C][5] != S[C][5]) ? (Array.prototype.splice.apply(w, [C, 1].concat(i.call(P, w[C]))), Array.prototype.splice.apply(S, [C, 1].concat(i.call(T, S[C])))) : (w[C] = e.call(P, w[C]), S[C] = e.call(T, S[C])), ++C != w.length || C != S.length;) C == w.length && w.push(["C", P.pos[0], P.pos[1], P.pos[0], P.pos[1], P.pos[0], P.pos[1]]), C == S.length && S.push(["C", T.pos[0], T.pos[1], T.pos[0], T.pos[1], T.pos[0], T.pos[1]]);
                        return {
                            start: w,
                            dest: S
                        }
                    }

                    function t(l) {
                        switch (l[0]) {
                            case "z":
                            case "Z":
                                l[0] = "L", l[1] = this.start[0], l[2] = this.start[1];
                                break;
                            case "H":
                                l[0] = "L", l[2] = this.pos[1];
                                break;
                            case "V":
                                l[0] = "L", l[2] = l[1], l[1] = this.pos[0];
                                break;
                            case "T":
                                l[0] = "Q", l[3] = l[1], l[4] = l[2], l[1] = this.reflection[1], l[2] = this.reflection[0];
                                break;
                            case "S":
                                l[0] = "C", l[6] = l[4], l[5] = l[3], l[4] = l[2], l[3] = l[1], l[2] = this.reflection[1], l[1] = this.reflection[0]
                        }
                        return l
                    }

                    function e(l) {
                        var h = l.length;
                        return this.pos = [l[h - 2], l[h - 1]], -1 != "SCQT".indexOf(l[0]) && (this.reflection = [2 * this.pos[0] - l[h - 4], 2 * this.pos[1] - l[h - 3]]), l
                    }

                    function i(l) {
                        var h = [l];
                        switch (l[0]) {
                            case "M":
                                return this.pos = this.start = [l[1], l[2]], h;
                            case "L":
                                l[5] = l[3] = l[1], l[6] = l[4] = l[2], l[1] = this.pos[0], l[2] = this.pos[1];
                                break;
                            case "Q":
                                l[6] = l[4], l[5] = l[3], l[4] = 1 * l[4] / 3 + 2 * l[2] / 3, l[3] = 1 * l[3] / 3 + 2 * l[1] / 3, l[2] = 1 * this.pos[1] / 3 + 2 * l[2] / 3, l[1] = 1 * this.pos[0] / 3 + 2 * l[1] / 3;
                                break;
                            case "A":
                                l = (h = function(d, g) {
                                    var x, b, v, w, S, C, P, T, I, R, p, k, M, D, X, H, j, U, Q, at, it, mt, yt, Pt, Dt, Vt, ee = Math.abs(g[1]),
                                        ie = Math.abs(g[2]),
                                        Kt = g[3] % 360,
                                        Ce = g[4],
                                        De = g[5],
                                        Li = g[6],
                                        Ji = g[7],
                                        Xt = new SVG.Point(d),
                                        fe = new SVG.Point(Li, Ji),
                                        _i = [];
                                    if (0 === ee || 0 === ie || Xt.x === fe.x && Xt.y === fe.y) return [
                                        ["C", Xt.x, Xt.y, fe.x, fe.y, fe.x, fe.y]
                                    ];
                                    for ((b = (x = new SVG.Point((Xt.x - fe.x) / 2, (Xt.y - fe.y) / 2).transform((new SVG.Matrix).rotate(Kt))).x * x.x / (ee * ee) + x.y * x.y / (ie * ie)) > 1 && (ee *= b = Math.sqrt(b), ie *= b), v = (new SVG.Matrix).rotate(Kt).scale(1 / ee, 1 / ie).rotate(-Kt), Xt = Xt.transform(v), C = (w = [(fe = fe.transform(v)).x - Xt.x, fe.y - Xt.y])[0] * w[0] + w[1] * w[1], S = Math.sqrt(C), w[0] /= S, w[1] /= S, P = C < 4 ? Math.sqrt(1 - C / 4) : 0, Ce === De && (P *= -1), T = new SVG.Point((fe.x + Xt.x) / 2 + P * -w[1], (fe.y + Xt.y) / 2 + P * w[0]), I = new SVG.Point(Xt.x - T.x, Xt.y - T.y), R = new SVG.Point(fe.x - T.x, fe.y - T.y), p = Math.acos(I.x / Math.sqrt(I.x * I.x + I.y * I.y)), I.y < 0 && (p *= -1), k = Math.acos(R.x / Math.sqrt(R.x * R.x + R.y * R.y)), R.y < 0 && (k *= -1), De && p > k && (k += 2 * Math.PI), !De && p < k && (k -= 2 * Math.PI), H = [], j = p, M = (k - p) / (D = Math.ceil(2 * Math.abs(p - k) / Math.PI)), X = 4 * Math.tan(M / 4) / 3, it = 0; it <= D; it++) Q = Math.cos(j), U = Math.sin(j), at = new SVG.Point(T.x + Q, T.y + U), H[it] = [new SVG.Point(at.x + X * U, at.y - X * Q), at, new SVG.Point(at.x - X * U, at.y + X * Q)], j += M;
                                    for (H[0][0] = H[0][1].clone(), H[H.length - 1][2] = H[H.length - 1][1].clone(), v = (new SVG.Matrix).rotate(Kt).scale(ee, ie).rotate(-Kt), it = 0, mt = H.length; it < mt; it++) H[it][0] = H[it][0].transform(v), H[it][1] = H[it][1].transform(v), H[it][2] = H[it][2].transform(v);
                                    for (it = 1, mt = H.length; it < mt; it++) yt = (at = H[it - 1][2]).x, Pt = at.y, Dt = (at = H[it][0]).x, Vt = at.y, Li = (at = H[it][1]).x, _i.push(["C", yt, Pt, Dt, Vt, Li, Ji = at.y]);
                                    return _i
                                }(this.pos, l))[0]
                        }
                        return l[0] = "C", this.pos = [l[5], l[6]], this.reflection = [2 * l[5] - l[3], 2 * l[6] - l[4]], h
                    }

                    function r(l, h) {
                        if (!1 === h) return !1;
                        for (var d = h, g = l.length; d < g; ++d)
                            if ("M" == l[d][0]) return d;
                        return !1
                    }
                    SVG.extend(SVG.PathArray, {
                        morph: function(l) {
                            for (var h = this.value, d = this.parse(l), g = 0, x = 0, b = !1, v = !1; !1 !== g || !1 !== x;) {
                                var w;
                                b = r(h, !1 !== g && g + 1), v = r(d, !1 !== x && x + 1), !1 === g && (g = 0 == (w = new SVG.PathArray(S.start).bbox()).height || 0 == w.width ? h.push(h[0]) - 1 : h.push(["M", w.x + w.width / 2, w.y + w.height / 2]) - 1), !1 === x && (x = 0 == (w = new SVG.PathArray(S.dest).bbox()).height || 0 == w.width ? d.push(d[0]) - 1 : d.push(["M", w.x + w.width / 2, w.y + w.height / 2]) - 1);
                                var S = _(h, g, b, d, x, v);
                                h = h.slice(0, g).concat(S.start, !1 === b ? [] : h.slice(b)), d = d.slice(0, x).concat(S.dest, !1 === v ? [] : d.slice(v)), g = !1 !== b && g + S.start.length, x = !1 !== v && x + S.dest.length
                            }
                            return this.value = h, this.destination = new SVG.PathArray, this.destination.value = d, this
                        }
                    })
                }(),
                /*! svg.draggable.js - v2.2.2 - 2019-01-08
                 * https://github.com/svgdotjs/svg.draggable.js
                 * Copyright (c) 2019 Wout Fierens; Licensed MIT */
                function() {
                    function _(t) {
                        t.remember("_draggable", this), this.el = t
                    }
                    _.prototype.init = function(t, e) {
                        var i = this;
                        this.constraint = t, this.value = e, this.el.on("mousedown.drag", function(r) {
                            i.start(r)
                        }), this.el.on("touchstart.drag", function(r) {
                            i.start(r)
                        })
                    }, _.prototype.transformPoint = function(t, e) {
                        var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
                        return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m)
                    }, _.prototype.getBBox = function() {
                        var t = this.el.bbox();
                        return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t
                    }, _.prototype.start = function(t) {
                        if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
                            var e = this;
                            if (this.el.fire("beforedrag", {
                                    event: t,
                                    handler: this
                                }), !this.el.event().defaultPrevented) {
                                t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                                var i, r = this.getBBox();
                                if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                                    case "middle":
                                        i /= 2;
                                        break;
                                    case "start":
                                        i = 0
                                }
                                this.startPoints = {
                                    point: this.transformPoint(t, i),
                                    box: r,
                                    transform: this.el.transform()
                                }, SVG.on(window, "mousemove.drag", function(l) {
                                    e.drag(l)
                                }), SVG.on(window, "touchmove.drag", function(l) {
                                    e.drag(l)
                                }), SVG.on(window, "mouseup.drag", function(l) {
                                    e.end(l)
                                }), SVG.on(window, "touchend.drag", function(l) {
                                    e.end(l)
                                }), this.el.fire("dragstart", {
                                    event: t,
                                    p: this.startPoints.point,
                                    m: this.m,
                                    handler: this
                                })
                            }
                        }
                    }, _.prototype.drag = function(t) {
                        var e = this.getBBox(),
                            i = this.transformPoint(t),
                            r = this.startPoints.box.x + i.x - this.startPoints.point.x,
                            l = this.startPoints.box.y + i.y - this.startPoints.point.y,
                            h = this.constraint,
                            d = i.x - this.startPoints.point.x,
                            g = i.y - this.startPoints.point.y;
                        if (this.el.fire("dragmove", {
                                event: t,
                                p: i,
                                m: this.m,
                                handler: this
                            }), this.el.event().defaultPrevented) return i;
                        if ("function" == typeof h) {
                            var x = h.call(this.el, r, l, this.m);
                            "boolean" == typeof x && (x = {
                                x,
                                y: x
                            }), !0 === x.x ? this.el.x(r) : !1 !== x.x && this.el.x(x.x), !0 === x.y ? this.el.y(l) : !1 !== x.y && this.el.y(x.y)
                        } else "object" == typeof h && (null != h.minX && r < h.minX ? d = (r = h.minX) - this.startPoints.box.x : null != h.maxX && r > h.maxX - e.width && (d = (r = h.maxX - e.width) - this.startPoints.box.x), null != h.minY && l < h.minY ? g = (l = h.minY) - this.startPoints.box.y : null != h.maxY && l > h.maxY - e.height && (g = (l = h.maxY - e.height) - this.startPoints.box.y), null != h.snapToGrid && (r -= r % h.snapToGrid, l -= l % h.snapToGrid, d -= d % h.snapToGrid, g -= g % h.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                            x: d,
                            y: g
                        }, !0) : this.el.move(r, l));
                        return i
                    }, _.prototype.end = function(t) {
                        var e = this.drag(t);
                        this.el.fire("dragend", {
                            event: t,
                            p: e,
                            m: this.m,
                            handler: this
                        }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
                    }, SVG.extend(SVG.Element, {
                        draggable: function(t, e) {
                            "function" != typeof t && "object" != typeof t || (e = t, t = !0);
                            var i = this.remember("_draggable") || new _(this);
                            return (t = void 0 === t || t) ? i.init(e || {}, t) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
                        }
                    })
                }.call(void 0),
                function() {
                    function _(t) {
                        this.el = t, t.remember("_selectHandler", this), this.pointSelection = {
                            isSelected: !1
                        }, this.rectSelection = {
                            isSelected: !1
                        }, this.pointsList = {
                            lt: [0, 0],
                            rt: ["width", 0],
                            rb: ["width", "height"],
                            lb: [0, "height"],
                            t: ["width", 0],
                            r: ["width", "height"],
                            b: ["width", "height"],
                            l: [0, "height"]
                        }, this.pointCoord = function(e, i, r) {
                            var l = "string" != typeof e ? e : i[e];
                            return r ? l / 2 : l
                        }, this.pointCoords = function(e, i) {
                            var r = this.pointsList[e];
                            return {
                                x: this.pointCoord(r[0], i, "t" === e || "b" === e),
                                y: this.pointCoord(r[1], i, "r" === e || "l" === e)
                            }
                        }
                    }
                    _.prototype.init = function(t, e) {
                        var i = this.el.bbox();
                        this.options = {};
                        var r = this.el.selectize.defaults.points;
                        for (var l in this.el.selectize.defaults) this.options[l] = this.el.selectize.defaults[l], void 0 !== e[l] && (this.options[l] = e[l]);
                        var h = ["points", "pointsExclude"];
                        for (var l in h) {
                            var d = this.options[h[l]];
                            "string" == typeof d ? d = d.length > 0 ? d.split(/\s*,\s*/i) : [] : "boolean" == typeof d && "points" === h[l] && (d = d ? r : []), this.options[h[l]] = d
                        }
                        this.options.points = [r, this.options.points].reduce(function(g, x) {
                            return g.filter(function(b) {
                                return x.indexOf(b) > -1
                            })
                        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(g, x) {
                            return g.filter(function(b) {
                                return x.indexOf(b) < 0
                            })
                        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup()
                    }, _.prototype.selectPoints = function(t) {
                        return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
                    }, _.prototype.getPointArray = function() {
                        var t = this.el.bbox();
                        return this.el.array().valueOf().map(function(e) {
                            return [e[0] - t.x, e[1] - t.y]
                        })
                    }, _.prototype.drawPoints = function() {
                        for (var t = this, e = this.getPointArray(), i = 0, r = e.length; i < r; ++i) {
                            var l = function(d) {
                                    return function(g) {
                                        (g = g || window.event).preventDefault ? g.preventDefault() : g.returnValue = !1, g.stopPropagation(), t.el.fire("point", {
                                            x: g.pageX || g.touches[0].pageX,
                                            y: g.pageY || g.touches[0].pageY,
                                            i: d,
                                            event: g
                                        })
                                    }
                                }(i),
                                h = this.drawPoint(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", l).on("mousedown", l);
                            this.pointSelection.set.add(h)
                        }
                    }, _.prototype.drawPoint = function(t, e) {
                        var i = this.options.pointType;
                        switch (i) {
                            case "circle":
                                return this.drawCircle(t, e);
                            case "rect":
                                return this.drawRect(t, e);
                            default:
                                if ("function" == typeof i) return i.call(this, t, e);
                                throw new Error("Unknown " + i + " point type!")
                        }
                    }, _.prototype.drawCircle = function(t, e) {
                        return this.nested.circle(this.options.pointSize).center(t, e)
                    }, _.prototype.drawRect = function(t, e) {
                        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e)
                    }, _.prototype.updatePointSelection = function() {
                        var t = this.getPointArray();
                        this.pointSelection.set.each(function(e) {
                            this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1])
                        })
                    }, _.prototype.updateRectSelection = function() {
                        var t = this,
                            e = this.el.bbox();
                        if (this.rectSelection.set.get(0).attr({
                                width: e.width,
                                height: e.height
                            }), this.options.points.length && this.options.points.map(function(r, l) {
                                var h = t.pointCoords(r, e);
                                t.rectSelection.set.get(l + 1).center(h.x, h.y)
                            }), this.options.rotationPoint) {
                            var i = this.rectSelection.set.length();
                            this.rectSelection.set.get(i - 1).center(e.width / 2, 20)
                        }
                    }, _.prototype.selectRect = function(t) {
                        var e = this,
                            i = this.el.bbox();

                        function r(d) {
                            return function(g) {
                                (g = g || window.event).preventDefault ? g.preventDefault() : g.returnValue = !1, g.stopPropagation(), e.el.fire(d, {
                                    x: g.pageX || g.touches[0].pageX,
                                    y: g.pageY || g.touches[0].pageY,
                                    event: g
                                })
                            }
                        }
                        if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(d, g) {
                                var x = e.pointCoords(d, i),
                                    b = e.drawPoint(x.x, x.y).attr("class", e.options.classPoints + "_" + d).on("mousedown", r(d)).on("touchstart", r(d));
                                e.rectSelection.set.add(b)
                            }), this.rectSelection.set.each(function() {
                                this.addClass(e.options.classPoints)
                            })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                            var l = function(d) {
                                    (d = d || window.event).preventDefault ? d.preventDefault() : d.returnValue = !1, d.stopPropagation(), e.el.fire("rot", {
                                        x: d.pageX || d.touches[0].pageX,
                                        y: d.pageY || d.touches[0].pageY,
                                        event: d
                                    })
                                },
                                h = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", l).on("mousedown", l);
                            this.rectSelection.set.add(h)
                        }
                    }, _.prototype.handler = function() {
                        var t = this.el.bbox();
                        this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
                    }, _.prototype.observe = function() {
                        var t = this;
                        if (MutationObserver)
                            if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function() {
                                t.handler()
                            }), this.observerInst.observe(this.el.node, {
                                attributes: !0
                            });
                            else try {
                                this.observerInst.disconnect(), delete this.observerInst
                            } catch {} else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
                                t.handler()
                            })
                    }, _.prototype.cleanup = function() {
                        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
                            this.remove()
                        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
                            this.remove()
                        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
                    }, SVG.extend(SVG.Element, {
                        selectize: function(t, e) {
                            return "object" == typeof t && (e = t, t = !0), (this.remember("_selectHandler") || new _(this)).init(void 0 === t || t, e || {}), this
                        }
                    }), SVG.Element.prototype.selectize.defaults = {
                        points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
                        pointsExclude: [],
                        classRect: "svg_select_boundingRect",
                        classPoints: "svg_select_points",
                        pointSize: 7,
                        rotationPoint: !0,
                        deepSelect: !1,
                        pointType: "circle"
                    }
                }(),
                function() {
                    (function() {
                        function _(t) {
                            t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint()
                        }
                        _.prototype.transformPoint = function(t, e, i) {
                            return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m)
                        }, _.prototype._extractPosition = function(t) {
                            return {
                                x: null != t.clientX ? t.clientX : t.touches[0].clientX,
                                y: null != t.clientY ? t.clientY : t.touches[0].clientY
                            }
                        }, _.prototype.init = function(t) {
                            var e = this;
                            if (this.stop(), "stop" !== t) {
                                for (var i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]);
                                this.el.on("lt.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("rt.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("rb.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("lb.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("t.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("r.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("b.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("l.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("rot.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.el.on("point.resize", function(r) {
                                    e.resize(r || window.event)
                                }), this.update()
                            }
                        }, _.prototype.stop = function() {
                            return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
                        }, _.prototype.resize = function(t) {
                            var e = this;
                            this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                                x: window.pageXOffset,
                                y: window.pageYOffset
                            };
                            var i = this._extractPosition(t.detail.event);
                            if (this.parameters = {
                                    type: this.el.type,
                                    p: this.transformPoint(i.x, i.y),
                                    x: t.detail.x,
                                    y: t.detail.y,
                                    box: this.el.bbox(),
                                    rotation: this.el.transform().rotation
                                }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
                                var r = this.el.array().valueOf();
                                this.parameters.i = t.detail.i, this.parameters.pointCoords = [r[t.detail.i][0], r[t.detail.i][1]]
                            }
                            switch (t.type) {
                                case "lt":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h);
                                        if (this.parameters.box.width - d[0] > 0 && this.parameters.box.height - d[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + d[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - d[0]);
                                            d = this.checkAspectRatio(d), this.el.move(this.parameters.box.x + d[0], this.parameters.box.y + d[1]).size(this.parameters.box.width - d[0], this.parameters.box.height - d[1])
                                        }
                                    };
                                    break;
                                case "rt":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 2);
                                        if (this.parameters.box.width + d[0] > 0 && this.parameters.box.height - d[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - d[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + d[0]);
                                            d = this.checkAspectRatio(d, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + d[1]).size(this.parameters.box.width + d[0], this.parameters.box.height - d[1])
                                        }
                                    };
                                    break;
                                case "rb":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 0);
                                        if (this.parameters.box.width + d[0] > 0 && this.parameters.box.height + d[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - d[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + d[0]);
                                            d = this.checkAspectRatio(d), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + d[0], this.parameters.box.height + d[1])
                                        }
                                    };
                                    break;
                                case "lb":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 1);
                                        if (this.parameters.box.width - d[0] > 0 && this.parameters.box.height + d[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + d[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - d[0]);
                                            d = this.checkAspectRatio(d, !0), this.el.move(this.parameters.box.x + d[0], this.parameters.box.y).size(this.parameters.box.width - d[0], this.parameters.box.height + d[1])
                                        }
                                    };
                                    break;
                                case "t":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 2);
                                        if (this.parameters.box.height - d[1] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y + d[1]).height(this.parameters.box.height - d[1])
                                        }
                                    };
                                    break;
                                case "r":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 0);
                                        if (this.parameters.box.width + d[0] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + d[0])
                                        }
                                    };
                                    break;
                                case "b":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 0);
                                        if (this.parameters.box.height + d[1] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + d[1])
                                        }
                                    };
                                    break;
                                case "l":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, 1);
                                        if (this.parameters.box.width - d[0] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x + d[0], this.parameters.box.y).width(this.parameters.box.width - d[0])
                                        }
                                    };
                                    break;
                                case "rot":
                                    this.calc = function(l, h) {
                                        var d = l + this.parameters.p.x,
                                            g = h + this.parameters.p.y,
                                            x = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                                            b = Math.atan2(g - this.parameters.box.y - this.parameters.box.height / 2, d - this.parameters.box.x - this.parameters.box.width / 2),
                                            v = this.parameters.rotation + 180 * (b - x) / Math.PI + this.options.snapToAngle / 2;
                                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(v - v % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                                    };
                                    break;
                                case "point":
                                    this.calc = function(l, h) {
                                        var d = this.snapToGrid(l, h, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                                            g = this.el.array().valueOf();
                                        g[this.parameters.i][0] = this.parameters.pointCoords[0] + d[0], g[this.parameters.i][1] = this.parameters.pointCoords[1] + d[1], this.el.plot(g)
                                    }
                            }
                            this.el.fire("resizestart", {
                                dx: this.parameters.x,
                                dy: this.parameters.y,
                                event: t
                            }), SVG.on(window, "touchmove.resize", function(l) {
                                e.update(l || window.event)
                            }), SVG.on(window, "touchend.resize", function() {
                                e.done()
                            }), SVG.on(window, "mousemove.resize", function(l) {
                                e.update(l || window.event)
                            }), SVG.on(window, "mouseup.resize", function() {
                                e.done()
                            })
                        }, _.prototype.update = function(t) {
                            if (t) {
                                var e = this._extractPosition(t),
                                    i = this.transformPoint(e.x, e.y),
                                    r = i.x - this.parameters.p.x,
                                    l = i.y - this.parameters.p.y;
                                this.lastUpdateCall = [r, l], this.calc(r, l), this.el.fire("resizing", {
                                    dx: r,
                                    dy: l,
                                    event: t
                                })
                            } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
                        }, _.prototype.done = function() {
                            this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
                        }, _.prototype.snapToGrid = function(t, e, i, r) {
                            var l;
                            return l = void 0 !== r ? [(i + t) % this.options.snapToGrid, (r + e) % this.options.snapToGrid] : [(this.parameters.box.x + t + (1 & (i = i ? ? 3) ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid], t < 0 && (l[0] -= this.options.snapToGrid), e < 0 && (l[1] -= this.options.snapToGrid), t -= Math.abs(l[0]) < this.options.snapToGrid / 2 ? l[0] : l[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(l[1]) < this.options.snapToGrid / 2 ? l[1] : l[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, r)
                        }, _.prototype.constraintToBox = function(t, e, i, r) {
                            var l, h, d = this.options.constraint || {};
                            return void 0 !== r ? (l = i, h = r) : (l = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), h = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== d.minX && l + t < d.minX && (t = d.minX - l), void 0 !== d.maxX && l + t > d.maxX && (t = d.maxX - l), void 0 !== d.minY && h + e < d.minY && (e = d.minY - h), void 0 !== d.maxY && h + e > d.maxY && (e = d.maxY - h), [t, e]
                        }, _.prototype.checkAspectRatio = function(t, e) {
                            if (!this.options.saveAspectRatio) return t;
                            var i = t.slice(),
                                r = this.parameters.box.width / this.parameters.box.height,
                                l = this.parameters.box.width + t[0],
                                h = this.parameters.box.height - t[1],
                                d = l / h;
                            return d < r ? (i[1] = l / r - this.parameters.box.height, e && (i[1] = -i[1])) : d > r && (i[0] = this.parameters.box.width - h * r, e && (i[0] = -i[0])), i
                        }, SVG.extend(SVG.Element, {
                            resize: function(t) {
                                return (this.remember("_resizeHandler") || new _(this)).init(t || {}), this
                            }
                        }), SVG.Element.prototype.resize.defaults = {
                            snapToAngle: .1,
                            snapToGrid: 1,
                            constraint: {},
                            saveAspectRatio: !1
                        }
                    }).call(this)
                }(), void 0 === window.Apex && (window.Apex = {});
            var Se = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "initModules",
                        value: function() {
                            this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new Bt(this.ctx), this.ctx.axes = new Tt(this.ctx), this.ctx.core = new Te(this.ctx.el, this.ctx), this.ctx.config = new Pe({}), this.ctx.data = new He(this.ctx), this.ctx.grid = new We(this.ctx), this.ctx.graphics = new ot(this.ctx), this.ctx.coreUtils = new te(this.ctx), this.ctx.crosshairs = new $t(this.ctx), this.ctx.events = new zt(this.ctx), this.ctx.exports = new ii(this.ctx), this.ctx.localization = new Qt(this.ctx), this.ctx.options = new Re, this.ctx.responsive = new Jt(this.ctx), this.ctx.series = new xe(this.ctx), this.ctx.theme = new Ct(this.ctx), this.ctx.formatters = new Be(this.ctx), this.ctx.titleSubtitle = new Qi(this.ctx), this.ctx.legend = new bi(this.ctx), this.ctx.toolbar = new re(this.ctx), this.ctx.tooltip = new yi(this.ctx), this.ctx.dimensions = new Ve(this.ctx), this.ctx.updateHelpers = new ge(this.ctx), this.ctx.zoomPanSelection = new qe(this.ctx), this.ctx.w.globals.tooltip = new yi(this.ctx)
                        }
                    }]), _
                }(),
                Wt = function() {
                    function _(t) {
                        xt(this, _), this.ctx = t, this.w = t.w
                    }
                    return ht(_, [{
                        key: "clear",
                        value: function(t) {
                            var e = t.isUpdating;
                            this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
                                isUpdating: e
                            })
                        }
                    }, {
                        key: "killSVG",
                        value: function(t) {
                            t.each(function(e, i) {
                                this.removeClass("*"), this.off(), this.stop()
                            }, !0), t.ungroup(), t.clear()
                        }
                    }, {
                        key: "clearDomElements",
                        value: function(t) {
                            var e = this,
                                r = this.w.globals.dom.Paper.node;
                            r.parentNode && r.parentNode.parentNode && !t.isUpdating && (r.parentNode.parentNode.style.minHeight = "unset");
                            var l = this.w.globals.dom.baseEl;
                            l && this.ctx.eventList.forEach(function(d) {
                                l.removeEventListener(d, e.ctx.events.documentEvent)
                            });
                            var h = this.w.globals.dom;
                            if (null !== this.ctx.el)
                                for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
                            this.killSVG(h.Paper), h.Paper.remove(), h.elWrap = null, h.elGraphical = null, h.elLegendWrap = null, h.elLegendForeign = null, h.baseEl = null, h.elGridRect = null, h.elGridRectMask = null, h.elGridRectMarkerMask = null, h.elForecastMask = null, h.elNonForecastMask = null, h.elDefs = null
                        }
                    }]), _
                }(),
                Lt = new WeakMap,
                Mt = function() {
                    function _(t, e) {
                        xt(this, _), this.opts = e, this.ctx = this, this.w = new Yi(e).init(), this.el = t, this.w.globals.cuid = q.randomId(), this.w.globals.chartID = this.w.config.chart.id ? q.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Se(this).initModules(), this.create = q.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this)
                    }
                    return ht(_, [{
                        key: "render",
                        value: function() {
                            var t = this;
                            return new Promise(function(e, i) {
                                if (null !== t.el) {
                                    void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
                                        id: t.w.globals.chartID,
                                        group: t.w.config.chart.group,
                                        chart: t
                                    }), t.setLocale(t.w.config.chart.defaultLocale);
                                    var r = t.w.config.chart.events.beforeMount;
                                    if ("function" == typeof r && r(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), function(b, v) {
                                            var w = !1;
                                            if (b.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                                                var S = b.getBoundingClientRect();
                                                "none" !== b.style.display && 0 !== S.width || (w = !0)
                                            }
                                            var C = new ResizeObserver(function(P) {
                                                w && v.call(b, P), w = !0
                                            });
                                            b.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(b.children).forEach(function(P) {
                                                return C.observe(P)
                                            }) : C.observe(b), Lt.set(v, C)
                                        }(t.el.parentNode, t.parentResizeHandler), !t.css) {
                                        var l = t.el.getRootNode && t.el.getRootNode(),
                                            h = q.is("ShadowRoot", l),
                                            d = t.el.ownerDocument,
                                            g = d.getElementById("apexcharts-css");
                                        !h && g || (t.css = document.createElement("style"), t.css.id = "apexcharts-css", t.css.textContent = '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}', h ? l.prepend(t.css) : d.head.appendChild(t.css))
                                    }
                                    var x = t.create(t.w.config.series, {});
                                    if (!x) return e(t);
                                    t.mount(x).then(function() {
                                        "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(x)
                                    }).catch(function(b) {
                                        i(b)
                                    })
                                } else i(new Error("Element not found"))
                            })
                        }
                    }, {
                        key: "create",
                        value: function(t, e) {
                            var i = this.w;
                            new Se(this).initModules();
                            var r = this.w.globals;
                            if (r.noData = !1, r.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric && new Ze(i.config).convertCatToNumericXaxis(i.config, this.ctx), null === this.el || (this.core.setupElements(), "treemap" === i.config.chart.type && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), 0 === r.svgWidth)) return r.animationEnded = !0, null;
                            var l = te.checkComboSeries(t);
                            r.comboCharts = l.comboCharts, r.comboBarCount = l.comboBarCount;
                            var h = t.every(function(b) {
                                return b.data && 0 === b.data.length
                            });
                            (0 === t.length || h) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new gi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), r.noData && r.collapsedSeries.length !== r.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), r.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new te(this).getLargestMarkerSize(), this.dimensions.plotCoords();
                            var d = this.core.xySettings();
                            this.grid.createGridMask();
                            var g = this.core.plotChartType(t, d),
                                x = new ve(this);
                            return x.bringForward(), i.config.dataLabels.background.enabled && x.dataLabelsBackground(), this.core.shiftGraphPosition(), {
                                elGraph: g,
                                xyRatios: d,
                                dimensions: {
                                    plot: {
                                        left: i.globals.translateX,
                                        top: i.globals.translateY,
                                        width: i.globals.gridWidth,
                                        height: i.globals.gridHeight
                                    }
                                }
                            }
                        }
                    }, {
                        key: "mount",
                        value: function() {
                            var t = this,
                                e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                i = this,
                                r = i.w;
                            return new Promise(function(l, h) {
                                if (null === i.el) return h(new Error("Not enough data to display or target element not found"));
                                (null === e || r.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new We(i);
                                var d, g, x = i.grid.drawGrid();
                                if (i.annotations = new ci(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === r.config.grid.position && (x && r.globals.dom.elGraphical.add(x.el), null != x && null !== (d = x.elGridBorders) && void 0 !== d && d.node && r.globals.dom.elGraphical.add(x.elGridBorders)), Array.isArray(e.elGraph))
                                    for (var b = 0; b < e.elGraph.length; b++) r.globals.dom.elGraphical.add(e.elGraph[b]);
                                else r.globals.dom.elGraphical.add(e.elGraph);
                                "front" === r.config.grid.position && (x && r.globals.dom.elGraphical.add(x.el), null != x && null !== (g = x.elGridBorders) && void 0 !== g && g.node && r.globals.dom.elGraphical.add(x.elGridBorders)), "front" === r.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === r.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "treemap" !== r.config.chart.type && i.axes.drawAxis(r.config.chart.type, x);
                                var v = new Ye(t.ctx, x),
                                    w = new pi(t.ctx, x);
                                if (null !== x && (v.xAxisLabelCorrections(x.xAxisTickWidth), w.setYAxisTextAlignments(), r.config.yaxis.map(function(C, P) {
                                        -1 === r.globals.ignoreYAxisIndexes.indexOf(P) && w.yAxisTitleRotate(P, C.opposite)
                                    })), i.annotations.drawAxesAnnotations(), !r.globals.noData) {
                                    if (r.config.tooltip.enabled && !r.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), r.globals.axisCharts && (r.globals.isXNumeric || r.config.xaxis.convertedCatToNumeric || r.globals.isRangeBar))(r.config.chart.zoom.enabled || r.config.chart.selection && r.config.chart.selection.enabled || r.config.chart.pan && r.config.chart.pan.enabled) && i.zoomPanSelection.init({
                                        xyRatios: e.xyRatios
                                    });
                                    else {
                                        var S = r.config.chart.toolbar.tools;
                                        ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(C) {
                                            S[C] = !1
                                        })
                                    }
                                    r.config.chart.toolbar.show && !r.globals.allSeriesCollapsed && i.toolbar.createToolbar()
                                }
                                r.globals.memory.methodsToExec.length > 0 && r.globals.memory.methodsToExec.forEach(function(C) {
                                    C.method(C.params, !1, C.context)
                                }), r.globals.axisCharts || r.globals.noData || i.core.resizeNonAxisCharts(), l(i)
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t, e;
                            window.removeEventListener("resize", this.windowResizeHandler), (e = Lt.get(t = this.parentResizeHandler)) && (e.disconnect(), Lt.delete(t));
                            var i = this.w.config.chart.id;
                            i && Apex._chartInstances.forEach(function(r, l) {
                                r.id === q.escapeString(i) && Apex._chartInstances.splice(l, 1)
                            }), new Wt(this.ctx).clear({
                                isUpdating: !1
                            })
                        }
                    }, {
                        key: "updateOptions",
                        value: function(t) {
                            var e = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                l = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                h = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                d = this.w;
                            return d.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function(g, x) {
                                return e.updateHelpers._extendSeries(g, x)
                            })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), d.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, r, l, h)
                        }
                    }, {
                        key: "updateSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                            return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i)
                        }
                    }, {
                        key: "appendSeries",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                r = this.w.config.series.slice();
                            return r.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(r, e, i)
                        }
                    }, {
                        key: "appendData",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = this;
                            i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
                            for (var r = i.w.config.series.slice(), l = 0; l < r.length; l++)
                                if (null != t[l])
                                    for (var h = 0; h < t[l].data.length; h++) r[l].data.push(t[l].data[h]);
                            return i.w.config.series = r, e && (i.w.globals.initialSeries = q.clone(i.w.config.series)), this.update()
                        }
                    }, {
                        key: "update",
                        value: function(t) {
                            var e = this;
                            return new Promise(function(i, r) {
                                new Wt(e.ctx).clear({
                                    isUpdating: !0
                                });
                                var l = e.create(e.w.config.series, t);
                                if (!l) return i(e);
                                e.mount(l).then(function() {
                                    "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, i(e)
                                }).catch(function(h) {
                                    r(h)
                                })
                            })
                        }
                    }, {
                        key: "getSyncedCharts",
                        value: function() {
                            var t = this.getGroupedCharts(),
                                e = [this];
                            return t.length && (e = [], t.forEach(function(i) {
                                e.push(i)
                            })), e
                        }
                    }, {
                        key: "getGroupedCharts",
                        value: function() {
                            var t = this;
                            return Apex._chartInstances.filter(function(e) {
                                if (e.group) return !0
                            }).map(function(e) {
                                return t.w.config.chart.group === e.group ? e.chart : t
                            })
                        }
                    }, {
                        key: "toggleSeries",
                        value: function(t) {
                            return this.series.toggleSeries(t)
                        }
                    }, {
                        key: "highlightSeriesOnLegendHover",
                        value: function(t, e) {
                            return this.series.toggleSeriesOnHover(t, e)
                        }
                    }, {
                        key: "showSeries",
                        value: function(t) {
                            this.series.showSeries(t)
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            this.series.hideSeries(t)
                        }
                    }, {
                        key: "isSeriesHidden",
                        value: function(t) {
                            this.series.isSeriesHidden(t)
                        }
                    }, {
                        key: "resetSeries",
                        value: function() {
                            this.series.resetSeries(!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1])
                        }
                    }, {
                        key: "addEventListener",
                        value: function(t, e) {
                            this.events.addEventListener(t, e)
                        }
                    }, {
                        key: "removeEventListener",
                        value: function(t, e) {
                            this.events.removeEventListener(t, e)
                        }
                    }, {
                        key: "addXaxisAnnotation",
                        value: function(t) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                r = this;
                            i && (r = i), r.annotations.addXaxisAnnotationExternal(t, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r)
                        }
                    }, {
                        key: "addYaxisAnnotation",
                        value: function(t) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                r = this;
                            i && (r = i), r.annotations.addYaxisAnnotationExternal(t, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r)
                        }
                    }, {
                        key: "addPointAnnotation",
                        value: function(t) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                r = this;
                            i && (r = i), r.annotations.addPointAnnotationExternal(t, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r)
                        }
                    }, {
                        key: "clearAnnotations",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
                                e = this;
                            t && (e = t), e.annotations.clearAnnotations(e)
                        }
                    }, {
                        key: "removeAnnotation",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
                                i = this;
                            e && (i = e), i.annotations.removeAnnotation(i, t)
                        }
                    }, {
                        key: "getChartArea",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
                        }
                    }, {
                        key: "getSeriesTotalXRange",
                        value: function(t, e) {
                            return this.coreUtils.getSeriesTotalsXRange(t, e)
                        }
                    }, {
                        key: "getHighestValueInSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                            return new Ae(this.ctx).getMinYMaxY(t).highestY
                        }
                    }, {
                        key: "getLowestValueInSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                            return new Ae(this.ctx).getMinYMaxY(t).lowestY
                        }
                    }, {
                        key: "getSeriesTotal",
                        value: function() {
                            return this.w.globals.seriesTotals
                        }
                    }, {
                        key: "toggleDataPointSelection",
                        value: function(t, e) {
                            return this.updateHelpers.toggleDataPointSelection(t, e)
                        }
                    }, {
                        key: "zoomX",
                        value: function(t, e) {
                            this.ctx.toolbar.zoomUpdateOptions(t, e)
                        }
                    }, {
                        key: "setLocale",
                        value: function(t) {
                            this.localization.setCurrentLocaleValues(t)
                        }
                    }, {
                        key: "dataURI",
                        value: function(t) {
                            return new ii(this.ctx).dataURI(t)
                        }
                    }, {
                        key: "exportToCSV",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            return new ii(this.ctx).exportToCSV(t)
                        }
                    }, {
                        key: "paper",
                        value: function() {
                            return this.w.globals.dom.Paper
                        }
                    }, {
                        key: "_parentResizeCallback",
                        value: function() {
                            this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
                        }
                    }, {
                        key: "_windowResize",
                        value: function() {
                            var t = this;
                            clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
                                t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update()
                            }, 150)
                        }
                    }, {
                        key: "_windowResizeHandler",
                        value: function() {
                            var t = this.w.config.chart.redrawOnWindowResize;
                            "function" == typeof t && (t = t()), t && this._windowResize()
                        }
                    }], [{
                        key: "getChartByID",
                        value: function(t) {
                            var e = q.escapeString(t);
                            if (Apex._chartInstances) {
                                var i = Apex._chartInstances.filter(function(r) {
                                    return r.id === e
                                })[0];
                                return i && i.chart
                            }
                        }
                    }, {
                        key: "initOnLoad",
                        value: function() {
                            for (var t = document.querySelectorAll("[data-apexcharts]"), e = 0; e < t.length; e++) new _(t[e], JSON.parse(t[e].getAttribute("data-options"))).render()
                        }
                    }, {
                        key: "exec",
                        value: function(t, e) {
                            var i = this.getChartByID(t);
                            if (i) {
                                i.w.globals.isExecCalled = !0;
                                var r = null;
                                if (-1 !== i.publicMethods.indexOf(e)) {
                                    for (var l = arguments.length, h = new Array(l > 2 ? l - 2 : 0), d = 2; d < l; d++) h[d - 2] = arguments[d];
                                    r = i[e].apply(i, h)
                                }
                                return r
                            }
                        }
                    }, {
                        key: "merge",
                        value: function(t, e) {
                            return q.extend(t, e)
                        }
                    }]), _
                }();
            Mi.exports = Mt
        },
        5553: (Mi, je, Nt) => {
            Nt.d(je, {
                ny: () => He,
                uc: () => jt,
                vz: () => Xe,
                wW: () => Fe,
                wf: () => xi
            });
            const _t = {
                    svg: "http://www.w3.org/2000/svg",
                    xmlns: "http://www.w3.org/2000/xmlns/",
                    xhtml: "http://www.w3.org/1999/xhtml",
                    xlink: "http://www.w3.org/1999/xlink",
                    ct: "http://gionkunz.github.com/chartist-js/ct"
                },
                pe = 8,
                ut = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#039;"
                };

            function Zt(W, E) {
                return "number" == typeof W ? W + E : W
            }

            function xt(W) {
                if ("string" == typeof W) {
                    const E = /^(\d+)\s*(.*)$/g.exec(W);
                    return {
                        value: E ? +E[1] : 0,
                        unit: E ? .[2] || void 0
                    }
                }
                return {
                    value: Number(W)
                }
            }

            function be(W) {
                return String.fromCharCode(97 + W % 26)
            }
            const ht = 2221e-19;

            function Rt(W, E, N) {
                return E / N.range * W
            }

            function bt(W, E) {
                const N = Math.pow(10, E || pe);
                return Math.round(W * N) / N
            }

            function ue(W, E, N, F) {
                const Y = (F - 90) * Math.PI / 180;
                return {
                    x: W + N * Math.cos(Y),
                    y: E + N * Math.sin(Y)
                }
            }

            function ze() {
                let W = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                for (var E = arguments.length, N = new Array(E > 1 ? E - 1 : 0), F = 1; F < E; F++) N[F - 1] = arguments[F];
                for (let Y = 0; Y < N.length; Y++) {
                    const $ = N[Y];
                    for (const K in $) {
                        const et = $[K];
                        W[K] = "object" != typeof et || null === et || et instanceof Array ? et : ze(W[K], et)
                    }
                }
                return W
            }
            const le = W => W;

            function ei(W, E) {
                return Array.from({
                    length: W
                }, E ? (N, F) => E(F) : () => {})
            }
            const Pi = (W, E) => W + (E || 0);

            function Bt(W, E) {
                return null !== W && "object" == typeof W && Reflect.has(W, E)
            }

            function ae(W) {
                return null !== W && isFinite(W)
            }

            function ot(W) {
                return !W && 0 !== W
            }

            function te(W) {
                return ae(W) ? Number(W) : void 0
            }

            function li(W, E) {
                let F = 0;
                W[arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? "reduceRight" : "reduce"]((Y, $, K) => E($, F++, K), void 0)
            }

            function hi(W, E) {
                const N = Array.isArray(W) ? W[E] : Bt(W, "data") ? W.data[E] : null;
                return Bt(N, "meta") ? N.meta : void 0
            }

            function Ni(W) {
                return null == W || "number" == typeof W && isNaN(W)
            }

            function ci(W) {
                let E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "y";
                return function Re(W) {
                    return "object" == typeof W && null !== W && (Reflect.has(W, "x") || Reflect.has(W, "y"))
                }(W) && Bt(W, E) ? te(W[E]) : te(W)
            }

            function ne(W, E, N) {
                const F = {
                        high: void 0 === (E = { ...E,
                            ...N ? "x" === N ? E.axisX : E.axisY : {}
                        }).high ? -Number.MAX_VALUE : +E.high,
                        low: void 0 === E.low ? Number.MAX_VALUE : +E.low
                    },
                    Y = void 0 === E.high,
                    $ = void 0 === E.low;
                return (Y || $) && function K(et) {
                    if (!Ni(et))
                        if (Array.isArray(et))
                            for (let rt = 0; rt < et.length; rt++) K(et[rt]);
                        else {
                            const rt = Number(N && Bt(et, N) ? et[N] : et);
                            Y && rt > F.high && (F.high = rt), $ && rt < F.low && (F.low = rt)
                        }
                }(W), (E.referenceValue || 0 === E.referenceValue) && (F.high = Math.max(E.referenceValue, F.high), F.low = Math.min(E.referenceValue, F.low)), F.high <= F.low && (0 === F.low ? F.high = 1 : F.low < 0 ? F.high = 0 : (F.high > 0 || (F.high = 1), F.low = 0)), F
            }

            function Be(W) {
                let Y, E = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    N = arguments.length > 2 ? arguments[2] : void 0,
                    F = arguments.length > 3 ? arguments[3] : void 0;
                const $ = {
                        labels: (W.labels || []).slice(),
                        series: Hi(W.series, N, F)
                    },
                    K = $.labels.length;
                return function Ue(W) {
                    return !!Array.isArray(W) && W.every(Array.isArray)
                }($.series) ? (Y = Math.max(K, ...$.series.map(et => et.length)), $.series.forEach(et => {
                    et.push(...ei(Math.max(0, Y - et.length)))
                })) : Y = $.series.length, $.labels.push(...ei(Math.max(0, Y - K), () => "")), E && function di(W) {
                    var E;
                    null === (E = W.labels) || void 0 === E || E.reverse(), W.series.reverse();
                    for (const N of W.series) Bt(N, "data") ? N.data.reverse() : Array.isArray(N) && N.reverse()
                }($), $
            }

            function Ze(W, E) {
                if (!Ni(W)) return E ? function ui(W, E) {
                    let N, F;
                    if ("object" != typeof W) {
                        const Y = te(W);
                        "x" === E ? N = Y : F = Y
                    } else Bt(W, "x") && (N = te(W.x)), Bt(W, "y") && (F = te(W.y));
                    if (void 0 !== N || void 0 !== F) return {
                        x: N,
                        y: F
                    }
                }(W, E) : te(W)
            }

            function Pe(W, E) {
                return Array.isArray(W) ? W.map(N => Bt(N, "value") ? Ze(N.value, E) : Ze(N, E)) : Pe(W.data, E)
            }

            function Hi(W, E, N) {
                if (function Bi(W) {
                        return Array.isArray(W) && W.every(E => Array.isArray(E) || Bt(E, "data"))
                    }(W)) return W.map(Y => Pe(Y, E));
                const F = Pe(W, E);
                return N ? F.map(Y => [Y]) : F
            }

            function Yi(W, E, N) {
                const F = {
                        increasingX: !1,
                        fillHoles: !1,
                        ...N
                    },
                    Y = [];
                let $ = !0;
                for (let K = 0; K < W.length; K += 2) void 0 === ci(E[K / 2].value) ? F.fillHoles || ($ = !0) : (F.increasingX && K >= 2 && W[K] <= W[K - 2] && ($ = !0), $ && (Y.push({
                    pathCoordinates: [],
                    valueData: []
                }), $ = !1), Y[Y.length - 1].pathCoordinates.push(W[K], W[K + 1]), Y[Y.length - 1].valueData.push(E[K / 2]));
                return Y
            }

            function ce(W) {
                let E = "";
                return null == W ? W : (E = "number" == typeof W ? "" + W : "object" == typeof W ? JSON.stringify({
                    data: W
                }) : String(W), Object.keys(ut).reduce((N, F) => N.replaceAll(F, ut[F]), E))
            }
            class fi {
                call(E, N) {
                    return this.svgElements.forEach(F => Reflect.apply(F[E], F, N)), this
                }
                attr() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("attr", N)
                }
                elem() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("elem", N)
                }
                root() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("root", N)
                }
                getNode() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("getNode", N)
                }
                foreignObject() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("foreignObject", N)
                }
                text() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("text", N)
                }
                empty() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("empty", N)
                }
                remove() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("remove", N)
                }
                addClass() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("addClass", N)
                }
                removeClass() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("removeClass", N)
                }
                removeAllClasses() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("removeAllClasses", N)
                }
                animate() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return this.call("animate", N)
                }
                constructor(E) {
                    this.svgElements = [];
                    for (let N = 0; N < E.length; N++) this.svgElements.push(new He(E[N]))
                }
            }
            const ve = {
                easeInSine: [.47, 0, .745, .715],
                easeOutSine: [.39, .575, .565, 1],
                easeInOutSine: [.445, .05, .55, .95],
                easeInQuad: [.55, .085, .68, .53],
                easeOutQuad: [.25, .46, .45, .94],
                easeInOutQuad: [.455, .03, .515, .955],
                easeInCubic: [.55, .055, .675, .19],
                easeOutCubic: [.215, .61, .355, 1],
                easeInOutCubic: [.645, .045, .355, 1],
                easeInQuart: [.895, .03, .685, .22],
                easeOutQuart: [.165, .84, .44, 1],
                easeInOutQuart: [.77, 0, .175, 1],
                easeInQuint: [.755, .05, .855, .06],
                easeOutQuint: [.23, 1, .32, 1],
                easeInOutQuint: [.86, 0, .07, 1],
                easeInExpo: [.95, .05, .795, .035],
                easeOutExpo: [.19, 1, .22, 1],
                easeInOutExpo: [1, 0, 0, 1],
                easeInCirc: [.6, .04, .98, .335],
                easeOutCirc: [.075, .82, .165, 1],
                easeInOutCirc: [.785, .135, .15, .86],
                easeInBack: [.6, -.28, .735, .045],
                easeOutBack: [.175, .885, .32, 1.275],
                easeInOutBack: [.68, -.55, .265, 1.55]
            };

            function xe(W, E, N) {
                let F = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    Y = arguments.length > 4 ? arguments[4] : void 0;
                const {
                    easing: $,
                    ...K
                } = N, et = {};
                let rt, lt;
                $ && (rt = Array.isArray($) ? $ : ve[$]), K.begin = Zt(K.begin, "ms"), K.dur = Zt(K.dur, "ms"), rt && (K.calcMode = "spline", K.keySplines = rt.join(" "), K.keyTimes = "0;1"), F && (K.fill = "freeze", et[E] = K.from, W.attr(et), lt = xt(K.begin || 0).value, K.begin = "indefinite");
                const ct = W.elem("animate", {
                    attributeName: E,
                    ...K
                });
                F && setTimeout(() => {
                    try {
                        ct._node.beginElement()
                    } catch {
                        et[E] = K.to, W.attr(et), ct.remove()
                    }
                }, lt);
                const wt = ct.getNode();
                Y && wt.addEventListener("beginEvent", () => Y.emit("animationBegin", {
                    element: W,
                    animate: wt,
                    params: N
                })), wt.addEventListener("endEvent", () => {
                    Y && Y.emit("animationEnd", {
                        element: W,
                        animate: wt,
                        params: N
                    }), F && (et[E] = K.to, W.attr(et), ct.remove())
                })
            }
            let He = (() => {
                class W {
                    attr(N, F) {
                        return "string" == typeof N ? F ? this._node.getAttributeNS(F, N) : this._node.getAttribute(N) : (Object.keys(N).forEach(Y => {
                            if (void 0 !== N[Y])
                                if (-1 !== Y.indexOf(":")) {
                                    const $ = Y.split(":");
                                    this._node.setAttributeNS(_t[$[0]], Y, String(N[Y]))
                                } else this._node.setAttribute(Y, String(N[Y]))
                        }), this)
                    }
                    elem(N, F, Y) {
                        return new W(N, F, Y, this, arguments.length > 3 && void 0 !== arguments[3] && arguments[3])
                    }
                    parent() {
                        return this._node.parentNode instanceof SVGElement ? new W(this._node.parentNode) : null
                    }
                    root() {
                        let N = this._node;
                        for (;
                            "svg" !== N.nodeName && N.parentElement;) N = N.parentElement;
                        return new W(N)
                    }
                    querySelector(N) {
                        const F = this._node.querySelector(N);
                        return F ? new W(F) : null
                    }
                    querySelectorAll(N) {
                        const F = this._node.querySelectorAll(N);
                        return new fi(F)
                    }
                    getNode() {
                        return this._node
                    }
                    foreignObject(N, F, Y) {
                        let K, $ = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                        if ("string" == typeof N) {
                            const rt = document.createElement("div");
                            rt.innerHTML = N, K = rt.firstChild
                        } else K = N;
                        K instanceof Element && K.setAttribute("xmlns", _t.xmlns);
                        const et = this.elem("foreignObject", F, Y, $);
                        return et._node.appendChild(K), et
                    }
                    text(N) {
                        return this._node.appendChild(document.createTextNode(N)), this
                    }
                    empty() {
                        for (; this._node.firstChild;) this._node.removeChild(this._node.firstChild);
                        return this
                    }
                    remove() {
                        var N;
                        return null === (N = this._node.parentNode) || void 0 === N || N.removeChild(this._node), this.parent()
                    }
                    replace(N) {
                        var F;
                        return null === (F = this._node.parentNode) || void 0 === F || F.replaceChild(N._node, this._node), N
                    }
                    append(N) {
                        return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && this._node.firstChild ? this._node.insertBefore(N._node, this._node.firstChild) : this._node.appendChild(N._node), this
                    }
                    classes() {
                        const N = this._node.getAttribute("class");
                        return N ? N.trim().split(/\s+/) : []
                    }
                    addClass(N) {
                        return this._node.setAttribute("class", this.classes().concat(N.trim().split(/\s+/)).filter(function(F, Y, $) {
                            return $.indexOf(F) === Y
                        }).join(" ")), this
                    }
                    removeClass(N) {
                        const F = N.trim().split(/\s+/);
                        return this._node.setAttribute("class", this.classes().filter(Y => -1 === F.indexOf(Y)).join(" ")), this
                    }
                    removeAllClasses() {
                        return this._node.setAttribute("class", ""), this
                    }
                    height() {
                        return this._node.getBoundingClientRect().height
                    }
                    width() {
                        return this._node.getBoundingClientRect().width
                    }
                    animate(N) {
                        let F = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            Y = arguments.length > 2 ? arguments[2] : void 0;
                        return Object.keys(N).forEach($ => {
                            const K = N[$];
                            Array.isArray(K) ? K.forEach(et => xe(this, $, et, !1, Y)) : xe(this, $, K, F, Y)
                        }), this
                    }
                    constructor(N, F, Y, $, K = !1) {
                        N instanceof Element ? this._node = N : (this._node = document.createElementNS(_t.svg, N), "svg" === N && this.attr({
                            "xmlns:ct": _t.ct
                        })), F && this.attr(F), Y && this.addClass(Y), $ && (K && $._node.firstChild ? $._node.insertBefore(this._node, $._node.firstChild) : $._node.appendChild(this._node))
                    }
                }
                return W.Easing = ve, W
            })();

            function Le(W) {
                let E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "100%",
                    N = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "100%",
                    F = arguments.length > 3 ? arguments[3] : void 0;
                Array.from(W.querySelectorAll("svg")).filter($ => $.getAttributeNS(_t.xmlns, "ct")).forEach($ => W.removeChild($));
                const Y = new He("svg").attr({
                    width: E,
                    height: N
                }).attr({
                    style: "width: ".concat(E, "; height: ").concat(N, ";")
                });
                return F && Y.addClass(F), W.appendChild(Y.getNode()), Y
            }

            function Ye(W, E) {
                var N, F, Y, $;
                const K = !(!E.axisX && !E.axisY),
                    et = (null === (N = E.axisY) || void 0 === N ? void 0 : N.offset) || 0,
                    rt = (null === (F = E.axisX) || void 0 === F ? void 0 : F.offset) || 0,
                    lt = null === (Y = E.axisY) || void 0 === Y ? void 0 : Y.position,
                    ct = null === ($ = E.axisX) || void 0 === $ ? void 0 : $.position;
                let wt = W.width() || xt(E.width).value || 0,
                    st = W.height() || xt(E.height).value || 0;
                const kt = function ii(W) {
                    return "number" == typeof W ? {
                        top: W,
                        right: W,
                        bottom: W,
                        left: W
                    } : void 0 === W ? {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    } : {
                        top: "number" == typeof W.top ? W.top : 0,
                        right: "number" == typeof W.right ? W.right : 0,
                        bottom: "number" == typeof W.bottom ? W.bottom : 0,
                        left: "number" == typeof W.left ? W.left : 0
                    }
                }(E.chartPadding);
                wt = Math.max(wt, et + kt.left + kt.right), st = Math.max(st, rt + kt.top + kt.bottom);
                const gt = {
                    x1: 0,
                    x2: 0,
                    y1: 0,
                    y2: 0,
                    padding: kt,
                    width() {
                        return this.x2 - this.x1
                    },
                    height() {
                        return this.y1 - this.y2
                    }
                };
                return K ? ("start" === ct ? (gt.y2 = kt.top + rt, gt.y1 = Math.max(st - kt.bottom, gt.y2 + 1)) : (gt.y2 = kt.top, gt.y1 = Math.max(st - kt.bottom - rt, gt.y2 + 1)), "start" === lt ? (gt.x1 = kt.left + et, gt.x2 = Math.max(wt - kt.right, gt.x1 + 1)) : (gt.x1 = kt.left, gt.x2 = Math.max(wt - kt.right - et, gt.x1 + 1))) : (gt.x1 = kt.left, gt.x2 = Math.max(wt - kt.right, gt.x1 + 1), gt.y2 = kt.top, gt.y1 = Math.max(st - kt.bottom, gt.y2 + 1)), gt
            }

            function $e(W, E, N, F) {
                const Y = W.elem("rect", {
                    x: E.x1,
                    y: E.y2,
                    width: E.width(),
                    height: E.height()
                }, N, !0);
                F.emit("draw", {
                    type: "gridBackground",
                    group: W,
                    element: Y
                })
            }

            function pi(W, E, N) {
                let F;
                const Y = [];

                function $(et) {
                    const rt = F;
                    F = ze({}, W), E && E.forEach(lt => {
                        window.matchMedia(lt[0]).matches && (F = ze(F, lt[1]))
                    }), N && et && N.emit("optionsChanged", {
                        previousOptions: rt,
                        currentOptions: F
                    })
                }
                if (!window.matchMedia) throw new Error("window.matchMedia not found! Make sure you're using a polyfill.");
                return E && E.forEach(et => {
                    const rt = window.matchMedia(et[0]);
                    rt.addEventListener("change", $), Y.push(rt)
                }), $(), {
                    removeMediaQueryListeners: function K() {
                        Y.forEach(et => et.removeEventListener("change", $))
                    },
                    getCurrentOptions: () => F
                }
            }
            const zt = {
                    m: ["x", "y"],
                    l: ["x", "y"],
                    c: ["x1", "y1", "x2", "y2", "x", "y"],
                    a: ["rx", "ry", "xAr", "lAf", "sf", "x", "y"]
                },
                Qt = {
                    accuracy: 3
                };

            function Tt(W, E, N, F, Y, $) {
                const K = {
                    command: Y ? W.toLowerCase() : W.toUpperCase(),
                    ...E,
                    ...$ ? {
                        data: $
                    } : {}
                };
                N.splice(F, 0, K)
            }

            function $t(W, E) {
                W.forEach((N, F) => {
                    zt[N.command.toLowerCase()].forEach((Y, $) => {
                        E(N, Y, F, $, W)
                    })
                })
            }
            class Jt {
                static join(E) {
                    const Y = new Jt(arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 ? arguments[2] : void 0);
                    for (let $ = 0; $ < E.length; $++) {
                        const K = E[$];
                        for (let et = 0; et < K.pathElements.length; et++) Y.pathElements.push(K.pathElements[et])
                    }
                    return Y
                }
                position(E) {
                    return void 0 !== E ? (this.pos = Math.max(0, Math.min(this.pathElements.length, E)), this) : this.pos
                }
                remove(E) {
                    return this.pathElements.splice(this.pos, E), this
                }
                move(E, N) {
                    let F = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        Y = arguments.length > 3 ? arguments[3] : void 0;
                    return Tt("M", {
                        x: +E,
                        y: +N
                    }, this.pathElements, this.pos++, F, Y), this
                }
                line(E, N) {
                    let F = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        Y = arguments.length > 3 ? arguments[3] : void 0;
                    return Tt("L", {
                        x: +E,
                        y: +N
                    }, this.pathElements, this.pos++, F, Y), this
                }
                curve(E, N, F, Y, $, K) {
                    let et = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
                        rt = arguments.length > 7 ? arguments[7] : void 0;
                    return Tt("C", {
                        x1: +E,
                        y1: +N,
                        x2: +F,
                        y2: +Y,
                        x: +$,
                        y: +K
                    }, this.pathElements, this.pos++, et, rt), this
                }
                arc(E, N, F, Y, $, K, et) {
                    let rt = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
                        lt = arguments.length > 8 ? arguments[8] : void 0;
                    return Tt("A", {
                        rx: E,
                        ry: N,
                        xAr: F,
                        lAf: Y,
                        sf: $,
                        x: K,
                        y: et
                    }, this.pathElements, this.pos++, rt, lt), this
                }
                parse(E) {
                    const N = E.replace(/([A-Za-z])(-?[0-9])/g, "$1 $2").replace(/([0-9])([A-Za-z])/g, "$1 $2").split(/[\s,]+/).reduce((Y, $) => ($.match(/[A-Za-z]/) && Y.push([]), Y[Y.length - 1].push($), Y), []);
                    "Z" === N[N.length - 1][0].toUpperCase() && N.pop();
                    const F = N.map(Y => {
                        const $ = Y.shift(),
                            K = zt[$.toLowerCase()];
                        return {
                            command: $,
                            ...K.reduce((et, rt, lt) => (et[rt] = +Y[lt], et), {})
                        }
                    });
                    return this.pathElements.splice(this.pos, 0, ...F), this.pos += F.length, this
                }
                stringify() {
                    const E = Math.pow(10, this.options.accuracy);
                    return this.pathElements.reduce((N, F) => {
                        const Y = zt[F.command.toLowerCase()].map($ => {
                            const K = F[$];
                            return this.options.accuracy ? Math.round(K * E) / E : K
                        });
                        return N + F.command + Y.join(",")
                    }, "") + (this.close ? "Z" : "")
                }
                scale(E, N) {
                    return $t(this.pathElements, (F, Y) => {
                        F[Y] *= "x" === Y[0] ? E : N
                    }), this
                }
                translate(E, N) {
                    return $t(this.pathElements, (F, Y) => {
                        F[Y] += "x" === Y[0] ? E : N
                    }), this
                }
                transform(E) {
                    return $t(this.pathElements, (N, F, Y, $, K) => {
                        const et = E(N, F, Y, $, K);
                        (et || 0 === et) && (N[F] = et)
                    }), this
                }
                clone() {
                    const N = new Jt(arguments.length > 0 && void 0 !== arguments[0] && arguments[0] || this.close);
                    return N.pos = this.pos, N.pathElements = this.pathElements.slice().map(F => ({ ...F
                    })), N.options = { ...this.options
                    }, N
                }
                splitByCommand(E) {
                    const N = [new Jt];
                    return this.pathElements.forEach(F => {
                        F.command === E.toUpperCase() && 0 !== N[N.length - 1].pathElements.length && N.push(new Jt), N[N.length - 1].pathElements.push(F)
                    }), N
                }
                constructor(E = !1, N) {
                    this.close = E, this.pathElements = [], this.pos = 0, this.options = { ...Qt,
                        ...N
                    }
                }
            }

            function Ct(W) {
                const E = {
                    fillHoles: !1,
                    ...W
                };
                return function(F, Y) {
                    const $ = new Jt;
                    let K = !0;
                    for (let et = 0; et < F.length; et += 2) {
                        const rt = F[et],
                            lt = F[et + 1],
                            ct = Y[et / 2];
                        void 0 !== ci(ct.value) ? (K ? $.move(rt, lt, !1, ct) : $.line(rt, lt, !1, ct), K = !1) : E.fillHoles || (K = !0)
                    }
                    return $
                }
            }

            function Yt(W) {
                const E = {
                    fillHoles: !1,
                    ...W
                };
                return function N(F, Y) {
                    const $ = Yi(F, Y, {
                        fillHoles: E.fillHoles,
                        increasingX: !0
                    });
                    if ($.length) {
                        if ($.length > 1) return Jt.join($.map(K => N(K.pathCoordinates, K.valueData))); {
                            if (Y = $[0].valueData, (F = $[0].pathCoordinates).length <= 4) return Ct()(F, Y);
                            const K = [],
                                et = [],
                                rt = F.length / 2,
                                lt = [],
                                ct = [],
                                wt = [],
                                st = [];
                            for (let gt = 0; gt < rt; gt++) K[gt] = F[2 * gt], et[gt] = F[2 * gt + 1];
                            for (let gt = 0; gt < rt - 1; gt++) wt[gt] = et[gt + 1] - et[gt], st[gt] = K[gt + 1] - K[gt], ct[gt] = wt[gt] / st[gt];
                            lt[0] = ct[0], lt[rt - 1] = ct[rt - 2];
                            for (let gt = 1; gt < rt - 1; gt++) 0 === ct[gt] || 0 === ct[gt - 1] || ct[gt - 1] > 0 != ct[gt] > 0 ? lt[gt] = 0 : (lt[gt] = 3 * (st[gt - 1] + st[gt]) / ((2 * st[gt] + st[gt - 1]) / ct[gt - 1] + (st[gt] + 2 * st[gt - 1]) / ct[gt]), isFinite(lt[gt]) || (lt[gt] = 0));
                            const kt = (new Jt).move(K[0], et[0], !1, Y[0]);
                            for (let gt = 0; gt < rt - 1; gt++) kt.curve(K[gt] + st[gt] / 3, et[gt] + lt[gt] * st[gt] / 3, K[gt + 1] - st[gt] / 3, et[gt + 1] - lt[gt + 1] * st[gt] / 3, K[gt + 1], et[gt + 1], !1, Y[gt + 1]);
                            return kt
                        }
                    }
                    return Ct()([], [])
                }
            }
            var xi = Object.freeze({
                __proto__: null,
                none: Ct,
                simple: function Qi(W) {
                    const E = {
                            divisor: 2,
                            fillHoles: !1,
                            ...W
                        },
                        N = 1 / Math.max(1, E.divisor);
                    return function(Y, $) {
                        const K = new Jt;
                        let lt, et = 0,
                            rt = 0;
                        for (let ct = 0; ct < Y.length; ct += 2) {
                            const wt = Y[ct],
                                st = Y[ct + 1],
                                kt = (wt - et) * N,
                                gt = $[ct / 2];
                            void 0 !== gt.value ? (void 0 === lt ? K.move(wt, st, !1, gt) : K.curve(et + kt, rt, wt - kt, st, wt, st, !1, gt), et = wt, rt = st, lt = gt) : E.fillHoles || (et = rt = 0, lt = void 0)
                        }
                        return K
                    }
                },
                step: function Wi(W) {
                    const E = {
                        postpone: !0,
                        fillHoles: !1,
                        ...W
                    };
                    return function(F, Y) {
                        const $ = new Jt;
                        let rt, K = 0,
                            et = 0;
                        for (let lt = 0; lt < F.length; lt += 2) {
                            const ct = F[lt],
                                wt = F[lt + 1],
                                st = Y[lt / 2];
                            void 0 !== st.value ? (void 0 === rt ? $.move(ct, wt, !1, st) : (E.postpone ? $.line(ct, et, !1, rt) : $.line(K, wt, !1, st), $.line(ct, wt, !1, st)), K = ct, et = wt, rt = st) : E.fillHoles || (K = et = 0, rt = void 0)
                        }
                        return $
                    }
                },
                cardinal: function qt(W) {
                    const E = {
                            tension: 1,
                            fillHoles: !1,
                            ...W
                        },
                        N = Math.min(1, Math.max(0, E.tension)),
                        F = 1 - N;
                    return function Y($, K) {
                        const et = Yi($, K, {
                            fillHoles: E.fillHoles
                        });
                        if (et.length) {
                            if (et.length > 1) return Jt.join(et.map(rt => Y(rt.pathCoordinates, rt.valueData))); {
                                if (K = et[0].valueData, ($ = et[0].pathCoordinates).length <= 4) return Ct()($, K);
                                const rt = (new Jt).move($[0], $[1], !1, K[0]),
                                    lt = !1;
                                for (let ct = 0, wt = $.length; wt - 2 * +!lt > ct; ct += 2) {
                                    const st = [{
                                        x: +$[ct - 2],
                                        y: +$[ct - 1]
                                    }, {
                                        x: +$[ct],
                                        y: +$[ct + 1]
                                    }, {
                                        x: +$[ct + 2],
                                        y: +$[ct + 3]
                                    }, {
                                        x: +$[ct + 4],
                                        y: +$[ct + 5]
                                    }];
                                    wt - 4 === ct ? st[3] = st[2] : ct || (st[0] = {
                                        x: +$[ct],
                                        y: +$[ct + 1]
                                    }), rt.curve(N * (6 * st[1].x - st[0].x + st[2].x) / 6 + F * st[2].x, N * (6 * st[1].y - st[0].y + st[2].y) / 6 + F * st[2].y, N * (st[1].x + 6 * st[2].x - st[3].x) / 6 + F * st[2].x, N * (st[1].y + 6 * st[2].y - st[3].y) / 6 + F * st[2].y, st[2].x, st[2].y, !1, K[(ct + 2) / 2])
                                }
                                return rt
                            }
                        }
                        return Ct()([], [])
                    }
                },
                monotoneCubic: Yt
            });
            class Ve {
                on(E, N) {
                    const {
                        allListeners: F,
                        listeners: Y
                    } = this;
                    "*" === E ? F.add(N) : (Y.has(E) || Y.set(E, new Set), Y.get(E).add(N))
                }
                off(E, N) {
                    const {
                        allListeners: F,
                        listeners: Y
                    } = this;
                    if ("*" === E) N ? F.delete(N) : F.clear();
                    else if (Y.has(E)) {
                        const $ = Y.get(E);
                        N ? $.delete(N) : $.clear(), $.size || Y.delete(E)
                    }
                }
                emit(E, N) {
                    const {
                        allListeners: F,
                        listeners: Y
                    } = this;
                    Y.has(E) && Y.get(E).forEach($ => $(N)), F.forEach($ => $(E, N))
                }
                constructor() {
                    this.listeners = new Map, this.allListeners = new Set
                }
            }
            const mi = new WeakMap;
            class bi {
                update(E, N) {
                    let F = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    var Y;
                    return E && (this.data = E || {}, this.data.labels = this.data.labels || [], this.data.series = this.data.series || [], this.eventEmitter.emit("data", {
                        type: "update",
                        data: this.data
                    })), N && (this.options = ze({}, F ? this.options : this.defaultOptions, N), !this.initializeTimeoutId) && (null === (Y = this.optionsProvider) || void 0 === Y || Y.removeMediaQueryListeners(), this.optionsProvider = pi(this.options, this.responsiveOptions, this.eventEmitter)), !this.initializeTimeoutId && this.optionsProvider && this.createChart(this.optionsProvider.getCurrentOptions()), this
                }
                detach() {
                    var E;
                    return this.initializeTimeoutId ? window.clearTimeout(this.initializeTimeoutId) : (window.removeEventListener("resize", this.resizeListener), null === (E = this.optionsProvider) || void 0 === E || E.removeMediaQueryListeners()), mi.delete(this.container), this
                }
                on(E, N) {
                    return this.eventEmitter.on(E, N), this
                }
                off(E, N) {
                    return this.eventEmitter.off(E, N), this
                }
                initialize() {
                    window.addEventListener("resize", this.resizeListener), this.optionsProvider = pi(this.options, this.responsiveOptions, this.eventEmitter), this.eventEmitter.on("optionsChanged", () => this.update()), this.options.plugins && this.options.plugins.forEach(E => {
                        Array.isArray(E) ? E[0](this, E[1]) : E(this)
                    }), this.eventEmitter.emit("data", {
                        type: "initial",
                        data: this.data
                    }), this.createChart(this.optionsProvider.getCurrentOptions()), this.initializeTimeoutId = null
                }
                constructor(E, N, F, Y, $) {
                    this.data = N, this.defaultOptions = F, this.options = Y, this.responsiveOptions = $, this.eventEmitter = new Ve, this.resizeListener = () => this.update(), this.initializeTimeoutId = setTimeout(() => this.initialize(), 0);
                    const K = "string" == typeof E ? document.querySelector(E) : E;
                    if (!K) throw new Error("Target element is not found");
                    this.container = K;
                    const et = mi.get(K);
                    et && et.detach(), mi.set(K, this)
                }
            }
            const re = {
                x: {
                    pos: "x",
                    len: "width",
                    dir: "horizontal",
                    rectStart: "x1",
                    rectEnd: "x2",
                    rectOffset: "y2"
                },
                y: {
                    pos: "y",
                    len: "height",
                    dir: "vertical",
                    rectStart: "y2",
                    rectEnd: "y1",
                    rectOffset: "x1"
                }
            };
            class qe {
                createGridAndLabels(E, N, F, Y) {
                    const $ = "x" === this.units.pos ? F.axisX : F.axisY,
                        K = this.ticks.map((rt, lt) => this.projectValue(rt, lt)),
                        et = this.ticks.map($.labelInterpolationFnc);
                    K.forEach((rt, lt) => {
                        const ct = et[lt],
                            wt = {
                                x: 0,
                                y: 0
                            };
                        let st;
                        st = K[lt + 1] ? K[lt + 1] - rt : Math.max(this.axisLength - rt, this.axisLength / this.ticks.length), ("" === ct || !ot(ct)) && ("x" === this.units.pos ? (rt = this.chartRect.x1 + rt, wt.x = F.axisX.labelOffset.x, wt.y = "start" === F.axisX.position ? this.chartRect.padding.top + F.axisX.labelOffset.y + 5 : this.chartRect.y1 + F.axisX.labelOffset.y + 5) : (rt = this.chartRect.y1 - rt, wt.y = F.axisY.labelOffset.y - st, wt.x = "start" === F.axisY.position ? this.chartRect.padding.left + F.axisY.labelOffset.x : this.chartRect.x2 + F.axisY.labelOffset.x + 10), $.showGrid && function We(W, E, N, F, Y, $, K, et) {
                            const rt = {
                                    ["".concat(N.units.pos, "1")]: W,
                                    ["".concat(N.units.pos, "2")]: W,
                                    ["".concat(N.counterUnits.pos, "1")]: F,
                                    ["".concat(N.counterUnits.pos, "2")]: F + Y
                                },
                                lt = $.elem("line", rt, K.join(" "));
                            et.emit("draw", {
                                type: "grid",
                                axis: N,
                                index: E,
                                group: $,
                                element: lt,
                                ...rt
                            })
                        }(rt, lt, this, this.gridOffset, this.chartRect[this.counterUnits.len](), E, [F.classNames.grid, F.classNames[this.units.dir]], Y), $.showLabel && function Ae(W, E, N, F, Y, $, K, et, rt, lt) {
                            const ct = {
                                    [Y.units.pos]: W + K[Y.units.pos],
                                    [Y.counterUnits.pos]: K[Y.counterUnits.pos],
                                    [Y.units.len]: E,
                                    [Y.counterUnits.len]: Math.max(0, $ - 10)
                                },
                                wt = Math.round(ct[Y.units.len]),
                                st = Math.round(ct[Y.counterUnits.len]),
                                kt = document.createElement("span");
                            kt.className = rt.join(" "), kt.style[Y.units.len] = wt + "px", kt.style[Y.counterUnits.len] = st + "px", kt.textContent = String(F);
                            const gt = et.foreignObject(kt, {
                                style: "overflow: visible;",
                                ...ct
                            });
                            lt.emit("draw", {
                                type: "label",
                                axis: Y,
                                index: N,
                                group: et,
                                element: gt,
                                text: F,
                                ...ct
                            })
                        }(rt, st, lt, ct, this, $.offset, wt, N, [F.classNames.label, F.classNames[this.units.dir], "start" === $.position ? F.classNames[$.position] : F.classNames.end], Y))
                    })
                }
                constructor(E, N, F) {
                    this.units = E, this.chartRect = N, this.ticks = F, this.counterUnits = E === re.x ? re.y : re.x, this.axisLength = N[this.units.rectEnd] - N[this.units.rectStart], this.gridOffset = N[this.units.rectOffset]
                }
            }
            class vi extends qe {
                projectValue(E) {
                    const N = Number(ci(E, this.units.pos));
                    return this.axisLength * (N - this.bounds.min) / this.bounds.range
                }
                constructor(E, N, F, Y) {
                    const $ = Y.highLow || ne(N, Y, E.pos),
                        K = function Me(W, E, N) {
                            let F = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                            const Y = {
                                high: E.high,
                                low: E.low,
                                valueRange: 0,
                                oom: 0,
                                step: 0,
                                min: 0,
                                max: 0,
                                range: 0,
                                numberOfSteps: 0,
                                values: []
                            };
                            Y.valueRange = Y.high - Y.low, Y.oom = function Et(W) {
                                return Math.floor(Math.log(Math.abs(W)) / Math.LN10)
                            }(Y.valueRange), Y.step = Math.pow(10, Y.oom), Y.min = Math.floor(Y.low / Y.step) * Y.step, Y.max = Math.ceil(Y.high / Y.step) * Y.step, Y.range = Y.max - Y.min, Y.numberOfSteps = Math.round(Y.range / Y.step);
                            const K = Rt(W, Y.step, Y) < N,
                                et = F ? function Ft(W) {
                                    if (1 === W) return W;

                                    function E(K, et) {
                                        return K % et == 0 ? et : E(et, K % et)
                                    }

                                    function N(K) {
                                        return K * K + 1
                                    }
                                    let $, F = 2,
                                        Y = 2;
                                    if (W % 2 == 0) return 2;
                                    do {
                                        F = N(F) % W, Y = N(N(Y)) % W, $ = E(Math.abs(F - Y), W)
                                    } while (1 === $);
                                    return $
                                }(Y.range) : 0;
                            if (F && Rt(W, 1, Y) >= N) Y.step = 1;
                            else if (F && et < Y.step && Rt(W, et, Y) >= N) Y.step = et;
                            else {
                                let st = 0;
                                for (;;) {
                                    if (K && Rt(W, Y.step, Y) <= N) Y.step *= 2;
                                    else {
                                        if (K || !(Rt(W, Y.step / 2, Y) >= N)) break;
                                        if (Y.step /= 2, F && Y.step % 1 != 0) {
                                            Y.step *= 2;
                                            break
                                        }
                                    }
                                    if (st++ > 1e3) throw new Error("Exceeded maximum number of iterations while optimizing scale step!")
                                }
                            }

                            function rt(st, kt) {
                                return st === (st += kt) && (st *= 1 + (kt > 0 ? ht : -ht)), st
                            }
                            Y.step = Math.max(Y.step, ht);
                            let lt = Y.min,
                                ct = Y.max;
                            for (; lt + Y.step <= Y.low;) lt = rt(lt, Y.step);
                            for (; ct - Y.step >= Y.high;) ct = rt(ct, -Y.step);
                            Y.min = lt, Y.max = ct, Y.range = Y.max - Y.min;
                            const wt = [];
                            for (let st = Y.min; st <= Y.max; st = rt(st, Y.step)) {
                                const kt = bt(st);
                                kt !== wt[wt.length - 1] && wt.push(kt)
                            }
                            return Y.values = wt, Y
                        }(F[E.rectEnd] - F[E.rectStart], $, Y.scaleMinSpace || 20, Y.onlyInteger),
                        et = {
                            min: K.min,
                            max: K.max
                        };
                    super(E, F, K.values), this.bounds = K, this.range = et
                }
            }
            class Ke extends qe {
                projectValue(E, N) {
                    return this.stepLength * N
                }
                constructor(E, N, F, Y) {
                    const $ = Y.ticks || [];
                    super(E, F, $);
                    const K = Math.max(1, $.length - (Y.stretch ? 1 : 0));
                    this.stepLength = this.axisLength / K, this.stretch = !!Y.stretch
                }
            }

            function si(W, E, N) {
                var F;
                if (Bt(W, "name") && W.name && null !== (F = E.series) && void 0 !== F && F[W.name]) {
                    const $ = (E ? .series[W.name])[N];
                    return void 0 === $ ? E[N] : $
                }
                return E[N]
            }
            const Vi = {
                axisX: {
                    offset: 30,
                    position: "end",
                    labelOffset: {
                        x: 0,
                        y: 0
                    },
                    showLabel: !0,
                    showGrid: !0,
                    labelInterpolationFnc: le,
                    type: void 0
                },
                axisY: {
                    offset: 40,
                    position: "start",
                    labelOffset: {
                        x: 0,
                        y: 0
                    },
                    showLabel: !0,
                    showGrid: !0,
                    labelInterpolationFnc: le,
                    type: void 0,
                    scaleMinSpace: 20,
                    onlyInteger: !1
                },
                width: void 0,
                height: void 0,
                showLine: !0,
                showPoint: !0,
                showArea: !1,
                areaBase: 0,
                lineSmooth: !0,
                showGridBackground: !1,
                low: void 0,
                high: void 0,
                chartPadding: {
                    top: 15,
                    right: 15,
                    bottom: 5,
                    left: 10
                },
                fullWidth: !1,
                reverseData: !1,
                classNames: {
                    chart: "ct-chart-line",
                    label: "ct-label",
                    labelGroup: "ct-labels",
                    series: "ct-series",
                    line: "ct-line",
                    point: "ct-point",
                    area: "ct-area",
                    grid: "ct-grid",
                    gridGroup: "ct-grids",
                    gridBackground: "ct-grid-background",
                    vertical: "ct-vertical",
                    horizontal: "ct-horizontal",
                    start: "ct-start",
                    end: "ct-end"
                }
            };
            class Fe extends bi {
                createChart(E) {
                    const {
                        data: N
                    } = this, F = Be(N, E.reverseData, !0), Y = Le(this.container, E.width, E.height, E.classNames.chart);
                    this.svg = Y;
                    const $ = Y.elem("g").addClass(E.classNames.gridGroup),
                        K = Y.elem("g"),
                        et = Y.elem("g").addClass(E.classNames.labelGroup),
                        rt = Ye(Y, E);
                    let lt, ct;
                    lt = void 0 === E.axisX.type ? new Ke(re.x, F.series, rt, { ...E.axisX,
                        ticks: F.labels,
                        stretch: E.fullWidth
                    }) : new E.axisX.type(re.x, F.series, rt, E.axisX), ct = void 0 === E.axisY.type ? new vi(re.y, F.series, rt, { ...E.axisY,
                        high: ae(E.high) ? E.high : E.axisY.high,
                        low: ae(E.low) ? E.low : E.axisY.low
                    }) : new E.axisY.type(re.y, F.series, rt, E.axisY), lt.createGridAndLabels($, et, E, this.eventEmitter), ct.createGridAndLabels($, et, E, this.eventEmitter), E.showGridBackground && $e($, rt, E.classNames.gridBackground, this.eventEmitter), li(N.series, (wt, st) => {
                        const kt = K.elem("g"),
                            gt = Bt(wt, "name") && wt.name,
                            Gt = Bt(wt, "className") && wt.className,
                            Ut = Bt(wt, "meta") ? wt.meta : void 0;
                        gt && kt.attr({
                            "ct:series-name": gt
                        }), Ut && kt.attr({
                            "ct:meta": ce(Ut)
                        }), kt.addClass([E.classNames.series, Gt || "".concat(E.classNames.series, "-").concat(be(st))].join(" "));
                        const _e = [],
                            Te = [];
                        F.series[st].forEach((Lt, Mt) => {
                            const _ = {
                                x: rt.x1 + lt.projectValue(Lt, Mt, F.series[st]),
                                y: rt.y1 - ct.projectValue(Lt, Mt, F.series[st])
                            };
                            _e.push(_.x, _.y), Te.push({
                                value: Lt,
                                valueIndex: Mt,
                                meta: hi(wt, Mt)
                            })
                        });
                        const ge = {
                            lineSmooth: si(wt, E, "lineSmooth"),
                            showPoint: si(wt, E, "showPoint"),
                            showLine: si(wt, E, "showLine"),
                            showArea: si(wt, E, "showArea"),
                            areaBase: si(wt, E, "areaBase")
                        };
                        let Se;
                        Se = "function" == typeof ge.lineSmooth ? ge.lineSmooth : ge.lineSmooth ? Yt() : Ct();
                        const Wt = Se(_e, Te);
                        if (ge.showPoint && Wt.pathElements.forEach(Lt => {
                                const {
                                    data: Mt
                                } = Lt, _ = kt.elem("line", {
                                    x1: Lt.x,
                                    y1: Lt.y,
                                    x2: Lt.x + .01,
                                    y2: Lt.y
                                }, E.classNames.point);
                                if (Mt) {
                                    let t, e;
                                    Bt(Mt.value, "x") && (t = Mt.value.x), Bt(Mt.value, "y") && (e = Mt.value.y), _.attr({
                                        "ct:value": [t, e].filter(ae).join(","),
                                        "ct:meta": ce(Mt.meta)
                                    })
                                }
                                this.eventEmitter.emit("draw", {
                                    type: "point",
                                    value: Mt ? .value,
                                    index: Mt ? .valueIndex || 0,
                                    meta: Mt ? .meta,
                                    series: wt,
                                    seriesIndex: st,
                                    axisX: lt,
                                    axisY: ct,
                                    group: kt,
                                    element: _,
                                    x: Lt.x,
                                    y: Lt.y,
                                    chartRect: rt
                                })
                            }), ge.showLine) {
                            const Lt = kt.elem("path", {
                                d: Wt.stringify()
                            }, E.classNames.line, !0);
                            this.eventEmitter.emit("draw", {
                                type: "line",
                                values: F.series[st],
                                path: Wt.clone(),
                                chartRect: rt,
                                index: st,
                                series: wt,
                                seriesIndex: st,
                                meta: Ut,
                                axisX: lt,
                                axisY: ct,
                                group: kt,
                                element: Lt
                            })
                        }
                        if (ge.showArea && ct.range) {
                            const Lt = Math.max(Math.min(ge.areaBase, ct.range.max), ct.range.min),
                                Mt = rt.y1 - ct.projectValue(Lt);
                            Wt.splitByCommand("M").filter(_ => _.pathElements.length > 1).map(_ => {
                                const t = _.pathElements[0],
                                    e = _.pathElements[_.pathElements.length - 1];
                                return _.clone(!0).position(0).remove(1).move(t.x, Mt).line(t.x, t.y).position(_.pathElements.length + 1).line(e.x, Mt)
                            }).forEach(_ => {
                                const t = kt.elem("path", {
                                    d: _.stringify()
                                }, E.classNames.area, !0);
                                this.eventEmitter.emit("draw", {
                                    type: "area",
                                    values: F.series[st],
                                    path: _.clone(),
                                    series: wt,
                                    seriesIndex: st,
                                    axisX: lt,
                                    axisY: ct,
                                    chartRect: rt,
                                    index: st,
                                    group: kt,
                                    element: t,
                                    meta: Ut
                                })
                            })
                        }
                    }, E.reverseData), this.eventEmitter.emit("created", {
                        chartRect: rt,
                        axisX: lt,
                        axisY: ct,
                        svg: Y,
                        options: E
                    })
                }
                constructor(E, N, F, Y) {
                    super(E, N, Vi, ze({}, Vi, F), Y), this.data = N
                }
            }

            function yi(W) {
                return ((W, E) => ei(Math.max(...W.map(N => N.length)), N => function() {
                    for (var E = arguments.length, N = new Array(E), F = 0; F < E; F++) N[F] = arguments[F];
                    return Array.from(N).reduce((Y, $) => ({
                        x: Y.x + (Bt($, "x") ? $.x : 0),
                        y: Y.y + (Bt($, "y") ? $.y : 0)
                    }), {
                        x: 0,
                        y: 0
                    })
                }(...W.map(F => F[N]))))(W)
            }
            const Qe = {
                axisX: {
                    offset: 30,
                    position: "end",
                    labelOffset: {
                        x: 0,
                        y: 0
                    },
                    showLabel: !0,
                    showGrid: !0,
                    labelInterpolationFnc: le,
                    scaleMinSpace: 30,
                    onlyInteger: !1
                },
                axisY: {
                    offset: 40,
                    position: "start",
                    labelOffset: {
                        x: 0,
                        y: 0
                    },
                    showLabel: !0,
                    showGrid: !0,
                    labelInterpolationFnc: le,
                    scaleMinSpace: 20,
                    onlyInteger: !1
                },
                width: void 0,
                height: void 0,
                high: void 0,
                low: void 0,
                referenceValue: 0,
                chartPadding: {
                    top: 15,
                    right: 15,
                    bottom: 5,
                    left: 10
                },
                seriesBarDistance: 15,
                stackBars: !1,
                stackMode: "accumulate",
                horizontalBars: !1,
                distributeSeries: !1,
                reverseData: !1,
                showGridBackground: !1,
                classNames: {
                    chart: "ct-chart-bar",
                    horizontalBars: "ct-horizontal-bars",
                    label: "ct-label",
                    labelGroup: "ct-labels",
                    series: "ct-series",
                    bar: "ct-bar",
                    grid: "ct-grid",
                    gridGroup: "ct-grids",
                    gridBackground: "ct-grid-background",
                    vertical: "ct-vertical",
                    horizontal: "ct-horizontal",
                    start: "ct-start",
                    end: "ct-end"
                }
            };
            class Xe extends bi {
                createChart(E) {
                    const {
                        data: N
                    } = this, F = Be(N, E.reverseData, E.horizontalBars ? "x" : "y", !0), Y = Le(this.container, E.width, E.height, E.classNames.chart + (E.horizontalBars ? " " + E.classNames.horizontalBars : "")), $ = ne(E.stackBars && !0 !== E.stackMode && F.series.length ? [yi(F.series)] : F.series, E, E.horizontalBars ? "x" : "y");
                    this.svg = Y;
                    const K = Y.elem("g").addClass(E.classNames.gridGroup),
                        et = Y.elem("g"),
                        rt = Y.elem("g").addClass(E.classNames.labelGroup);
                    "number" == typeof E.high && ($.high = E.high), "number" == typeof E.low && ($.low = E.low);
                    const lt = Ye(Y, E);
                    let ct;
                    const wt = E.distributeSeries && E.stackBars ? F.labels.slice(0, 1) : F.labels;
                    let st, kt, gt;
                    E.horizontalBars ? (ct = kt = void 0 === E.axisX.type ? new vi(re.x, F.series, lt, { ...E.axisX,
                        highLow: $,
                        referenceValue: 0
                    }) : new E.axisX.type(re.x, F.series, lt, { ...E.axisX,
                        highLow: $,
                        referenceValue: 0
                    }), st = gt = void 0 === E.axisY.type ? new Ke(re.y, F.series, lt, {
                        ticks: wt
                    }) : new E.axisY.type(re.y, F.series, lt, E.axisY)) : (st = kt = void 0 === E.axisX.type ? new Ke(re.x, F.series, lt, {
                        ticks: wt
                    }) : new E.axisX.type(re.x, F.series, lt, E.axisX), ct = gt = void 0 === E.axisY.type ? new vi(re.y, F.series, lt, { ...E.axisY,
                        highLow: $,
                        referenceValue: 0
                    }) : new E.axisY.type(re.y, F.series, lt, { ...E.axisY,
                        highLow: $,
                        referenceValue: 0
                    }));
                    const Gt = E.horizontalBars ? lt.x1 + ct.projectValue(0) : lt.y1 - ct.projectValue(0),
                        Ut = "accumulate" === E.stackMode,
                        _e = "accumulate-relative" === E.stackMode,
                        Te = [],
                        ge = [];
                    let Se = Te;
                    st.createGridAndLabels(K, rt, E, this.eventEmitter), ct.createGridAndLabels(K, rt, E, this.eventEmitter), E.showGridBackground && $e(K, lt, E.classNames.gridBackground, this.eventEmitter), li(N.series, (Wt, Lt) => {
                        const Mt = Lt - (N.series.length - 1) / 2;
                        let _;
                        _ = E.distributeSeries && !E.stackBars ? st.axisLength / F.series.length / 2 : E.distributeSeries && E.stackBars ? st.axisLength / 2 : st.axisLength / F.series[Lt].length / 2;
                        const t = et.elem("g"),
                            e = Bt(Wt, "name") && Wt.name,
                            i = Bt(Wt, "className") && Wt.className,
                            r = Bt(Wt, "meta") ? Wt.meta : void 0;
                        e && t.attr({
                            "ct:series-name": e
                        }), r && t.attr({
                            "ct:meta": ce(r)
                        }), t.addClass([E.classNames.series, i || "".concat(E.classNames.series, "-").concat(be(Lt))].join(" ")), F.series[Lt].forEach((l, h) => {
                            const d = Bt(l, "x") && l.x,
                                g = Bt(l, "y") && l.y;
                            let x, b;
                            x = E.distributeSeries && !E.stackBars ? Lt : E.distributeSeries && E.stackBars ? 0 : h, b = E.horizontalBars ? {
                                x: lt.x1 + ct.projectValue(d || 0, h, F.series[Lt]),
                                y: lt.y1 - st.projectValue(g || 0, x, F.series[Lt])
                            } : {
                                x: lt.x1 + st.projectValue(d || 0, x, F.series[Lt]),
                                y: lt.y1 - ct.projectValue(g || 0, h, F.series[Lt])
                            }, st instanceof Ke && (st.stretch || (b[st.units.pos] += _ * (E.horizontalBars ? -1 : 1)), b[st.units.pos] += E.stackBars || E.distributeSeries ? 0 : Mt * E.seriesBarDistance * (E.horizontalBars ? -1 : 1)), _e && (Se = g >= 0 || d >= 0 ? Te : ge);
                            const v = Se[h] || Gt;
                            if (Se[h] = v - (Gt - b[st.counterUnits.pos]), void 0 === l) return;
                            const w = {
                                ["".concat(st.units.pos, "1")]: b[st.units.pos],
                                ["".concat(st.units.pos, "2")]: b[st.units.pos]
                            };
                            E.stackBars && (Ut || _e || !E.stackMode) ? (w["".concat(st.counterUnits.pos, "1")] = v, w["".concat(st.counterUnits.pos, "2")] = Se[h]) : (w["".concat(st.counterUnits.pos, "1")] = Gt, w["".concat(st.counterUnits.pos, "2")] = b[st.counterUnits.pos]), w.x1 = Math.min(Math.max(w.x1, lt.x1), lt.x2), w.x2 = Math.min(Math.max(w.x2, lt.x1), lt.x2), w.y1 = Math.min(Math.max(w.y1, lt.y2), lt.y1), w.y2 = Math.min(Math.max(w.y2, lt.y2), lt.y1);
                            const S = hi(Wt, h),
                                C = t.elem("line", w, E.classNames.bar).attr({
                                    "ct:value": [d, g].filter(ae).join(","),
                                    "ct:meta": ce(S)
                                });
                            this.eventEmitter.emit("draw", {
                                type: "bar",
                                value: l,
                                index: h,
                                meta: S,
                                series: Wt,
                                seriesIndex: Lt,
                                axisX: kt,
                                axisY: gt,
                                chartRect: lt,
                                group: t,
                                element: C,
                                ...w
                            })
                        })
                    }, E.reverseData), this.eventEmitter.emit("created", {
                        chartRect: lt,
                        axisX: kt,
                        axisY: gt,
                        svg: Y,
                        options: E
                    })
                }
                constructor(E, N, F, Y) {
                    super(E, N, Qe, ze({}, Qe, F), Y), this.data = N
                }
            }
            const Ne = {
                width: void 0,
                height: void 0,
                chartPadding: 5,
                classNames: {
                    chartPie: "ct-chart-pie",
                    chartDonut: "ct-chart-donut",
                    series: "ct-series",
                    slicePie: "ct-slice-pie",
                    sliceDonut: "ct-slice-donut",
                    label: "ct-label"
                },
                startAngle: 0,
                total: void 0,
                donut: !1,
                donutWidth: 60,
                showLabel: !0,
                labelOffset: 0,
                labelPosition: "inside",
                labelInterpolationFnc: le,
                labelDirection: "neutral",
                ignoreEmptyValues: !1
            };

            function Gi(W, E, N) {
                const F = E.x > W.x;
                return F && "explode" === N || !F && "implode" === N ? "start" : F && "implode" === N || !F && "explode" === N ? "end" : "middle"
            }
            class jt extends bi {
                createChart(E) {
                    const {
                        data: N
                    } = this, F = Be(N), Y = [];
                    let $, K, et = E.startAngle;
                    const rt = Le(this.container, E.width, E.height, E.donut ? E.classNames.chartDonut : E.classNames.chartPie);
                    this.svg = rt;
                    const lt = Ye(rt, E);
                    let ct = Math.min(lt.width() / 2, lt.height() / 2);
                    const wt = E.total || F.series.reduce(Pi, 0),
                        st = xt(E.donutWidth);
                    "%" === st.unit && (st.value *= ct / 100), ct -= E.donut ? st.value / 2 : 0, K = "outside" === E.labelPosition || E.donut ? ct : "center" === E.labelPosition ? 0 : ct / 2, E.labelOffset && (K += E.labelOffset);
                    const kt = {
                            x: lt.x1 + lt.width() / 2,
                            y: lt.y2 + lt.height() / 2
                        },
                        gt = 1 === N.series.filter(Gt => Bt(Gt, "value") ? 0 !== Gt.value : 0 !== Gt).length;
                    N.series.forEach((Gt, Ut) => Y[Ut] = rt.elem("g")), E.showLabel && ($ = rt.elem("g")), N.series.forEach((Gt, Ut) => {
                        var _e, Te;
                        if (0 === F.series[Ut] && E.ignoreEmptyValues) return;
                        const ge = Bt(Gt, "name") && Gt.name,
                            Se = Bt(Gt, "className") && Gt.className,
                            Wt = Bt(Gt, "meta") ? Gt.meta : void 0;
                        ge && Y[Ut].attr({
                            "ct:series-name": ge
                        }), Y[Ut].addClass([null === (_e = E.classNames) || void 0 === _e ? void 0 : _e.series, Se || "".concat(null === (Te = E.classNames) || void 0 === Te ? void 0 : Te.series, "-").concat(be(Ut))].join(" "));
                        let Lt = wt > 0 ? et + F.series[Ut] / wt * 360 : 0;
                        const Mt = Math.max(0, et - (0 === Ut || gt ? 0 : .2));
                        Lt - Mt >= 359.99 && (Lt = Mt + 359.99);
                        const _ = ue(kt.x, kt.y, ct, Mt),
                            t = ue(kt.x, kt.y, ct, Lt),
                            e = new Jt(!E.donut).move(t.x, t.y).arc(ct, ct, 0, +(Lt - et > 180), 0, _.x, _.y);
                        E.donut || e.line(kt.x, kt.y);
                        const i = Y[Ut].elem("path", {
                            d: e.stringify()
                        }, E.donut ? E.classNames.sliceDonut : E.classNames.slicePie);
                        if (i.attr({
                                "ct:value": F.series[Ut],
                                "ct:meta": ce(Wt)
                            }), E.donut && i.attr({
                                style: "stroke-width: " + st.value + "px"
                            }), this.eventEmitter.emit("draw", {
                                type: "slice",
                                value: F.series[Ut],
                                totalDataSum: wt,
                                index: Ut,
                                meta: Wt,
                                series: Gt,
                                group: Y[Ut],
                                element: i,
                                path: e.clone(),
                                center: kt,
                                radius: ct,
                                startAngle: et,
                                endAngle: Lt,
                                chartRect: lt
                            }), E.showLabel) {
                            let r, l;
                            r = 1 === N.series.length ? {
                                x: kt.x,
                                y: kt.y
                            } : ue(kt.x, kt.y, K, et + (Lt - et) / 2), l = F.labels && !ot(F.labels[Ut]) ? F.labels[Ut] : F.series[Ut];
                            const h = E.labelInterpolationFnc(l, Ut);
                            if (h || 0 === h) {
                                const d = $.elem("text", {
                                    dx: r.x,
                                    dy: r.y,
                                    "text-anchor": Gi(kt, r, E.labelDirection)
                                }, E.classNames.label).text(String(h));
                                this.eventEmitter.emit("draw", {
                                    type: "label",
                                    index: Ut,
                                    group: $,
                                    element: d,
                                    text: "" + h,
                                    chartRect: lt,
                                    series: Gt,
                                    meta: Wt,
                                    ...r
                                })
                            }
                        }
                        et = Lt
                    }), this.eventEmitter.emit("created", {
                        chartRect: lt,
                        svg: rt,
                        options: E
                    })
                }
                constructor(E, N, F, Y) {
                    super(E, N, Ne, ze({}, Ne, F), Y), this.data = N
                }
            }
        },
        6903: (Mi, je, Nt) => {
            Nt.d(je, {
                X: () => ht,
                x: () => xt
            });
            var _t = Nt(5879),
                pe = Nt(6410),
                ut = Nt(5054);
            const Zt = ["chart"];
            let xt = (() => {
                class Et {
                    constructor(bt) {
                        this.ngZone = bt, this.autoUpdateSeries = !0
                    }
                    ngOnChanges(bt) {
                        pe.E.schedule(() => {
                            this.autoUpdateSeries && 0 === Object.keys(bt).filter(Ft => "series" !== Ft).length ? this.updateSeries(this.series, !0) : this.createElement()
                        })
                    }
                    ngOnDestroy() {
                        this.chartObj && this.chartObj.destroy()
                    }
                    createElement() {
                        const bt = {};
                        this.annotations && (bt.annotations = this.annotations), this.chart && (bt.chart = this.chart), this.colors && (bt.colors = this.colors), this.dataLabels && (bt.dataLabels = this.dataLabels), this.series && (bt.series = this.series), this.stroke && (bt.stroke = this.stroke), this.labels && (bt.labels = this.labels), this.legend && (bt.legend = this.legend), this.fill && (bt.fill = this.fill), this.tooltip && (bt.tooltip = this.tooltip), this.plotOptions && (bt.plotOptions = this.plotOptions), this.responsive && (bt.responsive = this.responsive), this.markers && (bt.markers = this.markers), this.noData && (bt.noData = this.noData), this.xaxis && (bt.xaxis = this.xaxis), this.yaxis && (bt.yaxis = this.yaxis), this.forecastDataPoints && (bt.forecastDataPoints = this.forecastDataPoints), this.grid && (bt.grid = this.grid), this.states && (bt.states = this.states), this.title && (bt.title = this.title), this.subtitle && (bt.subtitle = this.subtitle), this.theme && (bt.theme = this.theme), this.chartObj && this.chartObj.destroy(), this.ngZone.runOutsideAngular(() => {
                            this.chartObj = new ut(this.chartElement.nativeElement, bt)
                        }), this.render()
                    }
                    render() {
                        return this.ngZone.runOutsideAngular(() => this.chartObj.render())
                    }
                    updateOptions(bt, Ft, ue, Me) {
                        return this.ngZone.runOutsideAngular(() => this.chartObj.updateOptions(bt, Ft, ue, Me))
                    }
                    updateSeries(bt, Ft) {
                        return this.ngZone.runOutsideAngular(() => this.chartObj.updateSeries(bt, Ft))
                    }
                    appendSeries(bt, Ft) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.appendSeries(bt, Ft))
                    }
                    appendData(bt) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.appendData(bt))
                    }
                    toggleSeries(bt) {
                        return this.ngZone.runOutsideAngular(() => this.chartObj.toggleSeries(bt))
                    }
                    showSeries(bt) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.showSeries(bt))
                    }
                    hideSeries(bt) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.hideSeries(bt))
                    }
                    resetSeries() {
                        this.ngZone.runOutsideAngular(() => this.chartObj.resetSeries())
                    }
                    zoomX(bt, Ft) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.zoomX(bt, Ft))
                    }
                    toggleDataPointSelection(bt, Ft) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.toggleDataPointSelection(bt, Ft))
                    }
                    destroy() {
                        this.chartObj.destroy()
                    }
                    setLocale(bt) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.setLocale(bt))
                    }
                    paper() {
                        this.ngZone.runOutsideAngular(() => this.chartObj.paper())
                    }
                    addXaxisAnnotation(bt, Ft, ue) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.addXaxisAnnotation(bt, Ft, ue))
                    }
                    addYaxisAnnotation(bt, Ft, ue) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.addYaxisAnnotation(bt, Ft, ue))
                    }
                    addPointAnnotation(bt, Ft, ue) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.addPointAnnotation(bt, Ft, ue))
                    }
                    removeAnnotation(bt, Ft) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.removeAnnotation(bt, Ft))
                    }
                    clearAnnotations(bt) {
                        this.ngZone.runOutsideAngular(() => this.chartObj.clearAnnotations(bt))
                    }
                    dataURI(bt) {
                        return this.chartObj.dataURI(bt)
                    }
                }
                return Et.\u0275fac = function(bt) {
                    return new(bt || Et)(_t.Y36(_t.R0b))
                }, Et.\u0275cmp = _t.Xpm({
                    type: Et,
                    selectors: [
                        ["apx-chart"]
                    ],
                    viewQuery: function(bt, Ft) {
                        if (1 & bt && _t.Gf(Zt, 7), 2 & bt) {
                            let ue;
                            _t.iGM(ue = _t.CRH()) && (Ft.chartElement = ue.first)
                        }
                    },
                    inputs: {
                        chart: "chart",
                        annotations: "annotations",
                        colors: "colors",
                        dataLabels: "dataLabels",
                        series: "series",
                        stroke: "stroke",
                        labels: "labels",
                        legend: "legend",
                        markers: "markers",
                        noData: "noData",
                        fill: "fill",
                        tooltip: "tooltip",
                        plotOptions: "plotOptions",
                        responsive: "responsive",
                        xaxis: "xaxis",
                        yaxis: "yaxis",
                        forecastDataPoints: "forecastDataPoints",
                        grid: "grid",
                        states: "states",
                        title: "title",
                        subtitle: "subtitle",
                        theme: "theme",
                        autoUpdateSeries: "autoUpdateSeries"
                    },
                    features: [_t.TTD],
                    decls: 2,
                    vars: 0,
                    consts: [
                        ["chart", ""]
                    ],
                    template: function(bt, Ft) {
                        1 & bt && _t._UZ(0, "div", null, 0)
                    },
                    encapsulation: 2,
                    changeDetection: 0
                }), Et
            })();
            window.ApexCharts = ut;
            let ht = (() => {
                class Et {}
                return Et.\u0275fac = function(bt) {
                    return new(bt || Et)
                }, Et.\u0275mod = _t.oAB({
                    type: Et
                }), Et.\u0275inj = _t.cJS({}), Et
            })()
        },
        5195: (Mi, je, Nt) => {
            Nt.d(je, {
                f: () => Zt,
                y: () => ut
            });
            var _t = Nt(5879),
                pe = Nt(5553);
            let ut = (() => {
                    class xt {
                        elementRef;
                        configuration;
                        events;
                        initialized = new _t.vpe;
                        chart;
                        constructor(ht) {
                            this.elementRef = ht
                        }
                        ngOnInit() {
                            this.configuration.type && this.configuration.data && this.renderChart()
                        }
                        ngOnChanges(ht) {
                            this.update(ht)
                        }
                        ngOnDestroy() {
                            this.chart && (this.chart.detach(), this.chart = null)
                        }
                        renderChart() {
                            const ht = this.elementRef.nativeElement,
                                {
                                    type: Et,
                                    data: Rt,
                                    options: bt,
                                    responsiveOptions: Ft
                                } = this.configuration;
                            if ("Bar" === Et) this.chart = new pe.vz(ht, Rt, bt, Ft);
                            else if ("Line" === Et) this.chart = new pe.wW(ht, Rt, bt, Ft);
                            else {
                                if ("Pie" !== Et) throw new Error(`${Et} is not a known chart type`);
                                this.chart = new pe.uc(ht, Rt, bt, Ft)
                            }
                            this.events && this.bindEvents(), this.initialized.emit(this.chart)
                        }
                        update(ht) {
                            const {
                                type: Et,
                                data: Rt,
                                options: bt
                            } = this.configuration;
                            if (!Et || !Rt) return;
                            const Ft = ht.configuration.currentValue;
                            this.chart && Ft.type === Et ? ("data" in Ft || "options" in Ft) && this.chart.update(Rt, bt) : this.renderChart()
                        }
                        bindEvents() {
                            for (const ht of Object.keys(this.events)) this.chart.on(ht, this.events[ht])
                        }
                        static\ u0275fac = function(Et) {
                            return new(Et || xt)(_t.Y36(_t.SBq))
                        };
                        static\ u0275cmp = _t.Xpm({
                            type: xt,
                            selectors: [
                                ["x-chartist"]
                            ],
                            inputs: {
                                configuration: "configuration",
                                events: "events"
                            },
                            outputs: {
                                initialized: "initialized"
                            },
                            features: [_t.TTD],
                            decls: 0,
                            vars: 0,
                            template: function(Et, Rt) {},
                            styles: ["[_nghost-%COMP%]{display:block}"]
                        })
                    }
                    return xt
                })(),
                Zt = (() => {
                    class xt {
                        static\ u0275fac = function(Et) {
                            return new(Et || xt)
                        };
                        static\ u0275mod = _t.oAB({
                            type: xt
                        });
                        static\ u0275inj = _t.cJS({})
                    }
                    return xt
                })()
        },
        3348: (Mi, je, Nt) => {
            Nt.d(je, {
                jh: () => Nd,
                vQ: () => Wd
            });
            var _t = Nt(5879);

            function pe(n) {
                return n + .5 | 0
            }
            const ut = (n, a, s) => Math.max(Math.min(n, s), a);

            function Zt(n) {
                return ut(pe(2.55 * n), 0, 255)
            }

            function be(n) {
                return ut(pe(255 * n), 0, 255)
            }

            function ht(n) {
                return ut(pe(n / 2.55) / 100, 0, 1)
            }

            function Et(n) {
                return ut(pe(100 * n), 0, 100)
            }
            const Rt = {
                    0: 0,
                    1: 1,
                    2: 2,
                    3: 3,
                    4: 4,
                    5: 5,
                    6: 6,
                    7: 7,
                    8: 8,
                    9: 9,
                    A: 10,
                    B: 11,
                    C: 12,
                    D: 13,
                    E: 14,
                    F: 15,
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                    e: 14,
                    f: 15
                },
                bt = [..."0123456789ABCDEF"],
                Ft = n => bt[15 & n],
                ue = n => bt[(240 & n) >> 4] + bt[15 & n],
                Me = n => (240 & n) >> 4 == (15 & n);
            const q = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

            function Bt(n, a, s) {
                const o = a * Math.min(s, 1 - s),
                    c = (u, f = (u + n / 30) % 12) => s - o * Math.max(Math.min(f - 3, 9 - f, 1), -1);
                return [c(0), c(8), c(4)]
            }

            function ae(n, a, s) {
                const o = (c, u = (c + n / 60) % 6) => s - s * a * Math.max(Math.min(u, 4 - u, 1), 0);
                return [o(5), o(3), o(1)]
            }

            function ot(n, a, s) {
                const o = Bt(n, 1, .5);
                let c;
                for (a + s > 1 && (c = 1 / (a + s), a *= c, s *= c), c = 0; c < 3; c++) o[c] *= 1 - a - s, o[c] += a;
                return o
            }

            function Ue(n) {
                const s = n.r / 255,
                    o = n.g / 255,
                    c = n.b / 255,
                    u = Math.max(s, o, c),
                    f = Math.min(s, o, c),
                    m = (u + f) / 2;
                let y, A, L;
                return u !== f && (L = u - f, A = m > .5 ? L / (2 - u - f) : L / (u + f), y = function te(n, a, s, o, c) {
                    return n === c ? (a - s) / o + (a < s ? 6 : 0) : a === c ? (s - n) / o + 2 : (n - a) / o + 4
                }(s, o, c, L, u), y = 60 * y + .5), [0 | y, A || 0, m]
            }

            function li(n, a, s, o) {
                return (Array.isArray(a) ? n(a[0], a[1], a[2]) : n(a, s, o)).map(be)
            }

            function hi(n, a, s) {
                return li(Bt, n, a, s)
            }

            function Re(n) {
                return (n % 360 + 360) % 360
            }
            const di = {
                    x: "dark",
                    Z: "light",
                    Y: "re",
                    X: "blu",
                    W: "gr",
                    V: "medium",
                    U: "slate",
                    A: "ee",
                    T: "ol",
                    S: "or",
                    B: "ra",
                    C: "lateg",
                    D: "ights",
                    R: "in",
                    Q: "turquois",
                    E: "hi",
                    P: "ro",
                    O: "al",
                    N: "le",
                    M: "de",
                    L: "yello",
                    F: "en",
                    K: "ch",
                    G: "arks",
                    H: "ea",
                    I: "ightg",
                    J: "wh"
                },
                ui = {
                    OiceXe: "f0f8ff",
                    antiquewEte: "faebd7",
                    aqua: "ffff",
                    aquamarRe: "7fffd4",
                    azuY: "f0ffff",
                    beige: "f5f5dc",
                    bisque: "ffe4c4",
                    black: "0",
                    blanKedOmond: "ffebcd",
                    Xe: "ff",
                    XeviTet: "8a2be2",
                    bPwn: "a52a2a",
                    burlywood: "deb887",
                    caMtXe: "5f9ea0",
                    KartYuse: "7fff00",
                    KocTate: "d2691e",
                    cSO: "ff7f50",
                    cSnflowerXe: "6495ed",
                    cSnsilk: "fff8dc",
                    crimson: "dc143c",
                    cyan: "ffff",
                    xXe: "8b",
                    xcyan: "8b8b",
                    xgTMnPd: "b8860b",
                    xWay: "a9a9a9",
                    xgYF: "6400",
                    xgYy: "a9a9a9",
                    xkhaki: "bdb76b",
                    xmagFta: "8b008b",
                    xTivegYF: "556b2f",
                    xSange: "ff8c00",
                    xScEd: "9932cc",
                    xYd: "8b0000",
                    xsOmon: "e9967a",
                    xsHgYF: "8fbc8f",
                    xUXe: "483d8b",
                    xUWay: "2f4f4f",
                    xUgYy: "2f4f4f",
                    xQe: "ced1",
                    xviTet: "9400d3",
                    dAppRk: "ff1493",
                    dApskyXe: "bfff",
                    dimWay: "696969",
                    dimgYy: "696969",
                    dodgerXe: "1e90ff",
                    fiYbrick: "b22222",
                    flSOwEte: "fffaf0",
                    foYstWAn: "228b22",
                    fuKsia: "ff00ff",
                    gaRsbSo: "dcdcdc",
                    ghostwEte: "f8f8ff",
                    gTd: "ffd700",
                    gTMnPd: "daa520",
                    Way: "808080",
                    gYF: "8000",
                    gYFLw: "adff2f",
                    gYy: "808080",
                    honeyMw: "f0fff0",
                    hotpRk: "ff69b4",
                    RdianYd: "cd5c5c",
                    Rdigo: "4b0082",
                    ivSy: "fffff0",
                    khaki: "f0e68c",
                    lavFMr: "e6e6fa",
                    lavFMrXsh: "fff0f5",
                    lawngYF: "7cfc00",
                    NmoncEffon: "fffacd",
                    ZXe: "add8e6",
                    ZcSO: "f08080",
                    Zcyan: "e0ffff",
                    ZgTMnPdLw: "fafad2",
                    ZWay: "d3d3d3",
                    ZgYF: "90ee90",
                    ZgYy: "d3d3d3",
                    ZpRk: "ffb6c1",
                    ZsOmon: "ffa07a",
                    ZsHgYF: "20b2aa",
                    ZskyXe: "87cefa",
                    ZUWay: "778899",
                    ZUgYy: "778899",
                    ZstAlXe: "b0c4de",
                    ZLw: "ffffe0",
                    lime: "ff00",
                    limegYF: "32cd32",
                    lRF: "faf0e6",
                    magFta: "ff00ff",
                    maPon: "800000",
                    VaquamarRe: "66cdaa",
                    VXe: "cd",
                    VScEd: "ba55d3",
                    VpurpN: "9370db",
                    VsHgYF: "3cb371",
                    VUXe: "7b68ee",
                    VsprRggYF: "fa9a",
                    VQe: "48d1cc",
                    VviTetYd: "c71585",
                    midnightXe: "191970",
                    mRtcYam: "f5fffa",
                    mistyPse: "ffe4e1",
                    moccasR: "ffe4b5",
                    navajowEte: "ffdead",
                    navy: "80",
                    Tdlace: "fdf5e6",
                    Tive: "808000",
                    TivedBb: "6b8e23",
                    Sange: "ffa500",
                    SangeYd: "ff4500",
                    ScEd: "da70d6",
                    pOegTMnPd: "eee8aa",
                    pOegYF: "98fb98",
                    pOeQe: "afeeee",
                    pOeviTetYd: "db7093",
                    papayawEp: "ffefd5",
                    pHKpuff: "ffdab9",
                    peru: "cd853f",
                    pRk: "ffc0cb",
                    plum: "dda0dd",
                    powMrXe: "b0e0e6",
                    purpN: "800080",
                    YbeccapurpN: "663399",
                    Yd: "ff0000",
                    Psybrown: "bc8f8f",
                    PyOXe: "4169e1",
                    saddNbPwn: "8b4513",
                    sOmon: "fa8072",
                    sandybPwn: "f4a460",
                    sHgYF: "2e8b57",
                    sHshell: "fff5ee",
                    siFna: "a0522d",
                    silver: "c0c0c0",
                    skyXe: "87ceeb",
                    UXe: "6a5acd",
                    UWay: "708090",
                    UgYy: "708090",
                    snow: "fffafa",
                    sprRggYF: "ff7f",
                    stAlXe: "4682b4",
                    tan: "d2b48c",
                    teO: "8080",
                    tEstN: "d8bfd8",
                    tomato: "ff6347",
                    Qe: "40e0d0",
                    viTet: "ee82ee",
                    JHt: "f5deb3",
                    wEte: "ffffff",
                    wEtesmoke: "f5f5f5",
                    Lw: "ffff00",
                    LwgYF: "9acd32"
                };
            let Pe;
            const Yi = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/,
                fi = n => n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055,
                ve = n => n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4);

            function He(n, a, s) {
                if (n) {
                    let o = Ue(n);
                    o[a] = Math.max(0, Math.min(o[a] + o[a] * s, 0 === a ? 360 : 1)), o = hi(o), n.r = o[0], n.g = o[1], n.b = o[2]
                }
            }

            function Le(n, a) {
                return n && Object.assign(a || {}, n)
            }

            function ii(n) {
                var a = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 255
                };
                return Array.isArray(n) ? n.length >= 3 && (a = {
                    r: n[0],
                    g: n[1],
                    b: n[2],
                    a: 255
                }, n.length > 3 && (a.a = be(n[3]))) : (a = Le(n, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                })).a = be(a.a), a
            }

            function Ye(n) {
                return "r" === n.charAt(0) ? function ce(n) {
                    const a = Yi.exec(n);
                    let o, c, u, s = 255;
                    if (a) {
                        if (a[7] !== o) {
                            const f = +a[7];
                            s = a[8] ? Zt(f) : ut(255 * f, 0, 255)
                        }
                        return o = +a[1], c = +a[3], u = +a[5], o = 255 & (a[2] ? Zt(o) : ut(o, 0, 255)), c = 255 & (a[4] ? Zt(c) : ut(c, 0, 255)), u = 255 & (a[6] ? Zt(u) : ut(u, 0, 255)), {
                            r: o,
                            g: c,
                            b: u,
                            a: s
                        }
                    }
                }(n) : function ci(n) {
                    const a = q.exec(n);
                    let o, s = 255;
                    if (!a) return;
                    a[5] !== o && (s = a[6] ? Zt(+a[5]) : be(+a[5]));
                    const c = Re(+a[2]),
                        u = +a[3] / 100,
                        f = +a[4] / 100;
                    return o = "hwb" === a[1] ? function Ni(n, a, s) {
                        return li(ot, n, a, s)
                    }(c, u, f) : "hsv" === a[1] ? function Bi(n, a, s) {
                        return li(ae, n, a, s)
                    }(c, u, f) : hi(c, u, f), {
                        r: o[0],
                        g: o[1],
                        b: o[2],
                        a: s
                    }
                }(n)
            }
            class We {
                constructor(a) {
                    if (a instanceof We) return a;
                    const s = typeof a;
                    let o;
                    "object" === s ? o = ii(a) : "string" === s && (o = function le(n) {
                        var s, a = n.length;
                        return "#" === n[0] && (4 === a || 5 === a ? s = {
                            r: 255 & 17 * Rt[n[1]],
                            g: 255 & 17 * Rt[n[2]],
                            b: 255 & 17 * Rt[n[3]],
                            a: 5 === a ? 17 * Rt[n[4]] : 255
                        } : (7 === a || 9 === a) && (s = {
                            r: Rt[n[1]] << 4 | Rt[n[2]],
                            g: Rt[n[3]] << 4 | Rt[n[4]],
                            b: Rt[n[5]] << 4 | Rt[n[6]],
                            a: 9 === a ? Rt[n[7]] << 4 | Rt[n[8]] : 255
                        })), s
                    }(a) || function Hi(n) {
                        Pe || (Pe = function Ze() {
                            const n = {},
                                a = Object.keys(ui),
                                s = Object.keys(di);
                            let o, c, u, f, m;
                            for (o = 0; o < a.length; o++) {
                                for (f = m = a[o], c = 0; c < s.length; c++) u = s[c], m = m.replace(u, di[u]);
                                u = parseInt(ui[f], 16), n[m] = [u >> 16 & 255, u >> 8 & 255, 255 & u]
                            }
                            return n
                        }(), Pe.transparent = [0, 0, 0, 0]);
                        const a = Pe[n.toLowerCase()];
                        return a && {
                            r: a[0],
                            g: a[1],
                            b: a[2],
                            a: 4 === a.length ? a[3] : 255
                        }
                    }(a) || Ye(a)), this._rgb = o, this._valid = !!o
                }
                get valid() {
                    return this._valid
                }
                get rgb() {
                    var a = Le(this._rgb);
                    return a && (a.a = ht(a.a)), a
                }
                set rgb(a) {
                    this._rgb = ii(a)
                }
                rgbString() {
                    return this._valid ? function gi(n) {
                        return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${ht(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`)
                    }(this._rgb) : void 0
                }
                hexString() {
                    return this._valid ? function Pi(n) {
                        var a = (n => Me(n.r) && Me(n.g) && Me(n.b) && Me(n.a))(n) ? Ft : ue;
                        return n ? "#" + a(n.r) + a(n.g) + a(n.b) + ((n, a) => n < 255 ? a(n) : "")(n.a, a) : void 0
                    }(this._rgb) : void 0
                }
                hslString() {
                    return this._valid ? function Be(n) {
                        if (!n) return;
                        const a = Ue(n),
                            s = a[0],
                            o = Et(a[1]),
                            c = Et(a[2]);
                        return n.a < 255 ? `hsla(${s}, ${o}%, ${c}%, ${ht(n.a)})` : `hsl(${s}, ${o}%, ${c}%)`
                    }(this._rgb) : void 0
                }
                mix(a, s) {
                    if (a) {
                        const o = this.rgb,
                            c = a.rgb;
                        let u;
                        const f = s === u ? .5 : s,
                            m = 2 * f - 1,
                            y = o.a - c.a,
                            A = ((m * y == -1 ? m : (m + y) / (1 + m * y)) + 1) / 2;
                        u = 1 - A, o.r = 255 & A * o.r + u * c.r + .5, o.g = 255 & A * o.g + u * c.g + .5, o.b = 255 & A * o.b + u * c.b + .5, o.a = f * o.a + (1 - f) * c.a, this.rgb = o
                    }
                    return this
                }
                interpolate(a, s) {
                    return a && (this._rgb = function xe(n, a, s) {
                        const o = ve(ht(n.r)),
                            c = ve(ht(n.g)),
                            u = ve(ht(n.b));
                        return {
                            r: be(fi(o + s * (ve(ht(a.r)) - o))),
                            g: be(fi(c + s * (ve(ht(a.g)) - c))),
                            b: be(fi(u + s * (ve(ht(a.b)) - u))),
                            a: n.a + s * (a.a - n.a)
                        }
                    }(this._rgb, a._rgb, s)), this
                }
                clone() {
                    return new We(this.rgb)
                }
                alpha(a) {
                    return this._rgb.a = be(a), this
                }
                clearer(a) {
                    return this._rgb.a *= 1 - a, this
                }
                greyscale() {
                    const a = this._rgb,
                        s = pe(.3 * a.r + .59 * a.g + .11 * a.b);
                    return a.r = a.g = a.b = s, this
                }
                opaquer(a) {
                    return this._rgb.a *= 1 + a, this
                }
                negate() {
                    const a = this._rgb;
                    return a.r = 255 - a.r, a.g = 255 - a.g, a.b = 255 - a.b, this
                }
                lighten(a) {
                    return He(this._rgb, 2, a), this
                }
                darken(a) {
                    return He(this._rgb, 2, -a), this
                }
                saturate(a) {
                    return He(this._rgb, 1, a), this
                }
                desaturate(a) {
                    return He(this._rgb, 1, -a), this
                }
                rotate(a) {
                    return function ne(n, a) {
                        var s = Ue(n);
                        s[0] = Re(s[0] + a), s = hi(s), n.r = s[0], n.g = s[1], n.b = s[2]
                    }(this._rgb, a), this
                }
            }

            function Ae() {}
            const pi = (() => {
                let n = 0;
                return () => n++
            })();

            function zt(n) {
                return null === n || typeof n > "u"
            }

            function Qt(n) {
                if (Array.isArray && Array.isArray(n)) return !0;
                const a = Object.prototype.toString.call(n);
                return "[object" === a.slice(0, 7) && "Array]" === a.slice(-6)
            }

            function Tt(n) {
                return null !== n && "[object Object]" === Object.prototype.toString.call(n)
            }

            function $t(n) {
                return ("number" == typeof n || n instanceof Number) && isFinite(+n)
            }

            function Jt(n, a) {
                return $t(n) ? n : a
            }

            function Ct(n, a) {
                return typeof n > "u" ? a : n
            }
            const Wi = (n, a) => "string" == typeof n && n.endsWith("%") ? parseFloat(n) / 100 * a : +n;

            function qt(n, a, s) {
                if (n && "function" == typeof n.call) return n.apply(s, a)
            }

            function Yt(n, a, s, o) {
                let c, u, f;
                if (Qt(n))
                    if (u = n.length, o)
                        for (c = u - 1; c >= 0; c--) a.call(s, n[c], c);
                    else
                        for (c = 0; c < u; c++) a.call(s, n[c], c);
                else if (Tt(n))
                    for (f = Object.keys(n), u = f.length, c = 0; c < u; c++) a.call(s, n[f[c]], f[c])
            }

            function xi(n, a) {
                let s, o, c, u;
                if (!n || !a || n.length !== a.length) return !1;
                for (s = 0, o = n.length; s < o; ++s)
                    if (c = n[s], u = a[s], c.datasetIndex !== u.datasetIndex || c.index !== u.index) return !1;
                return !0
            }

            function Ve(n) {
                if (Qt(n)) return n.map(Ve);
                if (Tt(n)) {
                    const a = Object.create(null),
                        s = Object.keys(n),
                        o = s.length;
                    let c = 0;
                    for (; c < o; ++c) a[s[c]] = Ve(n[s[c]]);
                    return a
                }
                return n
            }

            function mi(n) {
                return -1 === ["__proto__", "prototype", "constructor"].indexOf(n)
            }

            function bi(n, a, s, o) {
                if (!mi(n)) return;
                const c = a[n],
                    u = s[n];
                Tt(c) && Tt(u) ? re(c, u, o) : a[n] = Ve(u)
            }

            function re(n, a, s) {
                const o = Qt(a) ? a : [a],
                    c = o.length;
                if (!Tt(n)) return n;
                const u = (s = s || {}).merger || bi;
                let f;
                for (let m = 0; m < c; ++m) {
                    if (f = o[m], !Tt(f)) continue;
                    const y = Object.keys(f);
                    for (let A = 0, L = y.length; A < L; ++A) u(y[A], n, f, s)
                }
                return n
            }

            function qe(n, a) {
                return re(n, a, {
                    merger: vi
                })
            }

            function vi(n, a, s) {
                if (!mi(n)) return;
                const o = a[n],
                    c = s[n];
                Tt(o) && Tt(c) ? qe(o, c) : Object.prototype.hasOwnProperty.call(a, n) || (a[n] = Ve(c))
            }
            const Ke = {
                "": n => n,
                x: n => n.x,
                y: n => n.y
            };

            function Fe(n, a) {
                return (Ke[a] || (Ke[a] = function Vi(n) {
                    const a = function si(n) {
                        const a = n.split("."),
                            s = [];
                        let o = "";
                        for (const c of a) o += c, o.endsWith("\\") ? o = o.slice(0, -1) + "." : (s.push(o), o = "");
                        return s
                    }(n);
                    return s => {
                        for (const o of a) {
                            if ("" === o) break;
                            s = s && s[o]
                        }
                        return s
                    }
                }(a)))(n)
            }

            function yi(n) {
                return n.charAt(0).toUpperCase() + n.slice(1)
            }
            const Qe = n => typeof n < "u",
                Xe = n => "function" == typeof n,
                Ne = (n, a) => {
                    if (n.size !== a.size) return !1;
                    for (const s of n)
                        if (!a.has(s)) return !1;
                    return !0
                },
                jt = Math.PI,
                W = 2 * jt,
                E = W + jt,
                N = Number.POSITIVE_INFINITY,
                F = jt / 180,
                Y = jt / 2,
                $ = jt / 4,
                K = 2 * jt / 3,
                et = Math.log10,
                rt = Math.sign;

            function lt(n, a, s) {
                return Math.abs(n - a) < s
            }

            function ct(n) {
                const a = Math.round(n);
                n = lt(n, a, n / 1e3) ? a : n;
                const s = Math.pow(10, Math.floor(et(n))),
                    o = n / s;
                return (o <= 1 ? 1 : o <= 2 ? 2 : o <= 5 ? 5 : 10) * s
            }

            function st(n) {
                return !isNaN(parseFloat(n)) && isFinite(n)
            }

            function gt(n, a, s) {
                let o, c, u;
                for (o = 0, c = n.length; o < c; o++) u = n[o][s], isNaN(u) || (a.min = Math.min(a.min, u), a.max = Math.max(a.max, u))
            }

            function Gt(n) {
                return n * (jt / 180)
            }

            function Ut(n) {
                return n * (180 / jt)
            }

            function _e(n) {
                if (!$t(n)) return;
                let a = 1,
                    s = 0;
                for (; Math.round(n * a) / a !== n;) a *= 10, s++;
                return s
            }

            function Te(n, a) {
                const s = a.x - n.x,
                    o = a.y - n.y,
                    c = Math.sqrt(s * s + o * o);
                let u = Math.atan2(o, s);
                return u < -.5 * jt && (u += W), {
                    angle: u,
                    distance: c
                }
            }

            function ge(n, a) {
                return Math.sqrt(Math.pow(a.x - n.x, 2) + Math.pow(a.y - n.y, 2))
            }

            function Se(n, a) {
                return (n - a + E) % W - jt
            }

            function Wt(n) {
                return (n % W + W) % W
            }

            function Lt(n, a, s, o) {
                const c = Wt(n),
                    u = Wt(a),
                    f = Wt(s),
                    m = Wt(u - c),
                    y = Wt(f - c),
                    A = Wt(c - u),
                    L = Wt(c - f);
                return c === u || c === f || o && u === f || m > y && A < L
            }

            function Mt(n, a, s) {
                return Math.max(a, Math.min(s, n))
            }

            function t(n, a, s, o = 1e-6) {
                return n >= Math.min(a, s) - o && n <= Math.max(a, s) + o
            }

            function e(n, a, s) {
                s = s || (f => n[f] < a);
                let u, o = n.length - 1,
                    c = 0;
                for (; o - c > 1;) u = c + o >> 1, s(u) ? c = u : o = u;
                return {
                    lo: c,
                    hi: o
                }
            }
            const i = (n, a, s, o) => e(n, s, o ? c => {
                    const u = n[c][a];
                    return u < s || u === s && n[c + 1][a] === s
                } : c => n[c][a] < s),
                r = (n, a, s) => e(n, s, o => n[o][a] >= s),
                h = ["push", "pop", "shift", "splice", "unshift"];

            function g(n, a) {
                const s = n._chartjs;
                if (!s) return;
                const o = s.listeners,
                    c = o.indexOf(a); - 1 !== c && o.splice(c, 1), !(o.length > 0) && (h.forEach(u => {
                    delete n[u]
                }), delete n._chartjs)
            }

            function x(n) {
                const a = new Set(n);
                return a.size === n.length ? n : Array.from(a)
            }
            const v = typeof window > "u" ? function(n) {
                return n()
            } : window.requestAnimationFrame;

            function w(n, a) {
                let s = [],
                    o = !1;
                return function(...c) {
                    s = c, o || (o = !0, v.call(window, () => {
                        o = !1, n.apply(a, s)
                    }))
                }
            }
            const C = n => "start" === n ? "left" : "end" === n ? "right" : "center",
                P = (n, a, s) => "start" === n ? a : "end" === n ? s : (a + s) / 2;

            function I(n, a, s) {
                const o = a.length;
                let c = 0,
                    u = o;
                if (n._sorted) {
                    const {
                        iScale: f,
                        _parsed: m
                    } = n, y = f.axis, {
                        min: A,
                        max: L,
                        minDefined: O,
                        maxDefined: z
                    } = f.getUserBounds();
                    O && (c = Mt(Math.min(i(m, y, A).lo, s ? o : i(a, y, f.getPixelForValue(A)).lo), 0, o - 1)), u = z ? Mt(Math.max(i(m, f.axis, L, !0).hi + 1, s ? 0 : i(a, y, f.getPixelForValue(L), !0).hi + 1), c, o) - c : o - c
                }
                return {
                    start: c,
                    count: u
                }
            }

            function R(n) {
                const {
                    xScale: a,
                    yScale: s,
                    _scaleRanges: o
                } = n, c = {
                    xmin: a.min,
                    xmax: a.max,
                    ymin: s.min,
                    ymax: s.max
                };
                if (!o) return n._scaleRanges = c, !0;
                const u = o.xmin !== a.min || o.xmax !== a.max || o.ymin !== s.min || o.ymax !== s.max;
                return Object.assign(o, c), u
            }
            const p = n => 0 === n || 1 === n,
                k = (n, a, s) => -Math.pow(2, 10 * (n -= 1)) * Math.sin((n - a) * W / s),
                M = (n, a, s) => Math.pow(2, -10 * n) * Math.sin((n - a) * W / s) + 1,
                D = {
                    linear: n => n,
                    easeInQuad: n => n * n,
                    easeOutQuad: n => -n * (n - 2),
                    easeInOutQuad: n => (n /= .5) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1),
                    easeInCubic: n => n * n * n,
                    easeOutCubic: n => (n -= 1) * n * n + 1,
                    easeInOutCubic: n => (n /= .5) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2),
                    easeInQuart: n => n * n * n * n,
                    easeOutQuart: n => -((n -= 1) * n * n * n - 1),
                    easeInOutQuart: n => (n /= .5) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2),
                    easeInQuint: n => n * n * n * n * n,
                    easeOutQuint: n => (n -= 1) * n * n * n * n + 1,
                    easeInOutQuint: n => (n /= .5) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2),
                    easeInSine: n => 1 - Math.cos(n * Y),
                    easeOutSine: n => Math.sin(n * Y),
                    easeInOutSine: n => -.5 * (Math.cos(jt * n) - 1),
                    easeInExpo: n => 0 === n ? 0 : Math.pow(2, 10 * (n - 1)),
                    easeOutExpo: n => 1 === n ? 1 : 1 - Math.pow(2, -10 * n),
                    easeInOutExpo: n => p(n) ? n : n < .5 ? .5 * Math.pow(2, 10 * (2 * n - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * n - 1))),
                    easeInCirc: n => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1),
                    easeOutCirc: n => Math.sqrt(1 - (n -= 1) * n),
                    easeInOutCirc: n => (n /= .5) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1),
                    easeInElastic: n => p(n) ? n : k(n, .075, .3),
                    easeOutElastic: n => p(n) ? n : M(n, .075, .3),
                    easeInOutElastic: n => p(n) ? n : n < .5 ? .5 * k(2 * n, .1125, .45) : .5 + .5 * M(2 * n - 1, .1125, .45),
                    easeInBack: n => n * n * (2.70158 * n - 1.70158),
                    easeOutBack: n => (n -= 1) * n * (2.70158 * n + 1.70158) + 1,
                    easeInOutBack(n) {
                        let a = 1.70158;
                        return (n /= .5) < 1 ? n * n * ((1 + (a *= 1.525)) * n - a) * .5 : .5 * ((n -= 2) * n * ((1 + (a *= 1.525)) * n + a) + 2)
                    },
                    easeInBounce: n => 1 - D.easeOutBounce(1 - n),
                    easeOutBounce: n => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375,
                    easeInOutBounce: n => n < .5 ? .5 * D.easeInBounce(2 * n) : .5 * D.easeOutBounce(2 * n - 1) + .5
                };

            function X(n) {
                if (n && "object" == typeof n) {
                    const a = n.toString();
                    return "[object CanvasPattern]" === a || "[object CanvasGradient]" === a
                }
                return !1
            }

            function H(n) {
                return X(n) ? n : new We(n)
            }

            function j(n) {
                return X(n) ? n : new We(n).saturate(.5).darken(.1).hexString()
            }
            const U = ["x", "y", "borderWidth", "radius", "tension"],
                Q = ["color", "borderColor", "backgroundColor"],
                mt = new Map;

            function Pt(n, a, s) {
                return function yt(n, a) {
                    a = a || {};
                    const s = n + JSON.stringify(a);
                    let o = mt.get(s);
                    return o || (o = new Intl.NumberFormat(n, a), mt.set(s, o)), o
                }(a, s).format(n)
            }
            const Dt = {
                values: n => Qt(n) ? n : "" + n,
                numeric(n, a, s) {
                    if (0 === n) return "0";
                    const o = this.chart.options.locale;
                    let c, u = n;
                    if (s.length > 1) {
                        const A = Math.max(Math.abs(s[0].value), Math.abs(s[s.length - 1].value));
                        (A < 1e-4 || A > 1e15) && (c = "scientific"), u = function Vt(n, a) {
                            let s = a.length > 3 ? a[2].value - a[1].value : a[1].value - a[0].value;
                            return Math.abs(s) >= 1 && n !== Math.floor(n) && (s = n - Math.floor(n)), s
                        }(n, s)
                    }
                    const f = et(Math.abs(u)),
                        m = isNaN(f) ? 1 : Math.max(Math.min(-1 * Math.floor(f), 20), 0),
                        y = {
                            notation: c,
                            minimumFractionDigits: m,
                            maximumFractionDigits: m
                        };
                    return Object.assign(y, this.options.ticks.format), Pt(n, o, y)
                },
                logarithmic(n, a, s) {
                    if (0 === n) return "0";
                    const o = s[a].significand || n / Math.pow(10, Math.floor(et(n)));
                    return [1, 2, 3, 5, 10, 15].includes(o) || a > .8 * s.length ? Dt.numeric.call(this, n, a, s) : ""
                }
            };
            var ee = {
                formatters: Dt
            };
            const Kt = Object.create(null),
                Ce = Object.create(null);

            function De(n, a) {
                if (!a) return n;
                const s = a.split(".");
                for (let o = 0, c = s.length; o < c; ++o) {
                    const u = s[o];
                    n = n[u] || (n[u] = Object.create(null))
                }
                return n
            }

            function Li(n, a, s) {
                return "string" == typeof a ? re(De(n, a), s) : re(De(n, ""), a)
            }
            class Ji {
                constructor(a, s) {
                    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = o => o.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
                        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                        size: 12,
                        style: "normal",
                        lineHeight: 1.2,
                        weight: null
                    }, this.hover = {}, this.hoverBackgroundColor = (o, c) => j(c.backgroundColor), this.hoverBorderColor = (o, c) => j(c.borderColor), this.hoverColor = (o, c) => j(c.color), this.indexAxis = "x", this.interaction = {
                        mode: "nearest",
                        intersect: !0,
                        includeInvisible: !1
                    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(a), this.apply(s)
                }
                set(a, s) {
                    return Li(this, a, s)
                }
                get(a) {
                    return De(this, a)
                }
                describe(a, s) {
                    return Li(Ce, a, s)
                }
                override(a, s) {
                    return Li(Kt, a, s)
                }
                route(a, s, o, c) {
                    const u = De(this, a),
                        f = De(this, o),
                        m = "_" + s;
                    Object.defineProperties(u, {
                        [m]: {
                            value: u[s],
                            writable: !0
                        },
                        [s]: {
                            enumerable: !0,
                            get() {
                                const y = this[m],
                                    A = f[c];
                                return Tt(y) ? Object.assign({}, A, y) : Ct(y, A)
                            },
                            set(y) {
                                this[m] = y
                            }
                        }
                    })
                }
                apply(a) {
                    a.forEach(s => s(this))
                }
            }
            var Xt = new Ji({
                _scriptable: n => !n.startsWith("on"),
                _indexable: n => "events" !== n,
                hover: {
                    _fallback: "interaction"
                },
                interaction: {
                    _scriptable: !1,
                    _indexable: !1
                }
            }, [function at(n) {
                n.set("animation", {
                    delay: void 0,
                    duration: 1e3,
                    easing: "easeOutQuart",
                    fn: void 0,
                    from: void 0,
                    loop: void 0,
                    to: void 0,
                    type: void 0
                }), n.describe("animation", {
                    _fallback: !1,
                    _indexable: !1,
                    _scriptable: a => "onProgress" !== a && "onComplete" !== a && "fn" !== a
                }), n.set("animations", {
                    colors: {
                        type: "color",
                        properties: Q
                    },
                    numbers: {
                        type: "number",
                        properties: U
                    }
                }), n.describe("animations", {
                    _fallback: "animation"
                }), n.set("transitions", {
                    active: {
                        animation: {
                            duration: 400
                        }
                    },
                    resize: {
                        animation: {
                            duration: 0
                        }
                    },
                    show: {
                        animations: {
                            colors: {
                                from: "transparent"
                            },
                            visible: {
                                type: "boolean",
                                duration: 0
                            }
                        }
                    },
                    hide: {
                        animations: {
                            colors: {
                                to: "transparent"
                            },
                            visible: {
                                type: "boolean",
                                easing: "linear",
                                fn: a => 0 | a
                            }
                        }
                    }
                })
            }, function it(n) {
                n.set("layout", {
                    autoPadding: !0,
                    padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                })
            }, function ie(n) {
                n.set("scale", {
                    display: !0,
                    offset: !1,
                    reverse: !1,
                    beginAtZero: !1,
                    bounds: "ticks",
                    clip: !0,
                    grace: 0,
                    grid: {
                        display: !0,
                        lineWidth: 1,
                        drawOnChartArea: !0,
                        drawTicks: !0,
                        tickLength: 8,
                        tickWidth: (a, s) => s.lineWidth,
                        tickColor: (a, s) => s.color,
                        offset: !1
                    },
                    border: {
                        display: !0,
                        dash: [],
                        dashOffset: 0,
                        width: 1
                    },
                    title: {
                        display: !1,
                        text: "",
                        padding: {
                            top: 4,
                            bottom: 4
                        }
                    },
                    ticks: {
                        minRotation: 0,
                        maxRotation: 50,
                        mirror: !1,
                        textStrokeWidth: 0,
                        textStrokeColor: "",
                        padding: 3,
                        display: !0,
                        autoSkip: !0,
                        autoSkipPadding: 3,
                        labelOffset: 0,
                        callback: ee.formatters.values,
                        minor: {},
                        major: {},
                        align: "center",
                        crossAlign: "near",
                        showLabelBackdrop: !1,
                        backdropColor: "rgba(255, 255, 255, 0.75)",
                        backdropPadding: 2
                    }
                }), n.route("scale.ticks", "color", "", "color"), n.route("scale.grid", "color", "", "borderColor"), n.route("scale.border", "color", "", "borderColor"), n.route("scale.title", "color", "", "color"), n.describe("scale", {
                    _fallback: !1,
                    _scriptable: a => !a.startsWith("before") && !a.startsWith("after") && "callback" !== a && "parser" !== a,
                    _indexable: a => "borderDash" !== a && "tickBorderDash" !== a && "dash" !== a
                }), n.describe("scales", {
                    _fallback: "scale"
                }), n.describe("scale.ticks", {
                    _scriptable: a => "backdropPadding" !== a && "callback" !== a,
                    _indexable: a => "backdropPadding" !== a
                })
            }]);

            function _i(n, a, s, o, c) {
                let u = a[c];
                return u || (u = a[c] = n.measureText(c).width, s.push(c)), u > o && (o = u), o
            }

            function kr(n, a, s, o) {
                let c = (o = o || {}).data = o.data || {},
                    u = o.garbageCollect = o.garbageCollect || [];
                o.font !== a && (c = o.data = {}, u = o.garbageCollect = [], o.font = a), n.save(), n.font = a;
                let f = 0;
                const m = s.length;
                let y, A, L, O, z;
                for (y = 0; y < m; y++)
                    if (O = s[y], null == O || Qt(O)) {
                        if (Qt(O))
                            for (A = 0, L = O.length; A < L; A++) z = O[A], null != z && !Qt(z) && (f = _i(n, c, u, f, z))
                    } else f = _i(n, c, u, f, O);
                n.restore();
                const B = u.length / 2;
                if (B > s.length) {
                    for (y = 0; y < B; y++) delete c[u[y]];
                    u.splice(0, B)
                }
                return f
            }

            function Ti(n, a, s) {
                const o = n.currentDevicePixelRatio,
                    c = 0 !== s ? Math.max(s / 2, .5) : 0;
                return Math.round((a - c) * o) / o + c
            }

            function xa(n, a) {
                (a = a || n.getContext("2d")).save(), a.resetTransform(), a.clearRect(0, 0, n.width, n.height), a.restore()
            }

            function Bs(n, a, s, o) {
                ma(n, a, s, o, null)
            }

            function ma(n, a, s, o, c) {
                let u, f, m, y, A, L, O, z;
                const B = a.pointStyle,
                    V = a.rotation,
                    G = a.radius;
                let Z = (V || 0) * F;
                if (B && "object" == typeof B && (u = B.toString(), "[object HTMLImageElement]" === u || "[object HTMLCanvasElement]" === u)) return n.save(), n.translate(s, o), n.rotate(Z), n.drawImage(B, -B.width / 2, -B.height / 2, B.width, B.height), void n.restore();
                if (!(isNaN(G) || G <= 0)) {
                    switch (n.beginPath(), B) {
                        default: c ? n.ellipse(s, o, c / 2, G, 0, 0, W) : n.arc(s, o, G, 0, W),
                        n.closePath();
                        break;
                        case "triangle":
                                L = c ? c / 2 : G,
                            n.moveTo(s + Math.sin(Z) * L, o - Math.cos(Z) * G),
                            Z += K,
                            n.lineTo(s + Math.sin(Z) * L, o - Math.cos(Z) * G),
                            Z += K,
                            n.lineTo(s + Math.sin(Z) * L, o - Math.cos(Z) * G),
                            n.closePath();
                            break;
                        case "rectRounded":
                                A = .516 * G,
                            y = G - A,
                            f = Math.cos(Z + $) * y,
                            O = Math.cos(Z + $) * (c ? c / 2 - A : y),
                            m = Math.sin(Z + $) * y,
                            z = Math.sin(Z + $) * (c ? c / 2 - A : y),
                            n.arc(s - O, o - m, A, Z - jt, Z - Y),
                            n.arc(s + z, o - f, A, Z - Y, Z),
                            n.arc(s + O, o + m, A, Z, Z + Y),
                            n.arc(s - z, o + f, A, Z + Y, Z + jt),
                            n.closePath();
                            break;
                        case "rect":
                                if (!V) {
                                y = Math.SQRT1_2 * G, L = c ? c / 2 : y, n.rect(s - L, o - y, 2 * L, 2 * y);
                                break
                            }Z += $;
                        case "rectRot":
                                O = Math.cos(Z) * (c ? c / 2 : G),
                            f = Math.cos(Z) * G,
                            m = Math.sin(Z) * G,
                            z = Math.sin(Z) * (c ? c / 2 : G),
                            n.moveTo(s - O, o - m),
                            n.lineTo(s + z, o - f),
                            n.lineTo(s + O, o + m),
                            n.lineTo(s - z, o + f),
                            n.closePath();
                            break;
                        case "crossRot":
                                Z += $;
                        case "cross":
                                O = Math.cos(Z) * (c ? c / 2 : G),
                            f = Math.cos(Z) * G,
                            m = Math.sin(Z) * G,
                            z = Math.sin(Z) * (c ? c / 2 : G),
                            n.moveTo(s - O, o - m),
                            n.lineTo(s + O, o + m),
                            n.moveTo(s + z, o - f),
                            n.lineTo(s - z, o + f);
                            break;
                        case "star":
                                O = Math.cos(Z) * (c ? c / 2 : G),
                            f = Math.cos(Z) * G,
                            m = Math.sin(Z) * G,
                            z = Math.sin(Z) * (c ? c / 2 : G),
                            n.moveTo(s - O, o - m),
                            n.lineTo(s + O, o + m),
                            n.moveTo(s + z, o - f),
                            n.lineTo(s - z, o + f),
                            Z += $,
                            O = Math.cos(Z) * (c ? c / 2 : G),
                            f = Math.cos(Z) * G,
                            m = Math.sin(Z) * G,
                            z = Math.sin(Z) * (c ? c / 2 : G),
                            n.moveTo(s - O, o - m),
                            n.lineTo(s + O, o + m),
                            n.moveTo(s + z, o - f),
                            n.lineTo(s - z, o + f);
                            break;
                        case "line":
                                f = c ? c / 2 : Math.cos(Z) * G,
                            m = Math.sin(Z) * G,
                            n.moveTo(s - f, o - m),
                            n.lineTo(s + f, o + m);
                            break;
                        case "dash":
                                n.moveTo(s, o),
                            n.lineTo(s + Math.cos(Z) * (c ? c / 2 : G), o + Math.sin(Z) * G);
                            break;
                        case !1:
                                n.closePath()
                    }
                    n.fill(), a.borderWidth > 0 && n.stroke()
                }
            }

            function ai(n, a, s) {
                return s = s || .5, !a || n && n.x > a.left - s && n.x < a.right + s && n.y > a.top - s && n.y < a.bottom + s
            }

            function xs(n, a) {
                n.save(), n.beginPath(), n.rect(a.left, a.top, a.right - a.left, a.bottom - a.top), n.clip()
            }

            function ms(n) {
                n.restore()
            }

            function Ar(n, a, s, o, c) {
                if (!a) return n.lineTo(s.x, s.y);
                if ("middle" === c) {
                    const u = (a.x + s.x) / 2;
                    n.lineTo(u, a.y), n.lineTo(u, s.y)
                } else "after" === c != !!o ? n.lineTo(a.x, s.y) : n.lineTo(s.x, a.y);
                n.lineTo(s.x, s.y)
            }

            function Sr(n, a, s, o) {
                if (!a) return n.lineTo(s.x, s.y);
                n.bezierCurveTo(o ? a.cp1x : a.cp2x, o ? a.cp1y : a.cp2y, o ? s.cp2x : s.cp1x, o ? s.cp2y : s.cp1y, s.x, s.y)
            }

            function Mr(n, a, s, o, c) {
                if (c.strikethrough || c.underline) {
                    const u = n.measureText(o),
                        f = a - u.actualBoundingBoxLeft,
                        m = a + u.actualBoundingBoxRight,
                        A = s + u.actualBoundingBoxDescent,
                        L = c.strikethrough ? (s - u.actualBoundingBoxAscent + A) / 2 : A;
                    n.strokeStyle = n.fillStyle, n.beginPath(), n.lineWidth = c.decorationWidth || 2, n.moveTo(f, L), n.lineTo(m, L), n.stroke()
                }
            }

            function Pr(n, a) {
                const s = n.fillStyle;
                n.fillStyle = a.color, n.fillRect(a.left, a.top, a.width, a.height), n.fillStyle = s
            }

            function Oi(n, a, s, o, c, u = {}) {
                const f = Qt(a) ? a : [a],
                    m = u.strokeWidth > 0 && "" !== u.strokeColor;
                let y, A;
                for (n.save(), n.font = c.string, function Cr(n, a) {
                        a.translation && n.translate(a.translation[0], a.translation[1]), zt(a.rotation) || n.rotate(a.rotation), a.color && (n.fillStyle = a.color), a.textAlign && (n.textAlign = a.textAlign), a.textBaseline && (n.textBaseline = a.textBaseline)
                    }(n, u), y = 0; y < f.length; ++y) A = f[y], u.backdrop && Pr(n, u.backdrop), m && (u.strokeColor && (n.strokeStyle = u.strokeColor), zt(u.strokeWidth) || (n.lineWidth = u.strokeWidth), n.strokeText(A, s, o, u.maxWidth)), n.fillText(A, s, o, u.maxWidth), Mr(n, s, o, A, u), o += Number(c.lineHeight);
                n.restore()
            }

            function ts(n, a) {
                const {
                    x: s,
                    y: o,
                    w: c,
                    h: u,
                    radius: f
                } = a;
                n.arc(s + f.topLeft, o + f.topLeft, f.topLeft, 1.5 * jt, jt, !0), n.lineTo(s, o + u - f.bottomLeft), n.arc(s + f.bottomLeft, o + u - f.bottomLeft, f.bottomLeft, jt, Y, !0), n.lineTo(s + c - f.bottomRight, o + u), n.arc(s + c - f.bottomRight, o + u - f.bottomRight, f.bottomRight, Y, 0, !0), n.lineTo(s + c, o + f.topRight), n.arc(s + c - f.topRight, o + f.topRight, f.topRight, 0, -Y, !0), n.lineTo(s + f.topLeft, o)
            }
            const Lr = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
                _r = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;

            function Tr(n, a) {
                const s = ("" + n).match(Lr);
                if (!s || "normal" === s[1]) return 1.2 * a;
                switch (n = +s[2], s[3]) {
                    case "px":
                        return n;
                    case "%":
                        n /= 100
                }
                return a * n
            }
            const Or = n => +n || 0;

            function Hs(n, a) {
                const s = {},
                    o = Tt(a),
                    c = o ? Object.keys(a) : a,
                    u = Tt(n) ? o ? f => Ct(n[f], n[a[f]]) : f => n[f] : () => n;
                for (const f of c) s[f] = Or(u(f));
                return s
            }

            function ba(n) {
                return Hs(n, {
                    top: "y",
                    right: "x",
                    bottom: "y",
                    left: "x"
                })
            }

            function Ei(n) {
                return Hs(n, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
            }

            function ye(n) {
                const a = ba(n);
                return a.width = a.left + a.right, a.height = a.top + a.bottom, a
            }

            function de(n, a) {
                let s = Ct((n = n || {}).size, (a = a || Xt.font).size);
                "string" == typeof s && (s = parseInt(s, 10));
                let o = Ct(n.style, a.style);
                o && !("" + o).match(_r) && (console.warn('Invalid font style specified: "' + o + '"'), o = void 0);
                const c = {
                    family: Ct(n.family, a.family),
                    lineHeight: Tr(Ct(n.lineHeight, a.lineHeight), s),
                    size: s,
                    style: o,
                    weight: Ct(n.weight, a.weight),
                    string: ""
                };
                return c.string = function fe(n) {
                    return !n || zt(n.size) || zt(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family
                }(c), c
            }

            function es(n, a, s, o) {
                let u, f, m, c = !0;
                for (u = 0, f = n.length; u < f; ++u)
                    if (m = n[u], void 0 !== m && (void 0 !== a && "function" == typeof m && (m = m(a), c = !1), void 0 !== s && Qt(m) && (m = m[s % m.length], c = !1), void 0 !== m)) return o && !c && (o.cacheable = !1), m
            }

            function wi(n, a) {
                return Object.assign(Object.create(n), a)
            }

            function Ys(n, a = [""], s, o, c = (() => n[0])) {
                const u = s || n;
                typeof o > "u" && (o = Aa("_fallback", n));
                const f = {
                    [Symbol.toStringTag]: "Object",
                    _cacheable: !0,
                    _scopes: n,
                    _rootScopes: u,
                    _fallback: o,
                    _getTarget: c,
                    override: m => Ys([m, ...n], a, u, o)
                };
                return new Proxy(f, {
                    deleteProperty: (m, y) => (delete m[y], delete m._keys, delete n[0][y], !0),
                    get: (m, y) => ya(m, y, () => function Br(n, a, s, o) {
                        let c;
                        for (const u of a)
                            if (c = Aa(Dr(u, n), s), typeof c < "u") return Ws(n, c) ? Vs(s, o, n, c) : c
                    }(y, a, n, m)),
                    getOwnPropertyDescriptor: (m, y) => Reflect.getOwnPropertyDescriptor(m._scopes[0], y),
                    getPrototypeOf: () => Reflect.getPrototypeOf(n[0]),
                    has: (m, y) => Sa(m).includes(y),
                    ownKeys: m => Sa(m),
                    set(m, y, A) {
                        const L = m._storage || (m._storage = c());
                        return m[y] = L[y] = A, delete m._keys, !0
                    }
                })
            }

            function ji(n, a, s, o) {
                const c = {
                    _cacheable: !1,
                    _proxy: n,
                    _context: a,
                    _subProxy: s,
                    _stack: new Set,
                    _descriptors: va(n, o),
                    setContext: u => ji(n, u, s, o),
                    override: u => ji(n.override(u), a, s, o)
                };
                return new Proxy(c, {
                    deleteProperty: (u, f) => (delete u[f], delete n[f], !0),
                    get: (u, f, m) => ya(u, f, () => function Ir(n, a, s) {
                        const {
                            _proxy: o,
                            _context: c,
                            _subProxy: u,
                            _descriptors: f
                        } = n;
                        let m = o[a];
                        return Xe(m) && f.isScriptable(a) && (m = function zr(n, a, s, o) {
                            const {
                                _proxy: c,
                                _context: u,
                                _subProxy: f,
                                _stack: m
                            } = s;
                            if (m.has(n)) throw new Error("Recursion detected: " + Array.from(m).join("->") + "->" + n);
                            m.add(n);
                            let y = a(u, f || o);
                            return m.delete(n), Ws(n, y) && (y = Vs(c._scopes, c, n, y)), y
                        }(a, m, n, s)), Qt(m) && m.length && (m = function Rr(n, a, s, o) {
                            const {
                                _proxy: c,
                                _context: u,
                                _subProxy: f,
                                _descriptors: m
                            } = s;
                            if (typeof u.index < "u" && o(n)) return a[u.index % a.length];
                            if (Tt(a[0])) {
                                const y = a,
                                    A = c._scopes.filter(L => L !== y);
                                a = [];
                                for (const L of y) {
                                    const O = Vs(A, c, n, L);
                                    a.push(ji(O, u, f && f[n], m))
                                }
                            }
                            return a
                        }(a, m, n, f.isIndexable)), Ws(a, m) && (m = ji(m, c, u && u[a], f)), m
                    }(u, f, m)),
                    getOwnPropertyDescriptor: (u, f) => u._descriptors.allKeys ? Reflect.has(n, f) ? {
                        enumerable: !0,
                        configurable: !0
                    } : void 0 : Reflect.getOwnPropertyDescriptor(n, f),
                    getPrototypeOf: () => Reflect.getPrototypeOf(n),
                    has: (u, f) => Reflect.has(n, f),
                    ownKeys: () => Reflect.ownKeys(n),
                    set: (u, f, m) => (n[f] = m, delete u[f], !0)
                })
            }

            function va(n, a = {
                scriptable: !0,
                indexable: !0
            }) {
                const {
                    _scriptable: s = a.scriptable,
                    _indexable: o = a.indexable,
                    _allKeys: c = a.allKeys
                } = n;
                return {
                    allKeys: c,
                    scriptable: s,
                    indexable: o,
                    isScriptable: Xe(s) ? s : () => s,
                    isIndexable: Xe(o) ? o : () => o
                }
            }
            const Dr = (n, a) => n ? n + yi(a) : a,
                Ws = (n, a) => Tt(a) && "adapters" !== n && (null === Object.getPrototypeOf(a) || a.constructor === Object);

            function ya(n, a, s) {
                if (Object.prototype.hasOwnProperty.call(n, a)) return n[a];
                const o = s();
                return n[a] = o, o
            }

            function wa(n, a, s) {
                return Xe(n) ? n(a, s) : n
            }
            const Fr = (n, a) => !0 === n ? a : "string" == typeof n ? Fe(a, n) : void 0;

            function Xr(n, a, s, o, c) {
                for (const u of a) {
                    const f = Fr(s, u);
                    if (f) {
                        n.add(f);
                        const m = wa(f._fallback, s, c);
                        if (typeof m < "u" && m !== s && m !== o) return m
                    } else if (!1 === f && typeof o < "u" && s !== o) return null
                }
                return !1
            }

            function Vs(n, a, s, o) {
                const c = a._rootScopes,
                    u = wa(a._fallback, s, o),
                    f = [...n, ...c],
                    m = new Set;
                m.add(o);
                let y = ka(m, f, s, u || s, o);
                return !(null === y || typeof u < "u" && u !== s && (y = ka(m, f, u, y, o), null === y)) && Ys(Array.from(m), [""], c, u, () => function Nr(n, a, s) {
                    const o = n._getTarget();
                    a in o || (o[a] = {});
                    const c = o[a];
                    return Qt(c) && Tt(s) ? s : c || {}
                }(a, s, o))
            }

            function ka(n, a, s, o, c) {
                for (; s;) s = Xr(n, a, s, o, c);
                return s
            }

            function Aa(n, a) {
                for (const s of a) {
                    if (!s) continue;
                    const o = s[n];
                    if (typeof o < "u") return o
                }
            }

            function Sa(n) {
                let a = n._keys;
                return a || (a = n._keys = function Hr(n) {
                    const a = new Set;
                    for (const s of n)
                        for (const o of Object.keys(s).filter(c => !c.startsWith("_"))) a.add(o);
                    return Array.from(a)
                }(n._scopes)), a
            }

            function Ca(n, a, s, o) {
                const {
                    iScale: c
                } = n, {
                    key: u = "r"
                } = this._parsing, f = new Array(o);
                let m, y, A, L;
                for (m = 0, y = o; m < y; ++m) A = m + s, L = a[A], f[m] = {
                    r: c.parse(Fe(L, u), A)
                };
                return f
            }
            const Yr = Number.EPSILON || 1e-14,
                Ui = (n, a) => a < n.length && !n[a].skip && n[a],
                Ma = n => "x" === n ? "y" : "x";

            function Wr(n, a, s, o) {
                const c = n.skip ? a : n,
                    u = a,
                    f = s.skip ? a : s,
                    m = ge(u, c),
                    y = ge(f, u);
                let A = m / (m + y),
                    L = y / (m + y);
                A = isNaN(A) ? 0 : A, L = isNaN(L) ? 0 : L;
                const O = o * A,
                    z = o * L;
                return {
                    previous: {
                        x: u.x - O * (f.x - c.x),
                        y: u.y - O * (f.y - c.y)
                    },
                    next: {
                        x: u.x + z * (f.x - c.x),
                        y: u.y + z * (f.y - c.y)
                    }
                }
            }

            function bs(n, a, s) {
                return Math.max(Math.min(n, s), a)
            }

            function Zr(n, a, s, o, c) {
                let u, f, m, y;
                if (a.spanGaps && (n = n.filter(A => !A.skip)), "monotone" === a.cubicInterpolationMode) ! function jr(n, a = "x") {
                    const s = Ma(a),
                        o = n.length,
                        c = Array(o).fill(0),
                        u = Array(o);
                    let f, m, y, A = Ui(n, 0);
                    for (f = 0; f < o; ++f)
                        if (m = y, y = A, A = Ui(n, f + 1), y) {
                            if (A) {
                                const L = A[a] - y[a];
                                c[f] = 0 !== L ? (A[s] - y[s]) / L : 0
                            }
                            u[f] = m ? A ? rt(c[f - 1]) !== rt(c[f]) ? 0 : (c[f - 1] + c[f]) / 2 : c[f - 1] : c[f]
                        }(function Vr(n, a, s) {
                            const o = n.length;
                            let c, u, f, m, y, A = Ui(n, 0);
                            for (let L = 0; L < o - 1; ++L)
                                if (y = A, A = Ui(n, L + 1), y && A) {
                                    if (lt(a[L], 0, Yr)) {
                                        s[L] = s[L + 1] = 0;
                                        continue
                                    }
                                    c = s[L] / a[L], u = s[L + 1] / a[L], m = Math.pow(c, 2) + Math.pow(u, 2), !(m <= 9) && (f = 3 / Math.sqrt(m), s[L] = c * f * a[L], s[L + 1] = u * f * a[L])
                                }
                        })(n, c, u),
                    function Gr(n, a, s = "x") {
                        const o = Ma(s),
                            c = n.length;
                        let u, f, m, y = Ui(n, 0);
                        for (let A = 0; A < c; ++A) {
                            if (f = m, m = y, y = Ui(n, A + 1), !m) continue;
                            const L = m[s],
                                O = m[o];
                            f && (u = (L - f[s]) / 3, m[`cp1${s}`] = L - u, m[`cp1${o}`] = O - u * a[A]), y && (u = (y[s] - L) / 3, m[`cp2${s}`] = L + u, m[`cp2${o}`] = O + u * a[A])
                        }
                    }(n, u, a)
                }(n, c);
                else {
                    let A = o ? n[n.length - 1] : n[0];
                    for (u = 0, f = n.length; u < f; ++u) m = n[u], y = Wr(A, m, n[Math.min(u + 1, f - (o ? 0 : 1)) % f], a.tension), m.cp1x = y.previous.x, m.cp1y = y.previous.y, m.cp2x = y.next.x, m.cp2y = y.next.y, A = m
                }
                a.capBezierPoints && function Ur(n, a) {
                    let s, o, c, u, f, m = ai(n[0], a);
                    for (s = 0, o = n.length; s < o; ++s) f = u, u = m, m = s < o - 1 && ai(n[s + 1], a), u && (c = n[s], f && (c.cp1x = bs(c.cp1x, a.left, a.right), c.cp1y = bs(c.cp1y, a.top, a.bottom)), m && (c.cp2x = bs(c.cp2x, a.left, a.right), c.cp2y = bs(c.cp2y, a.top, a.bottom)))
                }(n, s)
            }

            function Pa() {
                return typeof window < "u" && typeof document < "u"
            }

            function Gs(n) {
                let a = n.parentNode;
                return a && "[object ShadowRoot]" === a.toString() && (a = a.host), a
            }

            function vs(n, a, s) {
                let o;
                return "string" == typeof n ? (o = parseInt(n, 10), -1 !== n.indexOf("%") && (o = o / 100 * a.parentNode[s])) : o = n, o
            }
            const ys = n => n.ownerDocument.defaultView.getComputedStyle(n, null),
                qr = ["top", "right", "bottom", "left"];

            function Di(n, a, s) {
                const o = {};
                s = s ? "-" + s : "";
                for (let c = 0; c < 4; c++) {
                    const u = qr[c];
                    o[u] = parseFloat(n[a + "-" + u + s]) || 0
                }
                return o.width = o.left + o.right, o.height = o.top + o.bottom, o
            }
            const Kr = (n, a, s) => (n > 0 || a > 0) && (!s || !s.shadowRoot);

            function Ii(n, a) {
                if ("native" in n) return n;
                const {
                    canvas: s,
                    currentDevicePixelRatio: o
                } = a, c = ys(s), u = "border-box" === c.boxSizing, f = Di(c, "padding"), m = Di(c, "border", "width"), {
                    x: y,
                    y: A,
                    box: L
                } = function Qr(n, a) {
                    const s = n.touches,
                        o = s && s.length ? s[0] : n,
                        {
                            offsetX: c,
                            offsetY: u
                        } = o;
                    let m, y, f = !1;
                    if (Kr(c, u, n.target)) m = c, y = u;
                    else {
                        const A = a.getBoundingClientRect();
                        m = o.clientX - A.left, y = o.clientY - A.top, f = !0
                    }
                    return {
                        x: m,
                        y,
                        box: f
                    }
                }(n, s), O = f.left + (L && m.left), z = f.top + (L && m.top);
                let {
                    width: B,
                    height: V
                } = a;
                return u && (B -= f.width + m.width, V -= f.height + m.height), {
                    x: Math.round((y - O) / B * s.width / o),
                    y: Math.round((A - z) / V * s.height / o)
                }
            }
            const ws = n => Math.round(10 * n) / 10;

            function La(n, a, s) {
                const o = a || 1,
                    c = Math.floor(n.height * o),
                    u = Math.floor(n.width * o);
                n.height = Math.floor(n.height), n.width = Math.floor(n.width);
                const f = n.canvas;
                return f.style && (s || !f.style.height && !f.style.width) && (f.style.height = `${n.height}px`, f.style.width = `${n.width}px`), (n.currentDevicePixelRatio !== o || f.height !== c || f.width !== u) && (n.currentDevicePixelRatio = o, f.height = c, f.width = u, n.ctx.setTransform(o, 0, 0, o, 0, 0), !0)
            }
            const eo = function() {
                let n = !1;
                try {
                    const a = {
                        get passive() {
                            return n = !0, !1
                        }
                    };
                    window.addEventListener("test", null, a), window.removeEventListener("test", null, a)
                } catch {}
                return n
            }();

            function _a(n, a) {
                const s = function $r(n, a) {
                        return ys(n).getPropertyValue(a)
                    }(n, a),
                    o = s && s.match(/^(\d+)(\.\d+)?px$/);
                return o ? +o[1] : void 0
            }

            function zi(n, a, s, o) {
                return {
                    x: n.x + s * (a.x - n.x),
                    y: n.y + s * (a.y - n.y)
                }
            }

            function io(n, a, s, o) {
                return {
                    x: n.x + s * (a.x - n.x),
                    y: "middle" === o ? s < .5 ? n.y : a.y : "after" === o ? s < 1 ? n.y : a.y : s > 0 ? a.y : n.y
                }
            }

            function so(n, a, s, o) {
                const c = {
                        x: n.cp2x,
                        y: n.cp2y
                    },
                    u = {
                        x: a.cp1x,
                        y: a.cp1y
                    },
                    f = zi(n, c, s),
                    m = zi(c, u, s),
                    y = zi(u, a, s),
                    A = zi(f, m, s),
                    L = zi(m, y, s);
                return zi(A, L, s)
            }

            function Zi(n, a, s) {
                return n ? function(n, a) {
                    return {
                        x: s => n + n + a - s,
                        setWidth(s) {
                            a = s
                        },
                        textAlign: s => "center" === s ? s : "right" === s ? "left" : "right",
                        xPlus: (s, o) => s - o,
                        leftForLtr: (s, o) => s - o
                    }
                }(a, s) : {
                    x: n => n,
                    setWidth(n) {},
                    textAlign: n => n,
                    xPlus: (n, a) => n + a,
                    leftForLtr: (n, a) => n
                }
            }

            function Ta(n, a) {
                let s, o;
                ("ltr" === a || "rtl" === a) && (s = n.canvas.style, o = [s.getPropertyValue("direction"), s.getPropertyPriority("direction")], s.setProperty("direction", a, "important"), n.prevTextDirection = o)
            }

            function Oa(n, a) {
                void 0 !== a && (delete n.prevTextDirection, n.canvas.style.setProperty("direction", a[0], a[1]))
            }

            function Ea(n) {
                return "angle" === n ? {
                    between: Lt,
                    compare: Se,
                    normalize: Wt
                } : {
                    between: t,
                    compare: (a, s) => a - s,
                    normalize: a => a
                }
            }

            function Da({
                start: n,
                end: a,
                count: s,
                loop: o,
                style: c
            }) {
                return {
                    start: n % s,
                    end: a % s,
                    loop: o && (a - n + 1) % s == 0,
                    style: c
                }
            }

            function Ia(n, a, s) {
                if (!s) return [n];
                const {
                    property: o,
                    start: c,
                    end: u
                } = s, f = a.length, {
                    compare: m,
                    between: y,
                    normalize: A
                } = Ea(o), {
                    start: L,
                    end: O,
                    loop: z,
                    style: B
                } = function ro(n, a, s) {
                    const {
                        property: o,
                        start: c,
                        end: u
                    } = s, {
                        between: f,
                        normalize: m
                    } = Ea(o), y = a.length;
                    let z, B, {
                        start: A,
                        end: L,
                        loop: O
                    } = n;
                    if (O) {
                        for (A += y, L += y, z = 0, B = y; z < B && f(m(a[A % y][o]), c, u); ++z) A--, L--;
                        A %= y, L %= y
                    }
                    return L < A && (L += y), {
                        start: A,
                        end: L,
                        loop: O,
                        style: n.style
                    }
                }(n, a, s), V = [];
                let tt, J, dt, G = !1,
                    Z = null;
                for (let vt = L, St = L; vt <= O; ++vt) J = a[vt % f], !J.skip && (tt = A(J[o]), tt !== dt && (G = y(tt, c, u), null === Z && (G || y(c, dt, tt) && 0 !== m(c, dt)) && (Z = 0 === m(tt, c) ? vt : St), null !== Z && (!G || 0 === m(u, tt) || y(u, dt, tt)) && (V.push(Da({
                    start: Z,
                    end: vt,
                    loop: z,
                    count: f,
                    style: B
                })), Z = null), St = vt, dt = tt));
                return null !== Z && V.push(Da({
                    start: Z,
                    end: O,
                    loop: z,
                    count: f,
                    style: B
                })), V
            }

            function za(n, a) {
                const s = [],
                    o = n.segments;
                for (let c = 0; c < o.length; c++) {
                    const u = Ia(o[c], n.points, a);
                    u.length && s.push(...u)
                }
                return s
            }

            function Fa(n) {
                return {
                    backgroundColor: n.backgroundColor,
                    borderCapStyle: n.borderCapStyle,
                    borderDash: n.borderDash,
                    borderDashOffset: n.borderDashOffset,
                    borderJoinStyle: n.borderJoinStyle,
                    borderWidth: n.borderWidth,
                    borderColor: n.borderColor
                }
            }

            function uo(n, a) {
                if (!a) return !1;
                const s = [],
                    o = function(c, u) {
                        return X(u) ? (s.includes(u) || s.push(u), s.indexOf(u)) : u
                    };
                return JSON.stringify(n, o) !== JSON.stringify(a, o)
            }
            class go {
                constructor() {
                    this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
                }
                _notify(a, s, o, c) {
                    const f = s.duration;
                    s.listeners[c].forEach(m => m({
                        chart: a,
                        initial: s.initial,
                        numSteps: f,
                        currentStep: Math.min(o - s.start, f)
                    }))
                }
                _refresh() {
                    this._request || (this._running = !0, this._request = v.call(window, () => {
                        this._update(), this._request = null, this._running && this._refresh()
                    }))
                }
                _update(a = Date.now()) {
                    let s = 0;
                    this._charts.forEach((o, c) => {
                        if (!o.running || !o.items.length) return;
                        const u = o.items;
                        let y, f = u.length - 1,
                            m = !1;
                        for (; f >= 0; --f) y = u[f], y._active ? (y._total > o.duration && (o.duration = y._total), y.tick(a), m = !0) : (u[f] = u[u.length - 1], u.pop());
                        m && (c.draw(), this._notify(c, o, a, "progress")), u.length || (o.running = !1, this._notify(c, o, a, "complete"), o.initial = !1), s += u.length
                    }), this._lastDate = a, 0 === s && (this._running = !1)
                }
                _getAnims(a) {
                    const s = this._charts;
                    let o = s.get(a);
                    return o || (o = {
                        running: !1,
                        initial: !0,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    }, s.set(a, o)), o
                }
                listen(a, s, o) {
                    this._getAnims(a).listeners[s].push(o)
                }
                add(a, s) {
                    !s || !s.length || this._getAnims(a).items.push(...s)
                }
                has(a) {
                    return this._getAnims(a).items.length > 0
                }
                start(a) {
                    const s = this._charts.get(a);
                    s && (s.running = !0, s.start = Date.now(), s.duration = s.items.reduce((o, c) => Math.max(o, c._duration), 0), this._refresh())
                }
                running(a) {
                    if (!this._running) return !1;
                    const s = this._charts.get(a);
                    return !(!s || !s.running || !s.items.length)
                }
                stop(a) {
                    const s = this._charts.get(a);
                    if (!s || !s.items.length) return;
                    const o = s.items;
                    let c = o.length - 1;
                    for (; c >= 0; --c) o[c].cancel();
                    s.items = [], this._notify(a, s, Date.now(), "complete")
                }
                remove(a) {
                    return this._charts.delete(a)
                }
            }
            var ni = new go;
            const Xa = "transparent",
                fo = {
                    boolean: (n, a, s) => s > .5 ? a : n,
                    color(n, a, s) {
                        const o = H(n || Xa),
                            c = o.valid && H(a || Xa);
                        return c && c.valid ? c.mix(o, s).hexString() : a
                    },
                    number: (n, a, s) => n + (a - n) * s
                };
            class po {
                constructor(a, s, o, c) {
                    const u = s[o];
                    c = es([a.to, c, u, a.from]);
                    const f = es([a.from, u, c]);
                    this._active = !0, this._fn = a.fn || fo[a.type || typeof f], this._easing = D[a.easing] || D.linear, this._start = Math.floor(Date.now() + (a.delay || 0)), this._duration = this._total = Math.floor(a.duration), this._loop = !!a.loop, this._target = s, this._prop = o, this._from = f, this._to = c, this._promises = void 0
                }
                active() {
                    return this._active
                }
                update(a, s, o) {
                    if (this._active) {
                        this._notify(!1);
                        const c = this._target[this._prop],
                            u = o - this._start,
                            f = this._duration - u;
                        this._start = o, this._duration = Math.floor(Math.max(f, a.duration)), this._total += u, this._loop = !!a.loop, this._to = es([a.to, s, c, a.from]), this._from = es([a.from, c, s])
                    }
                }
                cancel() {
                    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
                }
                tick(a) {
                    const s = a - this._start,
                        o = this._duration,
                        c = this._prop,
                        u = this._from,
                        f = this._loop,
                        m = this._to;
                    let y;
                    if (this._active = u !== m && (f || s < o), !this._active) return this._target[c] = m, void this._notify(!0);
                    s < 0 ? this._target[c] = u : (y = s / o % 2, y = f && y > 1 ? 2 - y : y, y = this._easing(Math.min(1, Math.max(0, y))), this._target[c] = this._fn(u, m, y))
                }
                wait() {
                    const a = this._promises || (this._promises = []);
                    return new Promise((s, o) => {
                        a.push({
                            res: s,
                            rej: o
                        })
                    })
                }
                _notify(a) {
                    const s = a ? "res" : "rej",
                        o = this._promises || [];
                    for (let c = 0; c < o.length; c++) o[c][s]()
                }
            }
            class Na {
                constructor(a, s) {
                    this._chart = a, this._properties = new Map, this.configure(s)
                }
                configure(a) {
                    if (!Tt(a)) return;
                    const s = Object.keys(Xt.animation),
                        o = this._properties;
                    Object.getOwnPropertyNames(a).forEach(c => {
                        const u = a[c];
                        if (!Tt(u)) return;
                        const f = {};
                        for (const m of s) f[m] = u[m];
                        (Qt(u.properties) && u.properties || [c]).forEach(m => {
                            (m === c || !o.has(m)) && o.set(m, f)
                        })
                    })
                }
                _animateOptions(a, s) {
                    const o = s.options,
                        c = function mo(n, a) {
                            if (!a) return;
                            let s = n.options;
                            if (s) return s.$shared && (n.options = s = Object.assign({}, s, {
                                $shared: !1,
                                $animations: {}
                            })), s;
                            n.options = a
                        }(a, o);
                    if (!c) return [];
                    const u = this._createAnimations(c, o);
                    return o.$shared && function xo(n, a) {
                        const s = [],
                            o = Object.keys(a);
                        for (let c = 0; c < o.length; c++) {
                            const u = n[o[c]];
                            u && u.active() && s.push(u.wait())
                        }
                        return Promise.all(s)
                    }(a.options.$animations, o).then(() => {
                        a.options = o
                    }, () => {}), u
                }
                _createAnimations(a, s) {
                    const o = this._properties,
                        c = [],
                        u = a.$animations || (a.$animations = {}),
                        f = Object.keys(s),
                        m = Date.now();
                    let y;
                    for (y = f.length - 1; y >= 0; --y) {
                        const A = f[y];
                        if ("$" === A.charAt(0)) continue;
                        if ("options" === A) {
                            c.push(...this._animateOptions(a, s));
                            continue
                        }
                        const L = s[A];
                        let O = u[A];
                        const z = o.get(A);
                        if (O) {
                            if (z && O.active()) {
                                O.update(z, L, m);
                                continue
                            }
                            O.cancel()
                        }
                        z && z.duration ? (u[A] = O = new po(z, a, A, L), c.push(O)) : a[A] = L
                    }
                    return c
                }
                update(a, s) {
                    if (0 === this._properties.size) return void Object.assign(a, s);
                    const o = this._createAnimations(a, s);
                    return o.length ? (ni.add(this._chart, o), !0) : void 0
                }
            }

            function Ba(n, a) {
                const s = n && n.options || {},
                    o = s.reverse,
                    c = void 0 === s.min ? a : 0,
                    u = void 0 === s.max ? a : 0;
                return {
                    start: o ? u : c,
                    end: o ? c : u
                }
            }

            function Ha(n, a) {
                const s = [],
                    o = n._getSortedDatasetMetas(a);
                let c, u;
                for (c = 0, u = o.length; c < u; ++c) s.push(o[c].index);
                return s
            }

            function Ya(n, a, s, o = {}) {
                const c = n.keys,
                    u = "single" === o.mode;
                let f, m, y, A;
                if (null !== a) {
                    for (f = 0, m = c.length; f < m; ++f) {
                        if (y = +c[f], y === s) {
                            if (o.all) continue;
                            break
                        }
                        A = n.values[y], $t(A) && (u || 0 === a || rt(a) === rt(A)) && (a += A)
                    }
                    return a
                }
            }

            function Wa(n, a) {
                const s = n && n.options.stacked;
                return s || void 0 === s && void 0 !== a.stack
            }

            function Ao(n, a, s) {
                const o = n[a] || (n[a] = {});
                return o[s] || (o[s] = {})
            }

            function Va(n, a, s, o) {
                for (const c of a.getMatchingVisibleMetas(o).reverse()) {
                    const u = n[c.index];
                    if (s && u > 0 || !s && u < 0) return c.index
                }
                return null
            }

            function Ga(n, a) {
                const {
                    chart: s,
                    _cachedMeta: o
                } = n, c = s._stacks || (s._stacks = {}), {
                    iScale: u,
                    vScale: f,
                    index: m
                } = o, y = u.axis, A = f.axis, L = function wo(n, a, s) {
                    return `${n.id}.${a.id}.${s.stack||s.type}`
                }(u, f, o), O = a.length;
                let z;
                for (let B = 0; B < O; ++B) {
                    const V = a[B],
                        {
                            [y]: G,
                            [A]: Z
                        } = V;
                    z = (V._stacks || (V._stacks = {}))[A] = Ao(c, L, G), z[m] = Z, z._top = Va(z, f, !0, o.type), z._bottom = Va(z, f, !1, o.type), (z._visualValues || (z._visualValues = {}))[m] = Z
                }
            }

            function js(n, a) {
                const s = n.scales;
                return Object.keys(s).filter(o => s[o].axis === a).shift()
            }

            function is(n, a) {
                const s = n.controller.index,
                    o = n.vScale && n.vScale.axis;
                if (o) {
                    a = a || n._parsed;
                    for (const c of a) {
                        const u = c._stacks;
                        if (!u || void 0 === u[o] || void 0 === u[o][s]) return;
                        delete u[o][s], void 0 !== u[o]._visualValues && void 0 !== u[o]._visualValues[s] && delete u[o]._visualValues[s]
                    }
                }
            }
            const Us = n => "reset" === n || "none" === n,
                ja = (n, a) => a ? n : Object.assign({}, n);
            let ki = (() => class n {
                static defaults = {};
                static datasetElementType = null;
                static dataElementType = null;
                constructor(s, o) {
                    this.chart = s, this._ctx = s.ctx, this.index = o, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize()
                }
                initialize() {
                    const s = this._cachedMeta;
                    this.configure(), this.linkScales(), s._stacked = Wa(s.vScale, s), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
                }
                updateIndex(s) {
                    this.index !== s && is(this._cachedMeta), this.index = s
                }
                linkScales() {
                    const s = this.chart,
                        o = this._cachedMeta,
                        c = this.getDataset(),
                        u = (z, B, V, G) => "x" === z ? B : "r" === z ? G : V,
                        f = o.xAxisID = Ct(c.xAxisID, js(s, "x")),
                        m = o.yAxisID = Ct(c.yAxisID, js(s, "y")),
                        y = o.rAxisID = Ct(c.rAxisID, js(s, "r")),
                        A = o.indexAxis,
                        L = o.iAxisID = u(A, f, m, y),
                        O = o.vAxisID = u(A, m, f, y);
                    o.xScale = this.getScaleForId(f), o.yScale = this.getScaleForId(m), o.rScale = this.getScaleForId(y), o.iScale = this.getScaleForId(L), o.vScale = this.getScaleForId(O)
                }
                getDataset() {
                    return this.chart.data.datasets[this.index]
                }
                getMeta() {
                    return this.chart.getDatasetMeta(this.index)
                }
                getScaleForId(s) {
                    return this.chart.scales[s]
                }
                _getOtherScale(s) {
                    const o = this._cachedMeta;
                    return s === o.iScale ? o.vScale : o.iScale
                }
                reset() {
                    this._update("reset")
                }
                _destroy() {
                    const s = this._cachedMeta;
                    this._data && g(this._data, this), s._stacked && is(s)
                }
                _dataCheck() {
                    const s = this.getDataset(),
                        o = s.data || (s.data = []),
                        c = this._data;
                    if (Tt(o)) this._data = function yo(n) {
                        const a = Object.keys(n),
                            s = new Array(a.length);
                        let o, c, u;
                        for (o = 0, c = a.length; o < c; ++o) u = a[o], s[o] = {
                            x: u,
                            y: n[u]
                        };
                        return s
                    }(o);
                    else if (c !== o) {
                        if (c) {
                            g(c, this);
                            const u = this._cachedMeta;
                            is(u), u._parsed = []
                        }
                        o && Object.isExtensible(o) && function d(n, a) {
                            n._chartjs ? n._chartjs.listeners.push(a) : (Object.defineProperty(n, "_chartjs", {
                                configurable: !0,
                                enumerable: !1,
                                value: {
                                    listeners: [a]
                                }
                            }), h.forEach(s => {
                                const o = "_onData" + yi(s),
                                    c = n[s];
                                Object.defineProperty(n, s, {
                                    configurable: !0,
                                    enumerable: !1,
                                    value(...u) {
                                        const f = c.apply(this, u);
                                        return n._chartjs.listeners.forEach(m => {
                                            "function" == typeof m[o] && m[o](...u)
                                        }), f
                                    }
                                })
                            }))
                        }(o, this), this._syncList = [], this._data = o
                    }
                }
                addElements() {
                    const s = this._cachedMeta;
                    this._dataCheck(), this.datasetElementType && (s.dataset = new this.datasetElementType)
                }
                buildOrUpdateElements(s) {
                    const o = this._cachedMeta,
                        c = this.getDataset();
                    let u = !1;
                    this._dataCheck();
                    const f = o._stacked;
                    o._stacked = Wa(o.vScale, o), o.stack !== c.stack && (u = !0, is(o), o.stack = c.stack), this._resyncElements(s), (u || f !== o._stacked) && Ga(this, o._parsed)
                }
                configure() {
                    const s = this.chart.config,
                        o = s.datasetScopeKeys(this._type),
                        c = s.getOptionScopes(this.getDataset(), o, !0);
                    this.options = s.createResolver(c, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
                }
                parse(s, o) {
                    const {
                        _cachedMeta: c,
                        _data: u
                    } = this, {
                        iScale: f,
                        _stacked: m
                    } = c, y = f.axis;
                    let O, z, B, A = 0 === s && o === u.length || c._sorted,
                        L = s > 0 && c._parsed[s - 1];
                    if (!1 === this._parsing) c._parsed = u, c._sorted = !0, B = u;
                    else {
                        B = Qt(u[s]) ? this.parseArrayData(c, u, s, o) : Tt(u[s]) ? this.parseObjectData(c, u, s, o) : this.parsePrimitiveData(c, u, s, o);
                        const V = () => null === z[y] || L && z[y] < L[y];
                        for (O = 0; O < o; ++O) c._parsed[O + s] = z = B[O], A && (V() && (A = !1), L = z);
                        c._sorted = A
                    }
                    m && Ga(this, B)
                }
                parsePrimitiveData(s, o, c, u) {
                    const {
                        iScale: f,
                        vScale: m
                    } = s, y = f.axis, A = m.axis, L = f.getLabels(), O = f === m, z = new Array(u);
                    let B, V, G;
                    for (B = 0, V = u; B < V; ++B) G = B + c, z[B] = {
                        [y]: O || f.parse(L[G], G),
                        [A]: m.parse(o[G], G)
                    };
                    return z
                }
                parseArrayData(s, o, c, u) {
                    const {
                        xScale: f,
                        yScale: m
                    } = s, y = new Array(u);
                    let A, L, O, z;
                    for (A = 0, L = u; A < L; ++A) O = A + c, z = o[O], y[A] = {
                        x: f.parse(z[0], O),
                        y: m.parse(z[1], O)
                    };
                    return y
                }
                parseObjectData(s, o, c, u) {
                    const {
                        xScale: f,
                        yScale: m
                    } = s, {
                        xAxisKey: y = "x",
                        yAxisKey: A = "y"
                    } = this._parsing, L = new Array(u);
                    let O, z, B, V;
                    for (O = 0, z = u; O < z; ++O) B = O + c, V = o[B], L[O] = {
                        x: f.parse(Fe(V, y), B),
                        y: m.parse(Fe(V, A), B)
                    };
                    return L
                }
                getParsed(s) {
                    return this._cachedMeta._parsed[s]
                }
                getDataElement(s) {
                    return this._cachedMeta.data[s]
                }
                applyStack(s, o, c) {
                    const f = this._cachedMeta,
                        m = o[s.axis];
                    return Ya({
                        keys: Ha(this.chart, !0),
                        values: o._stacks[s.axis]._visualValues
                    }, m, f.index, {
                        mode: c
                    })
                }
                updateRangeFromParsed(s, o, c, u) {
                    const f = c[o.axis];
                    let m = null === f ? NaN : f;
                    const y = u && c._stacks[o.axis];
                    u && y && (u.values = y, m = Ya(u, f, this._cachedMeta.index)), s.min = Math.min(s.min, m), s.max = Math.max(s.max, m)
                }
                getMinMax(s, o) {
                    const c = this._cachedMeta,
                        u = c._parsed,
                        f = c._sorted && s === c.iScale,
                        m = u.length,
                        y = this._getOtherScale(s),
                        A = ((n, a, s) => n && !a.hidden && a._stacked && {
                            keys: Ha(this.chart, !0),
                            values: null
                        })(o, c),
                        L = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        },
                        {
                            min: O,
                            max: z
                        } = function ko(n) {
                            const {
                                min: a,
                                max: s,
                                minDefined: o,
                                maxDefined: c
                            } = n.getUserBounds();
                            return {
                                min: o ? a : Number.NEGATIVE_INFINITY,
                                max: c ? s : Number.POSITIVE_INFINITY
                            }
                        }(y);
                    let B, V;

                    function G() {
                        V = u[B];
                        const Z = V[y.axis];
                        return !$t(V[s.axis]) || O > Z || z < Z
                    }
                    for (B = 0; B < m && (G() || (this.updateRangeFromParsed(L, s, V, A), !f)); ++B);
                    if (f)
                        for (B = m - 1; B >= 0; --B)
                            if (!G()) {
                                this.updateRangeFromParsed(L, s, V, A);
                                break
                            }
                    return L
                }
                getAllParsedValues(s) {
                    const o = this._cachedMeta._parsed,
                        c = [];
                    let u, f, m;
                    for (u = 0, f = o.length; u < f; ++u) m = o[u][s.axis], $t(m) && c.push(m);
                    return c
                }
                getMaxOverflow() {
                    return !1
                }
                getLabelAndValue(s) {
                    const o = this._cachedMeta,
                        c = o.iScale,
                        u = o.vScale,
                        f = this.getParsed(s);
                    return {
                        label: c ? "" + c.getLabelForValue(f[c.axis]) : "",
                        value: u ? "" + u.getLabelForValue(f[u.axis]) : ""
                    }
                }
                _update(s) {
                    const o = this._cachedMeta;
                    this.update(s || "default"), o._clip = function vo(n) {
                        let a, s, o, c;
                        return Tt(n) ? (a = n.top, s = n.right, o = n.bottom, c = n.left) : a = s = o = c = n, {
                            top: a,
                            right: s,
                            bottom: o,
                            left: c,
                            disabled: !1 === n
                        }
                    }(Ct(this.options.clip, function bo(n, a, s) {
                        if (!1 === s) return !1;
                        const o = Ba(n, s),
                            c = Ba(a, s);
                        return {
                            top: c.end,
                            right: o.end,
                            bottom: c.start,
                            left: o.start
                        }
                    }(o.xScale, o.yScale, this.getMaxOverflow())))
                }
                update(s) {}
                draw() {
                    const s = this._ctx,
                        c = this._cachedMeta,
                        u = c.data || [],
                        f = this.chart.chartArea,
                        m = [],
                        y = this._drawStart || 0,
                        A = this._drawCount || u.length - y,
                        L = this.options.drawActiveElementsOnTop;
                    let O;
                    for (c.dataset && c.dataset.draw(s, f, y, A), O = y; O < y + A; ++O) {
                        const z = u[O];
                        z.hidden || (z.active && L ? m.push(z) : z.draw(s, f))
                    }
                    for (O = 0; O < m.length; ++O) m[O].draw(s, f)
                }
                getStyle(s, o) {
                    const c = o ? "active" : "default";
                    return void 0 === s && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(c) : this.resolveDataElementOptions(s || 0, c)
                }
                getContext(s, o, c) {
                    const u = this.getDataset();
                    let f;
                    if (s >= 0 && s < this._cachedMeta.data.length) {
                        const m = this._cachedMeta.data[s];
                        f = m.$context || (m.$context = function Co(n, a, s) {
                            return wi(n, {
                                active: !1,
                                dataIndex: a,
                                parsed: void 0,
                                raw: void 0,
                                element: s,
                                index: a,
                                mode: "default",
                                type: "data"
                            })
                        }(this.getContext(), s, m)), f.parsed = this.getParsed(s), f.raw = u.data[s], f.index = f.dataIndex = s
                    } else f = this.$context || (this.$context = function So(n, a) {
                        return wi(n, {
                            active: !1,
                            dataset: void 0,
                            datasetIndex: a,
                            index: a,
                            mode: "default",
                            type: "dataset"
                        })
                    }(this.chart.getContext(), this.index)), f.dataset = u, f.index = f.datasetIndex = this.index;
                    return f.active = !!o, f.mode = c, f
                }
                resolveDatasetElementOptions(s) {
                    return this._resolveElementOptions(this.datasetElementType.id, s)
                }
                resolveDataElementOptions(s, o) {
                    return this._resolveElementOptions(this.dataElementType.id, o, s)
                }
                _resolveElementOptions(s, o = "default", c) {
                    const u = "active" === o,
                        f = this._cachedDataOpts,
                        m = s + "-" + o,
                        y = f[m],
                        A = this.enableOptionSharing && Qe(c);
                    if (y) return ja(y, A);
                    const L = this.chart.config,
                        O = L.datasetElementScopeKeys(this._type, s),
                        z = u ? [`${s}Hover`, "hover", s, ""] : [s, ""],
                        B = L.getOptionScopes(this.getDataset(), O),
                        V = Object.keys(Xt.elements[s]),
                        Z = L.resolveNamedOptions(B, V, () => this.getContext(c, u, o), z);
                    return Z.$shared && (Z.$shared = A, f[m] = Object.freeze(ja(Z, A))), Z
                }
                _resolveAnimations(s, o, c) {
                    const u = this.chart,
                        f = this._cachedDataOpts,
                        m = `animation-${o}`,
                        y = f[m];
                    if (y) return y;
                    let A;
                    if (!1 !== u.options.animation) {
                        const O = this.chart.config,
                            z = O.datasetAnimationScopeKeys(this._type, o),
                            B = O.getOptionScopes(this.getDataset(), z);
                        A = O.createResolver(B, this.getContext(s, c, o))
                    }
                    const L = new Na(u, A && A.animations);
                    return A && A._cacheable && (f[m] = Object.freeze(L)), L
                }
                getSharedOptions(s) {
                    if (s.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, s))
                }
                includeOptions(s, o) {
                    return !o || Us(s) || this.chart._animationsDisabled
                }
                _getSharedOptions(s, o) {
                    const c = this.resolveDataElementOptions(s, o),
                        u = this._sharedOptions,
                        f = this.getSharedOptions(c),
                        m = this.includeOptions(o, f) || f !== u;
                    return this.updateSharedOptions(f, o, c), {
                        sharedOptions: f,
                        includeOptions: m
                    }
                }
                updateElement(s, o, c, u) {
                    Us(u) ? Object.assign(s, c) : this._resolveAnimations(o, u).update(s, c)
                }
                updateSharedOptions(s, o, c) {
                    s && !Us(o) && this._resolveAnimations(void 0, o).update(s, c)
                }
                _setStyle(s, o, c, u) {
                    s.active = u;
                    const f = this.getStyle(o, u);
                    this._resolveAnimations(o, c, u).update(s, {
                        options: !u && this.getSharedOptions(f) || f
                    })
                }
                removeHoverStyle(s, o, c) {
                    this._setStyle(s, c, "active", !1)
                }
                setHoverStyle(s, o, c) {
                    this._setStyle(s, c, "active", !0)
                }
                _removeDatasetHoverStyle() {
                    const s = this._cachedMeta.dataset;
                    s && this._setStyle(s, void 0, "active", !1)
                }
                _setDatasetHoverStyle() {
                    const s = this._cachedMeta.dataset;
                    s && this._setStyle(s, void 0, "active", !0)
                }
                _resyncElements(s) {
                    const o = this._data,
                        c = this._cachedMeta.data;
                    for (const [y, A, L] of this._syncList) this[y](A, L);
                    this._syncList = [];
                    const u = c.length,
                        f = o.length,
                        m = Math.min(f, u);
                    m && this.parse(0, m), f > u ? this._insertElements(u, f - u, s) : f < u && this._removeElements(f, u - f)
                }
                _insertElements(s, o, c = !0) {
                    const u = this._cachedMeta,
                        f = u.data,
                        m = s + o;
                    let y;
                    const A = L => {
                        for (L.length += o, y = L.length - 1; y >= m; y--) L[y] = L[y - o]
                    };
                    for (A(f), y = s; y < m; ++y) f[y] = new this.dataElementType;
                    this._parsing && A(u._parsed), this.parse(s, o), c && this.updateElements(f, s, o, "reset")
                }
                updateElements(s, o, c, u) {}
                _removeElements(s, o) {
                    const c = this._cachedMeta;
                    if (this._parsing) {
                        const u = c._parsed.splice(s, o);
                        c._stacked && is(c, u)
                    }
                    c.data.splice(s, o)
                }
                _sync(s) {
                    if (this._parsing) this._syncList.push(s);
                    else {
                        const [o, c, u] = s;
                        this[o](c, u)
                    }
                    this.chart._dataChanges.push([this.index, ...s])
                }
                _onDataPush() {
                    const s = arguments.length;
                    this._sync(["_insertElements", this.getDataset().data.length - s, s])
                }
                _onDataPop() {
                    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
                }
                _onDataShift() {
                    this._sync(["_removeElements", 0, 1])
                }
                _onDataSplice(s, o) {
                    o && this._sync(["_removeElements", s, o]);
                    const c = arguments.length - 2;
                    c && this._sync(["_insertElements", s, c])
                }
                _onDataUnshift() {
                    this._sync(["_insertElements", 0, arguments.length])
                }
            })();

            function Lo(n) {
                const a = n.iScale,
                    s = function Po(n, a) {
                        if (!n._cache.$bar) {
                            const s = n.getMatchingVisibleMetas(a);
                            let o = [];
                            for (let c = 0, u = s.length; c < u; c++) o = o.concat(s[c].controller.getAllParsedValues(n));
                            n._cache.$bar = x(o.sort((c, u) => c - u))
                        }
                        return n._cache.$bar
                    }(a, n.type);
                let c, u, f, m, o = a._length;
                const y = () => {
                    32767 === f || -32768 === f || (Qe(m) && (o = Math.min(o, Math.abs(f - m) || o)), m = f)
                };
                for (c = 0, u = s.length; c < u; ++c) f = a.getPixelForValue(s[c]), y();
                for (m = void 0, c = 0, u = a.ticks.length; c < u; ++c) f = a.getPixelForTick(c), y();
                return o
            }

            function Ua(n, a, s, o) {
                return Qt(n) ? function Oo(n, a, s, o) {
                    const c = s.parse(n[0], o),
                        u = s.parse(n[1], o),
                        f = Math.min(c, u),
                        m = Math.max(c, u);
                    let y = f,
                        A = m;
                    Math.abs(f) > Math.abs(m) && (y = m, A = f), a[s.axis] = A, a._custom = {
                        barStart: y,
                        barEnd: A,
                        start: c,
                        end: u,
                        min: f,
                        max: m
                    }
                }(n, a, s, o) : a[s.axis] = s.parse(n, o), a
            }

            function Za(n, a, s, o) {
                const c = n.iScale,
                    u = n.vScale,
                    f = c.getLabels(),
                    m = c === u,
                    y = [];
                let A, L, O, z;
                for (A = s, L = s + o; A < L; ++A) z = a[A], O = {}, O[c.axis] = m || c.parse(f[A], A), y.push(Ua(z, O, u, A));
                return y
            }

            function Zs(n) {
                return n && void 0 !== n.barStart && void 0 !== n.barEnd
            }

            function Io(n, a, s, o) {
                let c = a.borderSkipped;
                const u = {};
                if (!c) return void(n.borderSkipped = u);
                if (!0 === c) return void(n.borderSkipped = {
                    top: !0,
                    right: !0,
                    bottom: !0,
                    left: !0
                });
                const {
                    start: f,
                    end: m,
                    reverse: y,
                    top: A,
                    bottom: L
                } = function Do(n) {
                    let a, s, o, c, u;
                    return n.horizontal ? (a = n.base > n.x, s = "left", o = "right") : (a = n.base < n.y, s = "bottom", o = "top"), a ? (c = "end", u = "start") : (c = "start", u = "end"), {
                        start: s,
                        end: o,
                        reverse: a,
                        top: c,
                        bottom: u
                    }
                }(n);
                "middle" === c && s && (n.enableBorderRadius = !0, (s._top || 0) === o ? c = A : (s._bottom || 0) === o ? c = L : (u[$a(L, f, m, y)] = !0, c = A)), u[$a(c, f, m, y)] = !0, n.borderSkipped = u
            }

            function $a(n, a, s, o) {
                return o ? (n = function zo(n, a, s) {
                    return n === a ? s : n === s ? a : n
                }(n, a, s), n = qa(n, s, a)) : n = qa(n, a, s), n
            }

            function qa(n, a, s) {
                return "start" === n ? a : "end" === n ? s : n
            }

            function Ro(n, {
                inflateAmount: a
            }, s) {
                n.inflateAmount = "auto" === a ? 1 === s ? .33 : 0 : a
            }
            let Fo = (() => class n extends ki {
                    static id = "bar";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "bar",
                        categoryPercentage: .8,
                        barPercentage: .9,
                        grouped: !0,
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "base", "width", "height"]
                            }
                        }
                    };
                    static overrides = {
                        scales: {
                            _index_: {
                                type: "category",
                                offset: !0,
                                grid: {
                                    offset: !0
                                }
                            },
                            _value_: {
                                type: "linear",
                                beginAtZero: !0
                            }
                        }
                    };
                    parsePrimitiveData(s, o, c, u) {
                        return Za(s, o, c, u)
                    }
                    parseArrayData(s, o, c, u) {
                        return Za(s, o, c, u)
                    }
                    parseObjectData(s, o, c, u) {
                        const {
                            iScale: f,
                            vScale: m
                        } = s, {
                            xAxisKey: y = "x",
                            yAxisKey: A = "y"
                        } = this._parsing, L = "x" === f.axis ? y : A, O = "x" === m.axis ? y : A, z = [];
                        let B, V, G, Z;
                        for (B = c, V = c + u; B < V; ++B) Z = o[B], G = {}, G[f.axis] = f.parse(Fe(Z, L), B), z.push(Ua(Fe(Z, O), G, m, B));
                        return z
                    }
                    updateRangeFromParsed(s, o, c, u) {
                        super.updateRangeFromParsed(s, o, c, u);
                        const f = c._custom;
                        f && o === this._cachedMeta.vScale && (s.min = Math.min(s.min, f.min), s.max = Math.max(s.max, f.max))
                    }
                    getMaxOverflow() {
                        return 0
                    }
                    getLabelAndValue(s) {
                        const o = this._cachedMeta,
                            {
                                iScale: c,
                                vScale: u
                            } = o,
                            f = this.getParsed(s),
                            m = f._custom,
                            y = Zs(m) ? "[" + m.start + ", " + m.end + "]" : "" + u.getLabelForValue(f[u.axis]);
                        return {
                            label: "" + c.getLabelForValue(f[c.axis]),
                            value: y
                        }
                    }
                    initialize() {
                        this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack
                    }
                    update(s) {
                        const o = this._cachedMeta;
                        this.updateElements(o.data, 0, o.data.length, s)
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            {
                                index: m,
                                _cachedMeta: {
                                    vScale: y
                                }
                            } = this,
                            A = y.getBasePixel(),
                            L = y.isHorizontal(),
                            O = this._getRuler(),
                            {
                                sharedOptions: z,
                                includeOptions: B
                            } = this._getSharedOptions(o, u);
                        for (let V = o; V < o + c; V++) {
                            const G = this.getParsed(V),
                                Z = f || zt(G[y.axis]) ? {
                                    base: A,
                                    head: A
                                } : this._calculateBarValuePixels(V),
                                tt = this._calculateBarIndexPixels(V, O),
                                J = (G._stacks || {})[y.axis],
                                dt = {
                                    horizontal: L,
                                    base: Z.base,
                                    enableBorderRadius: !J || Zs(G._custom) || m === J._top || m === J._bottom,
                                    x: L ? Z.head : tt.center,
                                    y: L ? tt.center : Z.head,
                                    height: L ? tt.size : Math.abs(Z.size),
                                    width: L ? Math.abs(Z.size) : tt.size
                                };
                            B && (dt.options = z || this.resolveDataElementOptions(V, s[V].active ? "active" : u));
                            const pt = dt.options || s[V].options;
                            Io(dt, pt, J, m), Ro(dt, pt, O.ratio), this.updateElement(s[V], V, dt, u)
                        }
                    }
                    _getStacks(s, o) {
                        const {
                            iScale: c
                        } = this._cachedMeta, u = c.getMatchingVisibleMetas(this._type).filter(A => A.controller.options.grouped), f = c.options.stacked, m = [], y = A => {
                            const L = A.controller.getParsed(o),
                                O = L && L[A.vScale.axis];
                            if (zt(O) || isNaN(O)) return !0
                        };
                        for (const A of u)
                            if ((void 0 === o || !y(A)) && ((!1 === f || -1 === m.indexOf(A.stack) || void 0 === f && void 0 === A.stack) && m.push(A.stack), A.index === s)) break;
                        return m.length || m.push(void 0), m
                    }
                    _getStackCount(s) {
                        return this._getStacks(void 0, s).length
                    }
                    _getStackIndex(s, o, c) {
                        const u = this._getStacks(s, c),
                            f = void 0 !== o ? u.indexOf(o) : -1;
                        return -1 === f ? u.length - 1 : f
                    }
                    _getRuler() {
                        const s = this.options,
                            o = this._cachedMeta,
                            c = o.iScale,
                            u = [];
                        let f, m;
                        for (f = 0, m = o.data.length; f < m; ++f) u.push(c.getPixelForValue(this.getParsed(f)[c.axis], f));
                        const y = s.barThickness;
                        return {
                            min: y || Lo(o),
                            pixels: u,
                            start: c._startPixel,
                            end: c._endPixel,
                            stackCount: this._getStackCount(),
                            scale: c,
                            grouped: s.grouped,
                            ratio: y ? 1 : s.categoryPercentage * s.barPercentage
                        }
                    }
                    _calculateBarValuePixels(s) {
                        const {
                            _cachedMeta: {
                                vScale: o,
                                _stacked: c,
                                index: u
                            },
                            options: {
                                base: f,
                                minBarLength: m
                            }
                        } = this, y = f || 0, A = this.getParsed(s), L = A._custom, O = Zs(L);
                        let G, Z, z = A[o.axis],
                            B = 0,
                            V = c ? this.applyStack(o, A, c) : z;
                        V !== z && (B = V - z, V = z), O && (z = L.barStart, V = L.barEnd - L.barStart, 0 !== z && rt(z) !== rt(L.barEnd) && (B = 0), B += z);
                        const tt = zt(f) || O ? B : f;
                        let J = o.getPixelForValue(tt);
                        if (G = this.chart.getDataVisibility(s) ? o.getPixelForValue(B + V) : J, Z = G - J, Math.abs(Z) < m) {
                            Z = function Eo(n, a, s) {
                                return 0 !== n ? rt(n) : (a.isHorizontal() ? 1 : -1) * (a.min >= s ? 1 : -1)
                            }(Z, o, y) * m, z === y && (J -= Z / 2);
                            const dt = o.getPixelForDecimal(0),
                                pt = o.getPixelForDecimal(1),
                                nt = Math.min(dt, pt),
                                ft = Math.max(dt, pt);
                            J = Math.max(Math.min(J, ft), nt), G = J + Z, c && !O && (A._stacks[o.axis]._visualValues[u] = o.getValueForPixel(G) - o.getValueForPixel(J))
                        }
                        if (J === o.getPixelForValue(y)) {
                            const dt = rt(Z) * o.getLineWidthForValue(y) / 2;
                            J += dt, Z -= dt
                        }
                        return {
                            size: Z,
                            base: J,
                            head: G,
                            center: G + Z / 2
                        }
                    }
                    _calculateBarIndexPixels(s, o) {
                        const c = o.scale,
                            u = this.options,
                            f = u.skipNull,
                            m = Ct(u.maxBarThickness, 1 / 0);
                        let y, A;
                        if (o.grouped) {
                            const L = f ? this._getStackCount(s) : o.stackCount,
                                O = "flex" === u.barThickness ? function To(n, a, s, o) {
                                    const c = a.pixels,
                                        u = c[n];
                                    let f = n > 0 ? c[n - 1] : null,
                                        m = n < c.length - 1 ? c[n + 1] : null;
                                    const y = s.categoryPercentage;
                                    null === f && (f = u - (null === m ? a.end - a.start : m - u)), null === m && (m = u + u - f);
                                    const A = u - (u - Math.min(f, m)) / 2 * y;
                                    return {
                                        chunk: Math.abs(m - f) / 2 * y / o,
                                        ratio: s.barPercentage,
                                        start: A
                                    }
                                }(s, o, u, L) : function _o(n, a, s, o) {
                                    const c = s.barThickness;
                                    let u, f;
                                    return zt(c) ? (u = a.min * s.categoryPercentage, f = s.barPercentage) : (u = c * o, f = 1), {
                                        chunk: u / o,
                                        ratio: f,
                                        start: a.pixels[n] - u / 2
                                    }
                                }(s, o, u, L),
                                z = this._getStackIndex(this.index, this._cachedMeta.stack, f ? s : void 0);
                            y = O.start + O.chunk * z + O.chunk / 2, A = Math.min(m, O.chunk * O.ratio)
                        } else y = c.getPixelForValue(this.getParsed(s)[c.axis], s), A = Math.min(m, o.min * o.ratio);
                        return {
                            base: y - A / 2,
                            head: y + A / 2,
                            center: y,
                            size: A
                        }
                    }
                    draw() {
                        const s = this._cachedMeta,
                            o = s.vScale,
                            c = s.data,
                            u = c.length;
                        let f = 0;
                        for (; f < u; ++f) null !== this.getParsed(f)[o.axis] && c[f].draw(this._ctx)
                    }
                })(),
                Xo = (() => class n extends ki {
                    static id = "bubble";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "point",
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "borderWidth", "radius"]
                            }
                        }
                    };
                    static overrides = {
                        scales: {
                            x: {
                                type: "linear"
                            },
                            y: {
                                type: "linear"
                            }
                        }
                    };
                    initialize() {
                        this.enableOptionSharing = !0, super.initialize()
                    }
                    parsePrimitiveData(s, o, c, u) {
                        const f = super.parsePrimitiveData(s, o, c, u);
                        for (let m = 0; m < f.length; m++) f[m]._custom = this.resolveDataElementOptions(m + c).radius;
                        return f
                    }
                    parseArrayData(s, o, c, u) {
                        const f = super.parseArrayData(s, o, c, u);
                        for (let m = 0; m < f.length; m++) f[m]._custom = Ct(o[c + m][2], this.resolveDataElementOptions(m + c).radius);
                        return f
                    }
                    parseObjectData(s, o, c, u) {
                        const f = super.parseObjectData(s, o, c, u);
                        for (let m = 0; m < f.length; m++) {
                            const y = o[c + m];
                            f[m]._custom = Ct(y && y.r && +y.r, this.resolveDataElementOptions(m + c).radius)
                        }
                        return f
                    }
                    getMaxOverflow() {
                        const s = this._cachedMeta.data;
                        let o = 0;
                        for (let c = s.length - 1; c >= 0; --c) o = Math.max(o, s[c].size(this.resolveDataElementOptions(c)) / 2);
                        return o > 0 && o
                    }
                    getLabelAndValue(s) {
                        const o = this._cachedMeta,
                            c = this.chart.data.labels || [],
                            {
                                xScale: u,
                                yScale: f
                            } = o,
                            m = this.getParsed(s),
                            y = u.getLabelForValue(m.x),
                            A = f.getLabelForValue(m.y),
                            L = m._custom;
                        return {
                            label: c[s] || "",
                            value: "(" + y + ", " + A + (L ? ", " + L : "") + ")"
                        }
                    }
                    update(s) {
                        const o = this._cachedMeta.data;
                        this.updateElements(o, 0, o.length, s)
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            {
                                iScale: m,
                                vScale: y
                            } = this._cachedMeta,
                            {
                                sharedOptions: A,
                                includeOptions: L
                            } = this._getSharedOptions(o, u),
                            O = m.axis,
                            z = y.axis;
                        for (let B = o; B < o + c; B++) {
                            const V = s[B],
                                G = !f && this.getParsed(B),
                                Z = {},
                                tt = Z[O] = f ? m.getPixelForDecimal(.5) : m.getPixelForValue(G[O]),
                                J = Z[z] = f ? y.getBasePixel() : y.getPixelForValue(G[z]);
                            Z.skip = isNaN(tt) || isNaN(J), L && (Z.options = A || this.resolveDataElementOptions(B, V.active ? "active" : u), f && (Z.options.radius = 0)), this.updateElement(V, B, Z, u)
                        }
                    }
                    resolveDataElementOptions(s, o) {
                        const c = this.getParsed(s);
                        let u = super.resolveDataElementOptions(s, o);
                        u.$shared && (u = Object.assign({}, u, {
                            $shared: !1
                        }));
                        const f = u.radius;
                        return "active" !== o && (u.radius = 0), u.radius += Ct(c && c._custom, f), u
                    }
                })(),
                $s = (() => class n extends ki {
                    static id = "doughnut";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "arc",
                        animation: {
                            animateRotate: !0,
                            animateScale: !1
                        },
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
                            }
                        },
                        cutout: "50%",
                        rotation: 0,
                        circumference: 360,
                        radius: "100%",
                        spacing: 0,
                        indexAxis: "r"
                    };
                    static descriptors = {
                        _scriptable: s => "spacing" !== s,
                        _indexable: s => "spacing" !== s && !s.startsWith("borderDash") && !s.startsWith("hoverBorderDash")
                    };
                    static overrides = {
                        aspectRatio: 1,
                        plugins: {
                            legend: {
                                labels: {
                                    generateLabels(s) {
                                        const o = s.data;
                                        if (o.labels.length && o.datasets.length) {
                                            const {
                                                labels: {
                                                    pointStyle: c,
                                                    color: u
                                                }
                                            } = s.legend.options;
                                            return o.labels.map((f, m) => {
                                                const A = s.getDatasetMeta(0).controller.getStyle(m);
                                                return {
                                                    text: f,
                                                    fillStyle: A.backgroundColor,
                                                    strokeStyle: A.borderColor,
                                                    fontColor: u,
                                                    lineWidth: A.borderWidth,
                                                    pointStyle: c,
                                                    hidden: !s.getDataVisibility(m),
                                                    index: m
                                                }
                                            })
                                        }
                                        return []
                                    }
                                },
                                onClick(s, o, c) {
                                    c.chart.toggleDataVisibility(o.index), c.chart.update()
                                }
                            }
                        }
                    };
                    constructor(s, o) {
                        super(s, o), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
                    }
                    linkScales() {}
                    parse(s, o) {
                        const c = this.getDataset().data,
                            u = this._cachedMeta;
                        if (!1 === this._parsing) u._parsed = c;
                        else {
                            let m, y, f = A => +c[A];
                            if (Tt(c[s])) {
                                const {
                                    key: A = "value"
                                } = this._parsing;
                                f = L => +Fe(c[L], A)
                            }
                            for (m = s, y = s + o; m < y; ++m) u._parsed[m] = f(m)
                        }
                    }
                    _getRotation() {
                        return Gt(this.options.rotation - 90)
                    }
                    _getCircumference() {
                        return Gt(this.options.circumference)
                    }
                    _getRotationExtents() {
                        let s = W,
                            o = -W;
                        for (let c = 0; c < this.chart.data.datasets.length; ++c)
                            if (this.chart.isDatasetVisible(c) && this.chart.getDatasetMeta(c).type === this._type) {
                                const u = this.chart.getDatasetMeta(c).controller,
                                    f = u._getRotation(),
                                    m = u._getCircumference();
                                s = Math.min(s, f), o = Math.max(o, f + m)
                            }
                        return {
                            rotation: s,
                            circumference: o - s
                        }
                    }
                    update(s) {
                        const o = this.chart,
                            {
                                chartArea: c
                            } = o,
                            u = this._cachedMeta,
                            f = u.data,
                            m = this.getMaxBorderWidth() + this.getMaxOffset(f) + this.options.spacing,
                            y = Math.max((Math.min(c.width, c.height) - m) / 2, 0),
                            A = Math.min(((n, a) => "string" == typeof n && n.endsWith("%") ? parseFloat(n) / 100 : +n / a)(this.options.cutout, y), 1),
                            L = this._getRingWeight(this.index),
                            {
                                circumference: O,
                                rotation: z
                            } = this._getRotationExtents(),
                            {
                                ratioX: B,
                                ratioY: V,
                                offsetX: G,
                                offsetY: Z
                            } = function No(n, a, s) {
                                let o = 1,
                                    c = 1,
                                    u = 0,
                                    f = 0;
                                if (a < W) {
                                    const m = n,
                                        y = m + a,
                                        A = Math.cos(m),
                                        L = Math.sin(m),
                                        O = Math.cos(y),
                                        z = Math.sin(y),
                                        B = (dt, pt, nt) => Lt(dt, m, y, !0) ? 1 : Math.max(pt, pt * s, nt, nt * s),
                                        V = (dt, pt, nt) => Lt(dt, m, y, !0) ? -1 : Math.min(pt, pt * s, nt, nt * s),
                                        G = B(0, A, O),
                                        Z = B(Y, L, z),
                                        tt = V(jt, A, O),
                                        J = V(jt + Y, L, z);
                                    o = (G - tt) / 2, c = (Z - J) / 2, u = -(G + tt) / 2, f = -(Z + J) / 2
                                }
                                return {
                                    ratioX: o,
                                    ratioY: c,
                                    offsetX: u,
                                    offsetY: f
                                }
                            }(z, O, A),
                            dt = Math.max(Math.min((c.width - m) / B, (c.height - m) / V) / 2, 0),
                            pt = Wi(this.options.radius, dt),
                            ft = (pt - Math.max(pt * A, 0)) / this._getVisibleDatasetWeightTotal();
                        this.offsetX = G * pt, this.offsetY = Z * pt, u.total = this.calculateTotal(), this.outerRadius = pt - ft * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - ft * L, 0), this.updateElements(f, 0, f.length, s)
                    }
                    _circumference(s, o) {
                        const c = this.options,
                            u = this._cachedMeta,
                            f = this._getCircumference();
                        return o && c.animation.animateRotate || !this.chart.getDataVisibility(s) || null === u._parsed[s] || u.data[s].hidden ? 0 : this.calculateCircumference(u._parsed[s] * f / W)
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            m = this.chart,
                            y = m.chartArea,
                            O = (y.left + y.right) / 2,
                            z = (y.top + y.bottom) / 2,
                            B = f && m.options.animation.animateScale,
                            V = B ? 0 : this.innerRadius,
                            G = B ? 0 : this.outerRadius,
                            {
                                sharedOptions: Z,
                                includeOptions: tt
                            } = this._getSharedOptions(o, u);
                        let dt, J = this._getRotation();
                        for (dt = 0; dt < o; ++dt) J += this._circumference(dt, f);
                        for (dt = o; dt < o + c; ++dt) {
                            const pt = this._circumference(dt, f),
                                nt = s[dt],
                                ft = {
                                    x: O + this.offsetX,
                                    y: z + this.offsetY,
                                    startAngle: J,
                                    endAngle: J + pt,
                                    circumference: pt,
                                    outerRadius: G,
                                    innerRadius: V
                                };
                            tt && (ft.options = Z || this.resolveDataElementOptions(dt, nt.active ? "active" : u)), J += pt, this.updateElement(nt, dt, ft, u)
                        }
                    }
                    calculateTotal() {
                        const s = this._cachedMeta,
                            o = s.data;
                        let u, c = 0;
                        for (u = 0; u < o.length; u++) {
                            const f = s._parsed[u];
                            null !== f && !isNaN(f) && this.chart.getDataVisibility(u) && !o[u].hidden && (c += Math.abs(f))
                        }
                        return c
                    }
                    calculateCircumference(s) {
                        const o = this._cachedMeta.total;
                        return o > 0 && !isNaN(s) ? W * (Math.abs(s) / o) : 0
                    }
                    getLabelAndValue(s) {
                        const c = this.chart,
                            u = c.data.labels || [],
                            f = Pt(this._cachedMeta._parsed[s], c.options.locale);
                        return {
                            label: u[s] || "",
                            value: f
                        }
                    }
                    getMaxBorderWidth(s) {
                        let o = 0;
                        const c = this.chart;
                        let u, f, m, y, A;
                        if (!s)
                            for (u = 0, f = c.data.datasets.length; u < f; ++u)
                                if (c.isDatasetVisible(u)) {
                                    m = c.getDatasetMeta(u), s = m.data, y = m.controller;
                                    break
                                }
                        if (!s) return 0;
                        for (u = 0, f = s.length; u < f; ++u) A = y.resolveDataElementOptions(u), "inner" !== A.borderAlign && (o = Math.max(o, A.borderWidth || 0, A.hoverBorderWidth || 0));
                        return o
                    }
                    getMaxOffset(s) {
                        let o = 0;
                        for (let c = 0, u = s.length; c < u; ++c) {
                            const f = this.resolveDataElementOptions(c);
                            o = Math.max(o, f.offset || 0, f.hoverOffset || 0)
                        }
                        return o
                    }
                    _getRingWeightOffset(s) {
                        let o = 0;
                        for (let c = 0; c < s; ++c) this.chart.isDatasetVisible(c) && (o += this._getRingWeight(c));
                        return o
                    }
                    _getRingWeight(s) {
                        return Math.max(Ct(this.chart.data.datasets[s].weight, 1), 0)
                    }
                    _getVisibleDatasetWeightTotal() {
                        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
                    }
                })(),
                Bo = (() => class n extends ki {
                    static id = "line";
                    static defaults = {
                        datasetElementType: "line",
                        dataElementType: "point",
                        showLine: !0,
                        spanGaps: !1
                    };
                    static overrides = {
                        scales: {
                            _index_: {
                                type: "category"
                            },
                            _value_: {
                                type: "linear"
                            }
                        }
                    };
                    initialize() {
                        this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
                    }
                    update(s) {
                        const o = this._cachedMeta,
                            {
                                dataset: c,
                                data: u = [],
                                _dataset: f
                            } = o,
                            m = this.chart._animationsDisabled;
                        let {
                            start: y,
                            count: A
                        } = I(o, u, m);
                        this._drawStart = y, this._drawCount = A, R(o) && (y = 0, A = u.length), c._chart = this.chart, c._datasetIndex = this.index, c._decimated = !!f._decimated, c.points = u;
                        const L = this.resolveDatasetElementOptions(s);
                        this.options.showLine || (L.borderWidth = 0), L.segment = this.options.segment, this.updateElement(c, void 0, {
                            animated: !m,
                            options: L
                        }, s), this.updateElements(u, y, A, s)
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            {
                                iScale: m,
                                vScale: y,
                                _stacked: A,
                                _dataset: L
                            } = this._cachedMeta,
                            {
                                sharedOptions: O,
                                includeOptions: z
                            } = this._getSharedOptions(o, u),
                            B = m.axis,
                            V = y.axis,
                            {
                                spanGaps: G,
                                segment: Z
                            } = this.options,
                            tt = st(G) ? G : Number.POSITIVE_INFINITY,
                            J = this.chart._animationsDisabled || f || "none" === u,
                            dt = o + c,
                            pt = s.length;
                        let nt = o > 0 && this.getParsed(o - 1);
                        for (let ft = 0; ft < pt; ++ft) {
                            const At = s[ft],
                                vt = J ? At : {};
                            if (ft < o || ft >= dt) {
                                vt.skip = !0;
                                continue
                            }
                            const St = this.getParsed(ft),
                                It = zt(St[V]),
                                Ot = vt[B] = m.getPixelForValue(St[B], ft),
                                Ht = vt[V] = f || It ? y.getBasePixel() : y.getPixelForValue(A ? this.applyStack(y, St, A) : St[V], ft);
                            vt.skip = isNaN(Ot) || isNaN(Ht) || It, vt.stop = ft > 0 && Math.abs(St[B] - nt[B]) > tt, Z && (vt.parsed = St, vt.raw = L.data[ft]), z && (vt.options = O || this.resolveDataElementOptions(ft, At.active ? "active" : u)), J || this.updateElement(At, ft, vt, u), nt = St
                        }
                    }
                    getMaxOverflow() {
                        const s = this._cachedMeta,
                            o = s.dataset,
                            c = o.options && o.options.borderWidth || 0,
                            u = s.data || [];
                        if (!u.length) return c;
                        const f = u[0].size(this.resolveDataElementOptions(0)),
                            m = u[u.length - 1].size(this.resolveDataElementOptions(u.length - 1));
                        return Math.max(c, f, m) / 2
                    }
                    draw() {
                        const s = this._cachedMeta;
                        s.dataset.updateControlPoints(this.chart.chartArea, s.iScale.axis), super.draw()
                    }
                })(),
                Ka = (() => class n extends ki {
                    static id = "polarArea";
                    static defaults = {
                        dataElementType: "arc",
                        animation: {
                            animateRotate: !0,
                            animateScale: !0
                        },
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
                            }
                        },
                        indexAxis: "r",
                        startAngle: 0
                    };
                    static overrides = {
                        aspectRatio: 1,
                        plugins: {
                            legend: {
                                labels: {
                                    generateLabels(s) {
                                        const o = s.data;
                                        if (o.labels.length && o.datasets.length) {
                                            const {
                                                labels: {
                                                    pointStyle: c,
                                                    color: u
                                                }
                                            } = s.legend.options;
                                            return o.labels.map((f, m) => {
                                                const A = s.getDatasetMeta(0).controller.getStyle(m);
                                                return {
                                                    text: f,
                                                    fillStyle: A.backgroundColor,
                                                    strokeStyle: A.borderColor,
                                                    fontColor: u,
                                                    lineWidth: A.borderWidth,
                                                    pointStyle: c,
                                                    hidden: !s.getDataVisibility(m),
                                                    index: m
                                                }
                                            })
                                        }
                                        return []
                                    }
                                },
                                onClick(s, o, c) {
                                    c.chart.toggleDataVisibility(o.index), c.chart.update()
                                }
                            }
                        },
                        scales: {
                            r: {
                                type: "radialLinear",
                                angleLines: {
                                    display: !1
                                },
                                beginAtZero: !0,
                                grid: {
                                    circular: !0
                                },
                                pointLabels: {
                                    display: !1
                                },
                                startAngle: 0
                            }
                        }
                    };
                    constructor(s, o) {
                        super(s, o), this.innerRadius = void 0, this.outerRadius = void 0
                    }
                    getLabelAndValue(s) {
                        const c = this.chart,
                            u = c.data.labels || [],
                            f = Pt(this._cachedMeta._parsed[s].r, c.options.locale);
                        return {
                            label: u[s] || "",
                            value: f
                        }
                    }
                    parseObjectData(s, o, c, u) {
                        return Ca.bind(this)(s, o, c, u)
                    }
                    update(s) {
                        const o = this._cachedMeta.data;
                        this._updateRadius(), this.updateElements(o, 0, o.length, s)
                    }
                    getMinMax() {
                        const o = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        };
                        return this._cachedMeta.data.forEach((c, u) => {
                            const f = this.getParsed(u).r;
                            !isNaN(f) && this.chart.getDataVisibility(u) && (f < o.min && (o.min = f), f > o.max && (o.max = f))
                        }), o
                    }
                    _updateRadius() {
                        const s = this.chart,
                            o = s.chartArea,
                            c = s.options,
                            u = Math.min(o.right - o.left, o.bottom - o.top),
                            f = Math.max(u / 2, 0),
                            y = (f - Math.max(c.cutoutPercentage ? f / 100 * c.cutoutPercentage : 1, 0)) / s.getVisibleDatasetCount();
                        this.outerRadius = f - y * this.index, this.innerRadius = this.outerRadius - y
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            m = this.chart,
                            A = m.options.animation,
                            L = this._cachedMeta.rScale,
                            O = L.xCenter,
                            z = L.yCenter,
                            B = L.getIndexAngle(0) - .5 * jt;
                        let G, V = B;
                        const Z = 360 / this.countVisibleElements();
                        for (G = 0; G < o; ++G) V += this._computeAngle(G, u, Z);
                        for (G = o; G < o + c; G++) {
                            const tt = s[G];
                            let J = V,
                                dt = V + this._computeAngle(G, u, Z),
                                pt = m.getDataVisibility(G) ? L.getDistanceFromCenterForValue(this.getParsed(G).r) : 0;
                            V = dt, f && (A.animateScale && (pt = 0), A.animateRotate && (J = dt = B));
                            const nt = {
                                x: O,
                                y: z,
                                innerRadius: 0,
                                outerRadius: pt,
                                startAngle: J,
                                endAngle: dt,
                                options: this.resolveDataElementOptions(G, tt.active ? "active" : u)
                            };
                            this.updateElement(tt, G, nt, u)
                        }
                    }
                    countVisibleElements() {
                        let o = 0;
                        return this._cachedMeta.data.forEach((c, u) => {
                            !isNaN(this.getParsed(u).r) && this.chart.getDataVisibility(u) && o++
                        }), o
                    }
                    _computeAngle(s, o, c) {
                        return this.chart.getDataVisibility(s) ? Gt(this.resolveDataElementOptions(s, o).angle || c) : 0
                    }
                })();
            var Ho = Object.freeze({
                __proto__: null,
                BarController: Fo,
                BubbleController: Xo,
                DoughnutController: $s,
                LineController: Bo,
                PieController: (() => class n extends $s {
                    static id = "pie";
                    static defaults = {
                        cutout: 0,
                        rotation: 0,
                        circumference: 360,
                        radius: "100%"
                    }
                })(),
                PolarAreaController: Ka,
                RadarController: (() => class n extends ki {
                    static id = "radar";
                    static defaults = {
                        datasetElementType: "line",
                        dataElementType: "point",
                        indexAxis: "r",
                        showLine: !0,
                        elements: {
                            line: {
                                fill: "start"
                            }
                        }
                    };
                    static overrides = {
                        aspectRatio: 1,
                        scales: {
                            r: {
                                type: "radialLinear"
                            }
                        }
                    };
                    getLabelAndValue(s) {
                        const o = this._cachedMeta.vScale,
                            c = this.getParsed(s);
                        return {
                            label: o.getLabels()[s],
                            value: "" + o.getLabelForValue(c[o.axis])
                        }
                    }
                    parseObjectData(s, o, c, u) {
                        return Ca.bind(this)(s, o, c, u)
                    }
                    update(s) {
                        const o = this._cachedMeta,
                            c = o.dataset,
                            u = o.data || [],
                            f = o.iScale.getLabels();
                        if (c.points = u, "resize" !== s) {
                            const m = this.resolveDatasetElementOptions(s);
                            this.options.showLine || (m.borderWidth = 0), this.updateElement(c, void 0, {
                                _loop: !0,
                                _fullLoop: f.length === u.length,
                                options: m
                            }, s)
                        }
                        this.updateElements(u, 0, u.length, s)
                    }
                    updateElements(s, o, c, u) {
                        const f = this._cachedMeta.rScale,
                            m = "reset" === u;
                        for (let y = o; y < o + c; y++) {
                            const A = s[y],
                                L = this.resolveDataElementOptions(y, A.active ? "active" : u),
                                O = f.getPointPositionForValue(y, this.getParsed(y).r),
                                z = m ? f.xCenter : O.x,
                                B = m ? f.yCenter : O.y,
                                V = {
                                    x: z,
                                    y: B,
                                    angle: O.angle,
                                    skip: isNaN(z) || isNaN(B),
                                    options: L
                                };
                            this.updateElement(A, y, V, u)
                        }
                    }
                })(),
                ScatterController: (() => class n extends ki {
                    static id = "scatter";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "point",
                        showLine: !1,
                        fill: !1
                    };
                    static overrides = {
                        interaction: {
                            mode: "point"
                        },
                        scales: {
                            x: {
                                type: "linear"
                            },
                            y: {
                                type: "linear"
                            }
                        }
                    };
                    getLabelAndValue(s) {
                        const o = this._cachedMeta,
                            c = this.chart.data.labels || [],
                            {
                                xScale: u,
                                yScale: f
                            } = o,
                            m = this.getParsed(s),
                            y = u.getLabelForValue(m.x),
                            A = f.getLabelForValue(m.y);
                        return {
                            label: c[s] || "",
                            value: "(" + y + ", " + A + ")"
                        }
                    }
                    update(s) {
                        const o = this._cachedMeta,
                            {
                                data: c = []
                            } = o,
                            u = this.chart._animationsDisabled;
                        let {
                            start: f,
                            count: m
                        } = I(o, c, u);
                        if (this._drawStart = f, this._drawCount = m, R(o) && (f = 0, m = c.length), this.options.showLine) {
                            this.datasetElementType || this.addElements();
                            const {
                                dataset: y,
                                _dataset: A
                            } = o;
                            y._chart = this.chart, y._datasetIndex = this.index, y._decimated = !!A._decimated, y.points = c;
                            const L = this.resolveDatasetElementOptions(s);
                            L.segment = this.options.segment, this.updateElement(y, void 0, {
                                animated: !u,
                                options: L
                            }, s)
                        } else this.datasetElementType && (delete o.dataset, this.datasetElementType = !1);
                        this.updateElements(c, f, m, s)
                    }
                    addElements() {
                        const {
                            showLine: s
                        } = this.options;
                        !this.datasetElementType && s && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements()
                    }
                    updateElements(s, o, c, u) {
                        const f = "reset" === u,
                            {
                                iScale: m,
                                vScale: y,
                                _stacked: A,
                                _dataset: L
                            } = this._cachedMeta,
                            O = this.resolveDataElementOptions(o, u),
                            z = this.getSharedOptions(O),
                            B = this.includeOptions(u, z),
                            V = m.axis,
                            G = y.axis,
                            {
                                spanGaps: Z,
                                segment: tt
                            } = this.options,
                            J = st(Z) ? Z : Number.POSITIVE_INFINITY,
                            dt = this.chart._animationsDisabled || f || "none" === u;
                        let pt = o > 0 && this.getParsed(o - 1);
                        for (let nt = o; nt < o + c; ++nt) {
                            const ft = s[nt],
                                At = this.getParsed(nt),
                                vt = dt ? ft : {},
                                St = zt(At[G]),
                                It = vt[V] = m.getPixelForValue(At[V], nt),
                                Ot = vt[G] = f || St ? y.getBasePixel() : y.getPixelForValue(A ? this.applyStack(y, At, A) : At[G], nt);
                            vt.skip = isNaN(It) || isNaN(Ot) || St, vt.stop = nt > 0 && Math.abs(At[V] - pt[V]) > J, tt && (vt.parsed = At, vt.raw = L.data[nt]), B && (vt.options = z || this.resolveDataElementOptions(nt, ft.active ? "active" : u)), dt || this.updateElement(ft, nt, vt, u), pt = At
                        }
                        this.updateSharedOptions(z, u, O)
                    }
                    getMaxOverflow() {
                        const s = this._cachedMeta,
                            o = s.data || [];
                        if (!this.options.showLine) {
                            let y = 0;
                            for (let A = o.length - 1; A >= 0; --A) y = Math.max(y, o[A].size(this.resolveDataElementOptions(A)) / 2);
                            return y > 0 && y
                        }
                        const c = s.dataset,
                            u = c.options && c.options.borderWidth || 0;
                        if (!o.length) return u;
                        const f = o[0].size(this.resolveDataElementOptions(0)),
                            m = o[o.length - 1].size(this.resolveDataElementOptions(o.length - 1));
                        return Math.max(u, f, m) / 2
                    }
                })()
            });

            function Ri() {
                throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
            }
            class qs {
                static override(a) {
                    Object.assign(qs.prototype, a)
                }
                options;
                constructor(a) {
                    this.options = a || {}
                }
                init() {}
                formats() {
                    return Ri()
                }
                parse() {
                    return Ri()
                }
                format() {
                    return Ri()
                }
                add() {
                    return Ri()
                }
                diff() {
                    return Ri()
                }
                startOf() {
                    return Ri()
                }
                endOf() {
                    return Ri()
                }
            }
            var Yo__date = qs;

            function Wo(n, a, s, o) {
                const {
                    controller: c,
                    data: u,
                    _sorted: f
                } = n, m = c._cachedMeta.iScale;
                if (m && a === m.axis && "r" !== a && f && u.length) {
                    const y = m._reversePixels ? r : i;
                    if (!o) return y(u, a, s);
                    if (c._sharedOptions) {
                        const A = u[0],
                            L = "function" == typeof A.getRange && A.getRange(a);
                        if (L) {
                            const O = y(u, a, s - L),
                                z = y(u, a, s + L);
                            return {
                                lo: O.lo,
                                hi: z.hi
                            }
                        }
                    }
                }
                return {
                    lo: 0,
                    hi: u.length - 1
                }
            }

            function ss(n, a, s, o, c) {
                const u = n.getSortedVisibleDatasetMetas(),
                    f = s[a];
                for (let m = 0, y = u.length; m < y; ++m) {
                    const {
                        index: A,
                        data: L
                    } = u[m], {
                        lo: O,
                        hi: z
                    } = Wo(u[m], a, f, c);
                    for (let B = O; B <= z; ++B) {
                        const V = L[B];
                        V.skip || o(V, A, B)
                    }
                }
            }

            function Ks(n, a, s, o, c) {
                const u = [];
                return !c && !n.isPointInArea(a) || ss(n, s, a, function(m, y, A) {
                    !c && !ai(m, n.chartArea, 0) || m.inRange(a.x, a.y, o) && u.push({
                        element: m,
                        datasetIndex: y,
                        index: A
                    })
                }, !0), u
            }

            function Qs(n, a, s, o, c, u) {
                return u || n.isPointInArea(a) ? "r" !== s || o ? function jo(n, a, s, o, c, u) {
                    let f = [];
                    const m = function Vo(n) {
                        const a = -1 !== n.indexOf("x"),
                            s = -1 !== n.indexOf("y");
                        return function(o, c) {
                            const u = a ? Math.abs(o.x - c.x) : 0,
                                f = s ? Math.abs(o.y - c.y) : 0;
                            return Math.sqrt(Math.pow(u, 2) + Math.pow(f, 2))
                        }
                    }(s);
                    let y = Number.POSITIVE_INFINITY;
                    return ss(n, s, a, function A(L, O, z) {
                        const B = L.inRange(a.x, a.y, c);
                        if (o && !B) return;
                        const V = L.getCenterPoint(c);
                        if (!u && !n.isPointInArea(V) && !B) return;
                        const Z = m(a, V);
                        Z < y ? (f = [{
                            element: L,
                            datasetIndex: O,
                            index: z
                        }], y = Z) : Z === y && f.push({
                            element: L,
                            datasetIndex: O,
                            index: z
                        })
                    }), f
                }(n, a, s, o, c, u) : function Go(n, a, s, o) {
                    let c = [];
                    return ss(n, s, a, function u(f, m, y) {
                        const {
                            startAngle: A,
                            endAngle: L
                        } = f.getProps(["startAngle", "endAngle"], o), {
                            angle: O
                        } = Te(f, {
                            x: a.x,
                            y: a.y
                        });
                        Lt(O, A, L) && c.push({
                            element: f,
                            datasetIndex: m,
                            index: y
                        })
                    }), c
                }(n, a, s, c) : []
            }

            function Qa(n, a, s, o, c) {
                const u = [],
                    f = "x" === s ? "inXRange" : "inYRange";
                let m = !1;
                return ss(n, s, a, (y, A, L) => {
                    y[f](a[s], c) && (u.push({
                        element: y,
                        datasetIndex: A,
                        index: L
                    }), m = m || y.inRange(a.x, a.y, c))
                }), o && !m ? [] : u
            }
            var Uo = {
                evaluateInteractionItems: ss,
                modes: {
                    index(n, a, s, o) {
                        const c = Ii(a, n),
                            u = s.axis || "x",
                            f = s.includeInvisible || !1,
                            m = s.intersect ? Ks(n, c, u, o, f) : Qs(n, c, u, !1, o, f),
                            y = [];
                        return m.length ? (n.getSortedVisibleDatasetMetas().forEach(A => {
                            const L = m[0].index,
                                O = A.data[L];
                            O && !O.skip && y.push({
                                element: O,
                                datasetIndex: A.index,
                                index: L
                            })
                        }), y) : []
                    },
                    dataset(n, a, s, o) {
                        const c = Ii(a, n),
                            u = s.axis || "xy",
                            f = s.includeInvisible || !1;
                        let m = s.intersect ? Ks(n, c, u, o, f) : Qs(n, c, u, !1, o, f);
                        if (m.length > 0) {
                            const y = m[0].datasetIndex,
                                A = n.getDatasetMeta(y).data;
                            m = [];
                            for (let L = 0; L < A.length; ++L) m.push({
                                element: A[L],
                                datasetIndex: y,
                                index: L
                            })
                        }
                        return m
                    },
                    point: (n, a, s, o) => Ks(n, Ii(a, n), s.axis || "xy", o, s.includeInvisible || !1),
                    nearest: (n, a, s, o) => Qs(n, Ii(a, n), s.axis || "xy", s.intersect, o, s.includeInvisible || !1),
                    x: (n, a, s, o) => Qa(n, Ii(a, n), "x", s.intersect, o),
                    y: (n, a, s, o) => Qa(n, Ii(a, n), "y", s.intersect, o)
                }
            };
            const Ja = ["left", "top", "right", "bottom"];

            function as(n, a) {
                return n.filter(s => s.pos === a)
            }

            function tn(n, a) {
                return n.filter(s => -1 === Ja.indexOf(s.pos) && s.box.axis === a)
            }

            function ns(n, a) {
                return n.sort((s, o) => {
                    const c = a ? o : s,
                        u = a ? s : o;
                    return c.weight === u.weight ? c.index - u.index : c.weight - u.weight
                })
            }

            function en(n, a, s, o) {
                return Math.max(n[s], a[s]) + Math.max(n[o], a[o])
            }

            function sn(n, a) {
                n.top = Math.max(n.top, a.top), n.left = Math.max(n.left, a.left), n.bottom = Math.max(n.bottom, a.bottom), n.right = Math.max(n.right, a.right)
            }

            function Qo(n, a, s, o) {
                const {
                    pos: c,
                    box: u
                } = s, f = n.maxPadding;
                if (!Tt(c)) {
                    s.size && (n[c] -= s.size);
                    const O = o[s.stack] || {
                        size: 0,
                        count: 1
                    };
                    O.size = Math.max(O.size, s.horizontal ? u.height : u.width), s.size = O.size / O.count, n[c] += s.size
                }
                u.getPadding && sn(f, u.getPadding());
                const m = Math.max(0, a.outerWidth - en(f, n, "left", "right")),
                    y = Math.max(0, a.outerHeight - en(f, n, "top", "bottom")),
                    A = m !== n.w,
                    L = y !== n.h;
                return n.w = m, n.h = y, s.horizontal ? {
                    same: A,
                    other: L
                } : {
                    same: L,
                    other: A
                }
            }

            function tl(n, a) {
                const s = a.maxPadding;
                return function o(c) {
                    const u = {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    };
                    return c.forEach(f => {
                        u[f] = Math.max(a[f], s[f])
                    }), u
                }(n ? ["left", "right"] : ["top", "bottom"])
            }

            function rs(n, a, s, o) {
                const c = [];
                let u, f, m, y, A, L;
                for (u = 0, f = n.length, A = 0; u < f; ++u) {
                    m = n[u], y = m.box, y.update(m.width || a.w, m.height || a.h, tl(m.horizontal, a));
                    const {
                        same: O,
                        other: z
                    } = Qo(a, s, m, o);
                    A |= O && c.length, L = L || z, y.fullSize || c.push(m)
                }
                return A && rs(c, a, s, o) || L
            }

            function ks(n, a, s, o, c) {
                n.top = s, n.left = a, n.right = a + o, n.bottom = s + c, n.width = o, n.height = c
            }

            function an(n, a, s, o) {
                const c = s.padding;
                let {
                    x: u,
                    y: f
                } = a;
                for (const m of n) {
                    const y = m.box,
                        A = o[m.stack] || {
                            count: 1,
                            placed: 0,
                            weight: 1
                        },
                        L = m.stackWeight / A.weight || 1;
                    if (m.horizontal) {
                        const O = a.w * L,
                            z = A.size || y.height;
                        Qe(A.start) && (f = A.start), y.fullSize ? ks(y, c.left, f, s.outerWidth - c.right - c.left, z) : ks(y, a.left + A.placed, f, O, z), A.start = f, A.placed += O, f = y.bottom
                    } else {
                        const O = a.h * L,
                            z = A.size || y.width;
                        Qe(A.start) && (u = A.start), y.fullSize ? ks(y, u, c.top, z, s.outerHeight - c.bottom - c.top) : ks(y, u, a.top + A.placed, z, O), A.start = u, A.placed += O, u = y.right
                    }
                }
                a.x = u, a.y = f
            }
            var we = {
                addBox(n, a) {
                    n.boxes || (n.boxes = []), a.fullSize = a.fullSize || !1, a.position = a.position || "top", a.weight = a.weight || 0, a._layers = a._layers || function() {
                        return [{
                            z: 0,
                            draw(s) {
                                a.draw(s)
                            }
                        }]
                    }, n.boxes.push(a)
                },
                removeBox(n, a) {
                    const s = n.boxes ? n.boxes.indexOf(a) : -1; - 1 !== s && n.boxes.splice(s, 1)
                },
                configure(n, a, s) {
                    a.fullSize = s.fullSize, a.position = s.position, a.weight = s.weight
                },
                update(n, a, s, o) {
                    if (!n) return;
                    const c = ye(n.options.layout.padding),
                        u = Math.max(a - c.width, 0),
                        f = Math.max(s - c.height, 0),
                        m = function Ko(n) {
                            const a = function Zo(n) {
                                    const a = [];
                                    let s, o, c, u, f, m;
                                    for (s = 0, o = (n || []).length; s < o; ++s) c = n[s], ({
                                        position: u,
                                        options: {
                                            stack: f,
                                            stackWeight: m = 1
                                        }
                                    } = c), a.push({
                                        index: s,
                                        box: c,
                                        pos: u,
                                        horizontal: c.isHorizontal(),
                                        weight: c.weight,
                                        stack: f && u + f,
                                        stackWeight: m
                                    });
                                    return a
                                }(n),
                                s = ns(a.filter(A => A.box.fullSize), !0),
                                o = ns(as(a, "left"), !0),
                                c = ns(as(a, "right")),
                                u = ns(as(a, "top"), !0),
                                f = ns(as(a, "bottom")),
                                m = tn(a, "x"),
                                y = tn(a, "y");
                            return {
                                fullSize: s,
                                leftAndTop: o.concat(u),
                                rightAndBottom: c.concat(y).concat(f).concat(m),
                                chartArea: as(a, "chartArea"),
                                vertical: o.concat(c).concat(y),
                                horizontal: u.concat(f).concat(m)
                            }
                        }(n.boxes),
                        y = m.vertical,
                        A = m.horizontal;
                    Yt(n.boxes, G => {
                        "function" == typeof G.beforeLayout && G.beforeLayout()
                    });
                    const L = y.reduce((G, Z) => Z.box.options && !1 === Z.box.options.display ? G : G + 1, 0) || 1,
                        O = Object.freeze({
                            outerWidth: a,
                            outerHeight: s,
                            padding: c,
                            availableWidth: u,
                            availableHeight: f,
                            vBoxMaxWidth: u / 2 / L,
                            hBoxMaxHeight: f / 2
                        }),
                        z = Object.assign({}, c);
                    sn(z, ye(o));
                    const B = Object.assign({
                            maxPadding: z,
                            w: u,
                            h: f,
                            x: c.left,
                            y: c.top
                        }, c),
                        V = function qo(n, a) {
                            const s = function $o(n) {
                                    const a = {};
                                    for (const s of n) {
                                        const {
                                            stack: o,
                                            pos: c,
                                            stackWeight: u
                                        } = s;
                                        if (!o || !Ja.includes(c)) continue;
                                        const f = a[o] || (a[o] = {
                                            count: 0,
                                            placed: 0,
                                            weight: 0,
                                            size: 0
                                        });
                                        f.count++, f.weight += u
                                    }
                                    return a
                                }(n),
                                {
                                    vBoxMaxWidth: o,
                                    hBoxMaxHeight: c
                                } = a;
                            let u, f, m;
                            for (u = 0, f = n.length; u < f; ++u) {
                                m = n[u];
                                const {
                                    fullSize: y
                                } = m.box, A = s[m.stack], L = A && m.stackWeight / A.weight;
                                m.horizontal ? (m.width = L ? L * o : y && a.availableWidth, m.height = c) : (m.width = o, m.height = L ? L * c : y && a.availableHeight)
                            }
                            return s
                        }(y.concat(A), O);
                    rs(m.fullSize, B, O, V), rs(y, B, O, V), rs(A, B, O, V) && rs(y, B, O, V),
                        function Jo(n) {
                            const a = n.maxPadding;

                            function s(o) {
                                const c = Math.max(a[o] - n[o], 0);
                                return n[o] += c, c
                            }
                            n.y += s("top"), n.x += s("left"), s("right"), s("bottom")
                        }(B), an(m.leftAndTop, B, O, V), B.x += B.w, B.y += B.h, an(m.rightAndBottom, B, O, V), n.chartArea = {
                            left: B.left,
                            top: B.top,
                            right: B.left + B.w,
                            bottom: B.top + B.h,
                            height: B.h,
                            width: B.w
                        }, Yt(m.chartArea, G => {
                            const Z = G.box;
                            Object.assign(Z, n.chartArea), Z.update(B.w, B.h, {
                                left: 0,
                                top: 0,
                                right: 0,
                                bottom: 0
                            })
                        })
                }
            };
            class nn {
                acquireContext(a, s) {}
                releaseContext(a) {
                    return !1
                }
                addEventListener(a, s, o) {}
                removeEventListener(a, s, o) {}
                getDevicePixelRatio() {
                    return 1
                }
                getMaximumSize(a, s, o, c) {
                    return s = Math.max(0, s || a.width), o = o || a.height, {
                        width: s,
                        height: Math.max(0, c ? Math.floor(s / c) : o)
                    }
                }
                isAttached(a) {
                    return !0
                }
                updateConfig(a) {}
            }
            class el extends nn {
                acquireContext(a) {
                    return a && a.getContext && a.getContext("2d") || null
                }
                updateConfig(a) {
                    a.options.animation = !1
                }
            }
            const As = "$chartjs",
                il = {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup",
                    pointerenter: "mouseenter",
                    pointerdown: "mousedown",
                    pointermove: "mousemove",
                    pointerup: "mouseup",
                    pointerleave: "mouseout",
                    pointerout: "mouseout"
                },
                rn = n => null === n || "" === n,
                on = !!eo && {
                    passive: !0
                };

            function nl(n, a, s) {
                n.canvas.removeEventListener(a, s, on)
            }

            function Ss(n, a) {
                for (const s of n)
                    if (s === a || s.contains(a)) return !0
            }

            function ol(n, a, s) {
                const o = n.canvas,
                    c = new MutationObserver(u => {
                        let f = !1;
                        for (const m of u) f = f || Ss(m.addedNodes, o), f = f && !Ss(m.removedNodes, o);
                        f && s()
                    });
                return c.observe(document, {
                    childList: !0,
                    subtree: !0
                }), c
            }

            function ll(n, a, s) {
                const o = n.canvas,
                    c = new MutationObserver(u => {
                        let f = !1;
                        for (const m of u) f = f || Ss(m.removedNodes, o), f = f && !Ss(m.addedNodes, o);
                        f && s()
                    });
                return c.observe(document, {
                    childList: !0,
                    subtree: !0
                }), c
            }
            const os = new Map;
            let ln = 0;

            function hn() {
                const n = window.devicePixelRatio;
                n !== ln && (ln = n, os.forEach((a, s) => {
                    s.currentDevicePixelRatio !== n && a()
                }))
            }

            function dl(n, a, s) {
                const o = n.canvas,
                    c = o && Gs(o);
                if (!c) return;
                const u = w((m, y) => {
                        const A = c.clientWidth;
                        s(m, y), A < c.clientWidth && s()
                    }, window),
                    f = new ResizeObserver(m => {
                        const y = m[0],
                            A = y.contentRect.width,
                            L = y.contentRect.height;
                        0 === A && 0 === L || u(A, L)
                    });
                return f.observe(c),
                    function hl(n, a) {
                        os.size || window.addEventListener("resize", hn), os.set(n, a)
                    }(n, u), f
            }

            function Js(n, a, s) {
                s && s.disconnect(), "resize" === a && function cl(n) {
                    os.delete(n), os.size || window.removeEventListener("resize", hn)
                }(n)
            }

            function ul(n, a, s) {
                const o = n.canvas,
                    c = w(u => {
                        null !== n.ctx && s(function rl(n, a) {
                            const s = il[n.type] || n.type,
                                {
                                    x: o,
                                    y: c
                                } = Ii(n, a);
                            return {
                                type: s,
                                chart: a,
                                native: n,
                                x: void 0 !== o ? o : null,
                                y: void 0 !== c ? c : null
                            }
                        }(u, n))
                    }, n);
                return function al(n, a, s) {
                    n.addEventListener(a, s, on)
                }(o, a, c), c
            }
            class gl extends nn {
                acquireContext(a, s) {
                    const o = a && a.getContext && a.getContext("2d");
                    return o && o.canvas === a ? (function sl(n, a) {
                        const s = n.style,
                            o = n.getAttribute("height"),
                            c = n.getAttribute("width");
                        if (n[As] = {
                                initial: {
                                    height: o,
                                    width: c,
                                    style: {
                                        display: s.display,
                                        height: s.height,
                                        width: s.width
                                    }
                                }
                            }, s.display = s.display || "block", s.boxSizing = s.boxSizing || "border-box", rn(c)) {
                            const u = _a(n, "width");
                            void 0 !== u && (n.width = u)
                        }
                        if (rn(o))
                            if ("" === n.style.height) n.height = n.width / (a || 2);
                            else {
                                const u = _a(n, "height");
                                void 0 !== u && (n.height = u)
                            }
                    }(a, s), o) : null
                }
                releaseContext(a) {
                    const s = a.canvas;
                    if (!s[As]) return !1;
                    const o = s[As].initial;
                    ["height", "width"].forEach(u => {
                        const f = o[u];
                        zt(f) ? s.removeAttribute(u) : s.setAttribute(u, f)
                    });
                    const c = o.style || {};
                    return Object.keys(c).forEach(u => {
                        s.style[u] = c[u]
                    }), s.width = s.width, delete s[As], !0
                }
                addEventListener(a, s, o) {
                    this.removeEventListener(a, s), (a.$proxies || (a.$proxies = {}))[s] = ({
                        attach: ol,
                        detach: ll,
                        resize: dl
                    }[s] || ul)(a, s, o)
                }
                removeEventListener(a, s) {
                    const o = a.$proxies || (a.$proxies = {}),
                        c = o[s];
                    c && (({
                        attach: Js,
                        detach: Js,
                        resize: Js
                    }[s] || nl)(a, s, c), o[s] = void 0)
                }
                getDevicePixelRatio() {
                    return window.devicePixelRatio
                }
                getMaximumSize(a, s, o, c) {
                    return function to(n, a, s, o) {
                        const c = ys(n),
                            u = Di(c, "margin"),
                            f = vs(c.maxWidth, n, "clientWidth") || N,
                            m = vs(c.maxHeight, n, "clientHeight") || N,
                            y = function Jr(n, a, s) {
                                let o, c;
                                if (void 0 === a || void 0 === s) {
                                    const u = Gs(n);
                                    if (u) {
                                        const f = u.getBoundingClientRect(),
                                            m = ys(u),
                                            y = Di(m, "border", "width"),
                                            A = Di(m, "padding");
                                        a = f.width - A.width - y.width, s = f.height - A.height - y.height, o = vs(m.maxWidth, u, "clientWidth"), c = vs(m.maxHeight, u, "clientHeight")
                                    } else a = n.clientWidth, s = n.clientHeight
                                }
                                return {
                                    width: a,
                                    height: s,
                                    maxWidth: o || N,
                                    maxHeight: c || N
                                }
                            }(n, a, s);
                        let {
                            width: A,
                            height: L
                        } = y;
                        if ("content-box" === c.boxSizing) {
                            const z = Di(c, "border", "width"),
                                B = Di(c, "padding");
                            A -= B.width + z.width, L -= B.height + z.height
                        }
                        return A = Math.max(0, A - u.width), L = Math.max(0, o ? A / o : L - u.height), A = ws(Math.min(A, f, y.maxWidth)), L = ws(Math.min(L, m, y.maxHeight)), A && !L && (L = ws(A / 2)), (void 0 !== a || void 0 !== s) && o && y.height && L > y.height && (L = y.height, A = ws(Math.floor(L * o))), {
                            width: A,
                            height: L
                        }
                    }(a, s, o, c)
                }
                isAttached(a) {
                    const s = Gs(a);
                    return !(!s || !s.isConnected)
                }
            }
            class ri {
                static defaults = {};
                static defaultRoutes = void 0;
                x;
                y;
                active = !1;
                options;
                $animations;
                tooltipPosition(a) {
                    const {
                        x: s,
                        y: o
                    } = this.getProps(["x", "y"], a);
                    return {
                        x: s,
                        y: o
                    }
                }
                hasValue() {
                    return st(this.x) && st(this.y)
                }
                getProps(a, s) {
                    const o = this.$animations;
                    if (!s || !o) return this;
                    const c = {};
                    return a.forEach(u => {
                        c[u] = o[u] && o[u].active() ? o[u]._to : this[u]
                    }), c
                }
            }

            function Cs(n, a, s, o, c) {
                const u = Ct(o, 0),
                    f = Math.min(Ct(c, n.length), n.length);
                let y, A, L, m = 0;
                for (s = Math.ceil(s), c && (y = c - o, s = y / Math.floor(y / s)), L = u; L < 0;) m++, L = Math.round(u + m * s);
                for (A = Math.max(u, 0); A < f; A++) A === L && (a.push(n[A]), m++, L = Math.round(u + m * s))
            }
            const cn = (n, a, s) => "top" === a || "left" === a ? n[a] + s : n[a] - s,
                dn = (n, a) => Math.min(a || n, n);

            function un(n, a) {
                const s = [],
                    o = n.length / a,
                    c = n.length;
                let u = 0;
                for (; u < c; u += o) s.push(n[Math.floor(u)]);
                return s
            }

            function kl(n, a, s) {
                const o = n.ticks.length,
                    c = Math.min(a, o - 1),
                    u = n._startPixel,
                    f = n._endPixel,
                    m = 1e-6;
                let A, y = n.getPixelForTick(c);
                if (!(s && (A = 1 === o ? Math.max(y - u, f - y) : 0 === a ? (n.getPixelForTick(1) - y) / 2 : (y - n.getPixelForTick(c - 1)) / 2, y += c < a ? A : -A, y < u - m || y > f + m))) return y
            }

            function ls(n) {
                return n.drawTicks ? n.tickLength : 0
            }

            function gn(n, a) {
                if (!n.display) return 0;
                const s = de(n.font, a),
                    o = ye(n.padding);
                return (Qt(n.text) ? n.text.length : 1) * s.lineHeight + o.height
            }

            function Ml(n, a, s) {
                let o = C(n);
                return (s && "right" !== a || !s && "right" === a) && (o = (n => "left" === n ? "right" : "right" === n ? "left" : n)(o)), o
            }
            class Fi extends ri {
                constructor(a) {
                    super(), this.id = a.id, this.type = a.type, this.options = void 0, this.ctx = a.ctx, this.chart = a.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
                }
                init(a) {
                    this.options = a.setContext(this.getContext()), this.axis = a.axis, this._userMin = this.parse(a.min), this._userMax = this.parse(a.max), this._suggestedMin = this.parse(a.suggestedMin), this._suggestedMax = this.parse(a.suggestedMax)
                }
                parse(a, s) {
                    return a
                }
                getUserBounds() {
                    let {
                        _userMin: a,
                        _userMax: s,
                        _suggestedMin: o,
                        _suggestedMax: c
                    } = this;
                    return a = Jt(a, Number.POSITIVE_INFINITY), s = Jt(s, Number.NEGATIVE_INFINITY), o = Jt(o, Number.POSITIVE_INFINITY), c = Jt(c, Number.NEGATIVE_INFINITY), {
                        min: Jt(a, o),
                        max: Jt(s, c),
                        minDefined: $t(a),
                        maxDefined: $t(s)
                    }
                }
                getMinMax(a) {
                    let f, {
                        min: s,
                        max: o,
                        minDefined: c,
                        maxDefined: u
                    } = this.getUserBounds();
                    if (c && u) return {
                        min: s,
                        max: o
                    };
                    const m = this.getMatchingVisibleMetas();
                    for (let y = 0, A = m.length; y < A; ++y) f = m[y].controller.getMinMax(this, a), c || (s = Math.min(s, f.min)), u || (o = Math.max(o, f.max));
                    return s = u && s > o ? o : s, o = c && s > o ? s : o, {
                        min: Jt(s, Jt(o, s)),
                        max: Jt(o, Jt(s, o))
                    }
                }
                getPadding() {
                    return {
                        left: this.paddingLeft || 0,
                        top: this.paddingTop || 0,
                        right: this.paddingRight || 0,
                        bottom: this.paddingBottom || 0
                    }
                }
                getTicks() {
                    return this.ticks
                }
                getLabels() {
                    const a = this.chart.data;
                    return this.options.labels || (this.isHorizontal() ? a.xLabels : a.yLabels) || a.labels || []
                }
                getLabelItems(a = this.chart.chartArea) {
                    return this._labelItems || (this._labelItems = this._computeLabelItems(a))
                }
                beforeLayout() {
                    this._cache = {}, this._dataLimitsCached = !1
                }
                beforeUpdate() {
                    qt(this.options.beforeUpdate, [this])
                }
                update(a, s, o) {
                    const {
                        beginAtZero: c,
                        grace: u,
                        ticks: f
                    } = this.options, m = f.sampleSize;
                    this.beforeUpdate(), this.maxWidth = a, this.maxHeight = s, this._margins = o = Object.assign({
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, o), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + o.left + o.right : this.height + o.top + o.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function Er(n, a, s) {
                        const {
                            min: o,
                            max: c
                        } = n, u = Wi(a, (c - o) / 2), f = (m, y) => s && 0 === m ? 0 : m + y;
                        return {
                            min: f(o, -Math.abs(u)),
                            max: f(c, u)
                        }
                    }(this, u, c), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
                    const y = m < this.ticks.length;
                    this._convertTicksToLabels(y ? un(this.ticks, m) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), f.display && (f.autoSkip || "auto" === f.source) && (this.ticks = function pl(n, a) {
                        const s = n.options.ticks,
                            o = function xl(n) {
                                const a = n.options.offset,
                                    s = n._tickSize();
                                return Math.floor(Math.min(n._length / s + (a ? 0 : 1), n._maxLength / s))
                            }(n),
                            c = Math.min(s.maxTicksLimit || o, o),
                            u = s.major.enabled ? function bl(n) {
                                const a = [];
                                let s, o;
                                for (s = 0, o = n.length; s < o; s++) n[s].major && a.push(s);
                                return a
                            }(a) : [],
                            f = u.length,
                            m = u[0],
                            y = u[f - 1],
                            A = [];
                        if (f > c) return function vl(n, a, s, o) {
                            let f, c = 0,
                                u = s[0];
                            for (o = Math.ceil(o), f = 0; f < n.length; f++) f === u && (a.push(n[f]), c++, u = s[c * o])
                        }(a, A, u, f / c), A;
                        const L = function ml(n, a, s) {
                            const o = function yl(n) {
                                    const a = n.length;
                                    let s, o;
                                    if (a < 2) return !1;
                                    for (o = n[0], s = 1; s < a; ++s)
                                        if (n[s] - n[s - 1] !== o) return !1;
                                    return o
                                }(n),
                                c = a.length / s;
                            if (!o) return Math.max(c, 1);
                            const u = function wt(n) {
                                const a = [],
                                    s = Math.sqrt(n);
                                let o;
                                for (o = 1; o < s; o++) n % o == 0 && (a.push(o), a.push(n / o));
                                return s === (0 | s) && a.push(s), a.sort((c, u) => c - u).pop(), a
                            }(o);
                            for (let f = 0, m = u.length - 1; f < m; f++) {
                                const y = u[f];
                                if (y > c) return y
                            }
                            return Math.max(c, 1)
                        }(u, a, c);
                        if (f > 0) {
                            let O, z;
                            const B = f > 1 ? Math.round((y - m) / (f - 1)) : null;
                            for (Cs(a, A, L, zt(B) ? 0 : m - B, m), O = 0, z = f - 1; O < z; O++) Cs(a, A, L, u[O], u[O + 1]);
                            return Cs(a, A, L, y, zt(B) ? a.length : y + B), A
                        }
                        return Cs(a, A, L), A
                    }(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), y && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
                }
                configure() {
                    let s, o, a = this.options.reverse;
                    this.isHorizontal() ? (s = this.left, o = this.right) : (s = this.top, o = this.bottom, a = !a), this._startPixel = s, this._endPixel = o, this._reversePixels = a, this._length = o - s, this._alignToPixels = this.options.alignToPixels
                }
                afterUpdate() {
                    qt(this.options.afterUpdate, [this])
                }
                beforeSetDimensions() {
                    qt(this.options.beforeSetDimensions, [this])
                }
                setDimensions() {
                    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
                }
                afterSetDimensions() {
                    qt(this.options.afterSetDimensions, [this])
                }
                _callHooks(a) {
                    this.chart.notifyPlugins(a, this.getContext()), qt(this.options[a], [this])
                }
                beforeDataLimits() {
                    this._callHooks("beforeDataLimits")
                }
                determineDataLimits() {}
                afterDataLimits() {
                    this._callHooks("afterDataLimits")
                }
                beforeBuildTicks() {
                    this._callHooks("beforeBuildTicks")
                }
                buildTicks() {
                    return []
                }
                afterBuildTicks() {
                    this._callHooks("afterBuildTicks")
                }
                beforeTickToLabelConversion() {
                    qt(this.options.beforeTickToLabelConversion, [this])
                }
                generateTickLabels(a) {
                    const s = this.options.ticks;
                    let o, c, u;
                    for (o = 0, c = a.length; o < c; o++) u = a[o], u.label = qt(s.callback, [u.value, o, a], this)
                }
                afterTickToLabelConversion() {
                    qt(this.options.afterTickToLabelConversion, [this])
                }
                beforeCalculateLabelRotation() {
                    qt(this.options.beforeCalculateLabelRotation, [this])
                }
                calculateLabelRotation() {
                    const a = this.options,
                        s = a.ticks,
                        o = dn(this.ticks.length, a.ticks.maxTicksLimit),
                        c = s.minRotation || 0,
                        u = s.maxRotation;
                    let m, y, A, f = c;
                    if (!this._isVisible() || !s.display || c >= u || o <= 1 || !this.isHorizontal()) return void(this.labelRotation = c);
                    const L = this._getLabelSizes(),
                        O = L.widest.width,
                        z = L.highest.height,
                        B = Mt(this.chart.width - O, 0, this.maxWidth);
                    m = a.offset ? this.maxWidth / o : B / (o - 1), O + 6 > m && (m = B / (o - (a.offset ? .5 : 1)), y = this.maxHeight - ls(a.grid) - s.padding - gn(a.title, this.chart.options.font), A = Math.sqrt(O * O + z * z), f = Ut(Math.min(Math.asin(Mt((L.highest.height + 6) / m, -1, 1)), Math.asin(Mt(y / A, -1, 1)) - Math.asin(Mt(z / A, -1, 1)))), f = Math.max(c, Math.min(u, f))), this.labelRotation = f
                }
                afterCalculateLabelRotation() {
                    qt(this.options.afterCalculateLabelRotation, [this])
                }
                afterAutoSkip() {}
                beforeFit() {
                    qt(this.options.beforeFit, [this])
                }
                fit() {
                    const a = {
                            width: 0,
                            height: 0
                        },
                        {
                            chart: s,
                            options: {
                                ticks: o,
                                title: c,
                                grid: u
                            }
                        } = this,
                        f = this._isVisible(),
                        m = this.isHorizontal();
                    if (f) {
                        const y = gn(c, s.options.font);
                        if (m ? (a.width = this.maxWidth, a.height = ls(u) + y) : (a.height = this.maxHeight, a.width = ls(u) + y), o.display && this.ticks.length) {
                            const {
                                first: A,
                                last: L,
                                widest: O,
                                highest: z
                            } = this._getLabelSizes(), B = 2 * o.padding, V = Gt(this.labelRotation), G = Math.cos(V), Z = Math.sin(V);
                            m ? a.height = Math.min(this.maxHeight, a.height + (o.mirror ? 0 : Z * O.width + G * z.height) + B) : a.width = Math.min(this.maxWidth, a.width + (o.mirror ? 0 : G * O.width + Z * z.height) + B), this._calculatePadding(A, L, Z, G)
                        }
                    }
                    this._handleMargins(), m ? (this.width = this._length = s.width - this._margins.left - this._margins.right, this.height = a.height) : (this.width = a.width, this.height = this._length = s.height - this._margins.top - this._margins.bottom)
                }
                _calculatePadding(a, s, o, c) {
                    const {
                        ticks: {
                            align: u,
                            padding: f
                        },
                        position: m
                    } = this.options, y = 0 !== this.labelRotation, A = "top" !== m && "x" === this.axis;
                    if (this.isHorizontal()) {
                        const L = this.getPixelForTick(0) - this.left,
                            O = this.right - this.getPixelForTick(this.ticks.length - 1);
                        let z = 0,
                            B = 0;
                        y ? A ? (z = c * a.width, B = o * s.height) : (z = o * a.height, B = c * s.width) : "start" === u ? B = s.width : "end" === u ? z = a.width : "inner" !== u && (z = a.width / 2, B = s.width / 2), this.paddingLeft = Math.max((z - L + f) * this.width / (this.width - L), 0), this.paddingRight = Math.max((B - O + f) * this.width / (this.width - O), 0)
                    } else {
                        let L = s.height / 2,
                            O = a.height / 2;
                        "start" === u ? (L = 0, O = a.height) : "end" === u && (L = s.height, O = 0), this.paddingTop = L + f, this.paddingBottom = O + f
                    }
                }
                _handleMargins() {
                    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
                }
                afterFit() {
                    qt(this.options.afterFit, [this])
                }
                isHorizontal() {
                    const {
                        axis: a,
                        position: s
                    } = this.options;
                    return "top" === s || "bottom" === s || "x" === a
                }
                isFullSize() {
                    return this.options.fullSize
                }
                _convertTicksToLabels(a) {
                    let s, o;
                    for (this.beforeTickToLabelConversion(), this.generateTickLabels(a), s = 0, o = a.length; s < o; s++) zt(a[s].label) && (a.splice(s, 1), o--, s--);
                    this.afterTickToLabelConversion()
                }
                _getLabelSizes() {
                    let a = this._labelSizes;
                    if (!a) {
                        const s = this.options.ticks.sampleSize;
                        let o = this.ticks;
                        s < o.length && (o = un(o, s)), this._labelSizes = a = this._computeLabelSizes(o, o.length, this.options.ticks.maxTicksLimit)
                    }
                    return a
                }
                _computeLabelSizes(a, s, o) {
                    const {
                        ctx: c,
                        _longestTextCache: u
                    } = this, f = [], m = [], y = Math.floor(s / dn(s, o));
                    let O, z, B, V, G, Z, tt, J, dt, pt, nt, A = 0,
                        L = 0;
                    for (O = 0; O < s; O += y) {
                        if (V = a[O].label, G = this._resolveTickFontOptions(O), c.font = Z = G.string, tt = u[Z] = u[Z] || {
                                data: {},
                                gc: []
                            }, J = G.lineHeight, dt = pt = 0, zt(V) || Qt(V)) {
                            if (Qt(V))
                                for (z = 0, B = V.length; z < B; ++z) nt = V[z], !zt(nt) && !Qt(nt) && (dt = _i(c, tt.data, tt.gc, dt, nt), pt += J)
                        } else dt = _i(c, tt.data, tt.gc, dt, V), pt = J;
                        f.push(dt), m.push(pt), A = Math.max(dt, A), L = Math.max(pt, L)
                    }! function Al(n, a) {
                        Yt(n, s => {
                            const o = s.gc,
                                c = o.length / 2;
                            let u;
                            if (c > a) {
                                for (u = 0; u < c; ++u) delete s.data[o[u]];
                                o.splice(0, c)
                            }
                        })
                    }(u, s);
                    const ft = f.indexOf(A),
                        At = m.indexOf(L),
                        vt = St => ({
                            width: f[St] || 0,
                            height: m[St] || 0
                        });
                    return {
                        first: vt(0),
                        last: vt(s - 1),
                        widest: vt(ft),
                        highest: vt(At),
                        widths: f,
                        heights: m
                    }
                }
                getLabelForValue(a) {
                    return a
                }
                getPixelForValue(a, s) {
                    return NaN
                }
                getValueForPixel(a) {}
                getPixelForTick(a) {
                    const s = this.ticks;
                    return a < 0 || a > s.length - 1 ? null : this.getPixelForValue(s[a].value)
                }
                getPixelForDecimal(a) {
                    this._reversePixels && (a = 1 - a);
                    const s = this._startPixel + a * this._length;
                    return function _(n) {
                        return Mt(n, -32768, 32767)
                    }(this._alignToPixels ? Ti(this.chart, s, 0) : s)
                }
                getDecimalForPixel(a) {
                    const s = (a - this._startPixel) / this._length;
                    return this._reversePixels ? 1 - s : s
                }
                getBasePixel() {
                    return this.getPixelForValue(this.getBaseValue())
                }
                getBaseValue() {
                    const {
                        min: a,
                        max: s
                    } = this;
                    return a < 0 && s < 0 ? s : a > 0 && s > 0 ? a : 0
                }
                getContext(a) {
                    const s = this.ticks || [];
                    if (a >= 0 && a < s.length) {
                        const o = s[a];
                        return o.$context || (o.$context = function Cl(n, a, s) {
                            return wi(n, {
                                tick: s,
                                index: a,
                                type: "tick"
                            })
                        }(this.getContext(), a, o))
                    }
                    return this.$context || (this.$context = function Sl(n, a) {
                        return wi(n, {
                            scale: a,
                            type: "scale"
                        })
                    }(this.chart.getContext(), this))
                }
                _tickSize() {
                    const a = this.options.ticks,
                        s = Gt(this.labelRotation),
                        o = Math.abs(Math.cos(s)),
                        c = Math.abs(Math.sin(s)),
                        u = this._getLabelSizes(),
                        f = a.autoSkipPadding || 0,
                        m = u ? u.widest.width + f : 0,
                        y = u ? u.highest.height + f : 0;
                    return this.isHorizontal() ? y * o > m * c ? m / o : y / c : y * c < m * o ? y / o : m / c
                }
                _isVisible() {
                    const a = this.options.display;
                    return "auto" !== a ? !!a : this.getMatchingVisibleMetas().length > 0
                }
                _computeGridLineItems(a) {
                    const s = this.axis,
                        o = this.chart,
                        c = this.options,
                        {
                            grid: u,
                            position: f,
                            border: m
                        } = c,
                        y = u.offset,
                        A = this.isHorizontal(),
                        O = this.ticks.length + (y ? 1 : 0),
                        z = ls(u),
                        B = [],
                        V = m.setContext(this.getContext()),
                        G = V.display ? V.width : 0,
                        Z = G / 2,
                        tt = function(oe) {
                            return Ti(o, oe, G)
                        };
                    let J, dt, pt, nt, ft, At, vt, St, It, Ot, Ht, me;
                    if ("top" === f) J = tt(this.bottom), At = this.bottom - z, St = J - Z, Ot = tt(a.top) + Z, me = a.bottom;
                    else if ("bottom" === f) J = tt(this.top), Ot = a.top, me = tt(a.bottom) - Z, At = J + Z, St = this.top + z;
                    else if ("left" === f) J = tt(this.right), ft = this.right - z, vt = J - Z, It = tt(a.left) + Z, Ht = a.right;
                    else if ("right" === f) J = tt(this.left), It = a.left, Ht = tt(a.right) - Z, ft = J + Z, vt = this.left + z;
                    else if ("x" === s) {
                        if ("center" === f) J = tt((a.top + a.bottom) / 2 + .5);
                        else if (Tt(f)) {
                            const oe = Object.keys(f)[0];
                            J = tt(this.chart.scales[oe].getPixelForValue(f[oe]))
                        }
                        Ot = a.top, me = a.bottom, At = J + Z, St = At + z
                    } else if ("y" === s) {
                        if ("center" === f) J = tt((a.left + a.right) / 2);
                        else if (Tt(f)) {
                            const oe = Object.keys(f)[0];
                            J = tt(this.chart.scales[oe].getPixelForValue(f[oe]))
                        }
                        ft = J - Z, vt = ft - z, It = a.left, Ht = a.right
                    }
                    const Ie = Ct(c.ticks.maxTicksLimit, O),
                        se = Math.max(1, Math.ceil(O / Ie));
                    for (dt = 0; dt < O; dt += se) {
                        const oe = this.getContext(dt),
                            he = u.setContext(oe),
                            Ge = m.setContext(oe),
                            ke = he.lineWidth,
                            qi = he.color,
                            Xs = Ge.dash || [],
                            Ki = Ge.dashOffset,
                            us = he.tickWidth,
                            gs = he.tickColor,
                            fs = he.tickBorderDash || [],
                            ps = he.tickBorderDashOffset;
                        pt = kl(this, dt, y), void 0 !== pt && (nt = Ti(o, pt, ke), A ? ft = vt = It = Ht = nt : At = St = Ot = me = nt, B.push({
                            tx1: ft,
                            ty1: At,
                            tx2: vt,
                            ty2: St,
                            x1: It,
                            y1: Ot,
                            x2: Ht,
                            y2: me,
                            width: ke,
                            color: qi,
                            borderDash: Xs,
                            borderDashOffset: Ki,
                            tickWidth: us,
                            tickColor: gs,
                            tickBorderDash: fs,
                            tickBorderDashOffset: ps
                        }))
                    }
                    return this._ticksLength = O, this._borderValue = J, B
                }
                _computeLabelItems(a) {
                    const s = this.axis,
                        o = this.options,
                        {
                            position: c,
                            ticks: u
                        } = o,
                        f = this.isHorizontal(),
                        m = this.ticks,
                        {
                            align: y,
                            crossAlign: A,
                            padding: L,
                            mirror: O
                        } = u,
                        z = ls(o.grid),
                        B = z + L,
                        V = O ? -L : B,
                        G = -Gt(this.labelRotation),
                        Z = [];
                    let tt, J, dt, pt, nt, ft, At, vt, St, It, Ot, Ht, me = "middle";
                    if ("top" === c) ft = this.bottom - V, At = this._getXAxisLabelAlignment();
                    else if ("bottom" === c) ft = this.top + V, At = this._getXAxisLabelAlignment();
                    else if ("left" === c) {
                        const se = this._getYAxisLabelAlignment(z);
                        At = se.textAlign, nt = se.x
                    } else if ("right" === c) {
                        const se = this._getYAxisLabelAlignment(z);
                        At = se.textAlign, nt = se.x
                    } else if ("x" === s) {
                        if ("center" === c) ft = (a.top + a.bottom) / 2 + B;
                        else if (Tt(c)) {
                            const se = Object.keys(c)[0];
                            ft = this.chart.scales[se].getPixelForValue(c[se]) + B
                        }
                        At = this._getXAxisLabelAlignment()
                    } else if ("y" === s) {
                        if ("center" === c) nt = (a.left + a.right) / 2 - B;
                        else if (Tt(c)) {
                            const se = Object.keys(c)[0];
                            nt = this.chart.scales[se].getPixelForValue(c[se])
                        }
                        At = this._getYAxisLabelAlignment(z).textAlign
                    }
                    "y" === s && ("start" === y ? me = "top" : "end" === y && (me = "bottom"));
                    const Ie = this._getLabelSizes();
                    for (tt = 0, J = m.length; tt < J; ++tt) {
                        dt = m[tt], pt = dt.label;
                        const se = u.setContext(this.getContext(tt));
                        vt = this.getPixelForTick(tt) + u.labelOffset, St = this._resolveTickFontOptions(tt), It = St.lineHeight, Ot = Qt(pt) ? pt.length : 1;
                        const oe = Ot / 2,
                            he = se.color,
                            Ge = se.textStrokeColor,
                            ke = se.textStrokeWidth;
                        let Xs, qi = At;
                        if (f ? (nt = vt, "inner" === At && (qi = tt === J - 1 ? this.options.reverse ? "left" : "right" : 0 === tt ? this.options.reverse ? "right" : "left" : "center"), Ht = "top" === c ? "near" === A || 0 !== G ? -Ot * It + It / 2 : "center" === A ? -Ie.highest.height / 2 - oe * It + It : It / 2 - Ie.highest.height : "near" === A || 0 !== G ? It / 2 : "center" === A ? Ie.highest.height / 2 - oe * It : Ie.highest.height - Ot * It, O && (Ht *= -1), 0 !== G && !se.showLabelBackdrop && (nt += It / 2 * Math.sin(G))) : (ft = vt, Ht = (1 - Ot) * It / 2), se.showLabelBackdrop) {
                            const Ki = ye(se.backdropPadding),
                                us = Ie.heights[tt],
                                gs = Ie.widths[tt];
                            let fs = Ht - Ki.top,
                                ps = 0 - Ki.left;
                            switch (me) {
                                case "middle":
                                    fs -= us / 2;
                                    break;
                                case "bottom":
                                    fs -= us
                            }
                            switch (At) {
                                case "center":
                                    ps -= gs / 2;
                                    break;
                                case "right":
                                    ps -= gs
                            }
                            Xs = {
                                left: ps,
                                top: fs,
                                width: gs + Ki.width,
                                height: us + Ki.height,
                                color: se.backdropColor
                            }
                        }
                        Z.push({
                            label: pt,
                            font: St,
                            textOffset: Ht,
                            options: {
                                rotation: G,
                                color: he,
                                strokeColor: Ge,
                                strokeWidth: ke,
                                textAlign: qi,
                                textBaseline: me,
                                translation: [nt, ft],
                                backdrop: Xs
                            }
                        })
                    }
                    return Z
                }
                _getXAxisLabelAlignment() {
                    const {
                        position: a,
                        ticks: s
                    } = this.options;
                    if (-Gt(this.labelRotation)) return "top" === a ? "left" : "right";
                    let c = "center";
                    return "start" === s.align ? c = "left" : "end" === s.align ? c = "right" : "inner" === s.align && (c = "inner"), c
                }
                _getYAxisLabelAlignment(a) {
                    const {
                        position: s,
                        ticks: {
                            crossAlign: o,
                            mirror: c,
                            padding: u
                        }
                    } = this.options, m = a + u, y = this._getLabelSizes().widest.width;
                    let A, L;
                    return "left" === s ? c ? (L = this.right + u, "near" === o ? A = "left" : "center" === o ? (A = "center", L += y / 2) : (A = "right", L += y)) : (L = this.right - m, "near" === o ? A = "right" : "center" === o ? (A = "center", L -= y / 2) : (A = "left", L = this.left)) : "right" === s ? c ? (L = this.left + u, "near" === o ? A = "right" : "center" === o ? (A = "center", L -= y / 2) : (A = "left", L -= y)) : (L = this.left + m, "near" === o ? A = "left" : "center" === o ? (A = "center", L += y / 2) : (A = "right", L = this.right)) : A = "right", {
                        textAlign: A,
                        x: L
                    }
                }
                _computeLabelArea() {
                    if (this.options.ticks.mirror) return;
                    const a = this.chart,
                        s = this.options.position;
                    return "left" === s || "right" === s ? {
                        top: 0,
                        left: this.left,
                        bottom: a.height,
                        right: this.right
                    } : "top" === s || "bottom" === s ? {
                        top: this.top,
                        left: 0,
                        bottom: this.bottom,
                        right: a.width
                    } : void 0
                }
                drawBackground() {
                    const {
                        ctx: a,
                        options: {
                            backgroundColor: s
                        },
                        left: o,
                        top: c,
                        width: u,
                        height: f
                    } = this;
                    s && (a.save(), a.fillStyle = s, a.fillRect(o, c, u, f), a.restore())
                }
                getLineWidthForValue(a) {
                    const s = this.options.grid;
                    if (!this._isVisible() || !s.display) return 0;
                    const c = this.ticks.findIndex(u => u.value === a);
                    return c >= 0 ? s.setContext(this.getContext(c)).lineWidth : 0
                }
                drawGrid(a) {
                    const s = this.options.grid,
                        o = this.ctx,
                        c = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(a));
                    let u, f;
                    const m = (y, A, L) => {
                        !L.width || !L.color || (o.save(), o.lineWidth = L.width, o.strokeStyle = L.color, o.setLineDash(L.borderDash || []), o.lineDashOffset = L.borderDashOffset, o.beginPath(), o.moveTo(y.x, y.y), o.lineTo(A.x, A.y), o.stroke(), o.restore())
                    };
                    if (s.display)
                        for (u = 0, f = c.length; u < f; ++u) {
                            const y = c[u];
                            s.drawOnChartArea && m({
                                x: y.x1,
                                y: y.y1
                            }, {
                                x: y.x2,
                                y: y.y2
                            }, y), s.drawTicks && m({
                                x: y.tx1,
                                y: y.ty1
                            }, {
                                x: y.tx2,
                                y: y.ty2
                            }, {
                                color: y.tickColor,
                                width: y.tickWidth,
                                borderDash: y.tickBorderDash,
                                borderDashOffset: y.tickBorderDashOffset
                            })
                        }
                }
                drawBorder() {
                    const {
                        chart: a,
                        ctx: s,
                        options: {
                            border: o,
                            grid: c
                        }
                    } = this, u = o.setContext(this.getContext()), f = o.display ? u.width : 0;
                    if (!f) return;
                    const m = c.setContext(this.getContext(0)).lineWidth,
                        y = this._borderValue;
                    let A, L, O, z;
                    this.isHorizontal() ? (A = Ti(a, this.left, f) - f / 2, L = Ti(a, this.right, m) + m / 2, O = z = y) : (O = Ti(a, this.top, f) - f / 2, z = Ti(a, this.bottom, m) + m / 2, A = L = y), s.save(), s.lineWidth = u.width, s.strokeStyle = u.color, s.beginPath(), s.moveTo(A, O), s.lineTo(L, z), s.stroke(), s.restore()
                }
                drawLabels(a) {
                    if (!this.options.ticks.display) return;
                    const o = this.ctx,
                        c = this._computeLabelArea();
                    c && xs(o, c);
                    const u = this.getLabelItems(a);
                    for (const f of u) Oi(o, f.label, 0, f.textOffset, f.font, f.options);
                    c && ms(o)
                }
                drawTitle() {
                    const {
                        ctx: a,
                        options: {
                            position: s,
                            title: o,
                            reverse: c
                        }
                    } = this;
                    if (!o.display) return;
                    const u = de(o.font),
                        f = ye(o.padding),
                        m = o.align;
                    let y = u.lineHeight / 2;
                    "bottom" === s || "center" === s || Tt(s) ? (y += f.bottom, Qt(o.text) && (y += u.lineHeight * (o.text.length - 1))) : y += f.top;
                    const {
                        titleX: A,
                        titleY: L,
                        maxWidth: O,
                        rotation: z
                    } = function Pl(n, a, s, o) {
                        const {
                            top: c,
                            left: u,
                            bottom: f,
                            right: m,
                            chart: y
                        } = n, {
                            chartArea: A,
                            scales: L
                        } = y;
                        let z, B, V, O = 0;
                        const G = f - c,
                            Z = m - u;
                        if (n.isHorizontal()) {
                            if (B = P(o, u, m), Tt(s)) {
                                const tt = Object.keys(s)[0];
                                V = L[tt].getPixelForValue(s[tt]) + G - a
                            } else V = "center" === s ? (A.bottom + A.top) / 2 + G - a : cn(n, s, a);
                            z = m - u
                        } else {
                            if (Tt(s)) {
                                const tt = Object.keys(s)[0];
                                B = L[tt].getPixelForValue(s[tt]) - Z + a
                            } else B = "center" === s ? (A.left + A.right) / 2 - Z + a : cn(n, s, a);
                            V = P(o, f, c), O = "left" === s ? -Y : Y
                        }
                        return {
                            titleX: B,
                            titleY: V,
                            maxWidth: z,
                            rotation: O
                        }
                    }(this, y, s, m);
                    Oi(a, o.text, 0, 0, u, {
                        color: o.color,
                        maxWidth: O,
                        rotation: z,
                        textAlign: Ml(m, s, c),
                        textBaseline: "middle",
                        translation: [A, L]
                    })
                }
                draw(a) {
                    this._isVisible() && (this.drawBackground(), this.drawGrid(a), this.drawBorder(), this.drawTitle(), this.drawLabels(a))
                }
                _layers() {
                    const a = this.options,
                        s = a.ticks && a.ticks.z || 0,
                        o = Ct(a.grid && a.grid.z, -1),
                        c = Ct(a.border && a.border.z, 0);
                    return this._isVisible() && this.draw === Fi.prototype.draw ? [{
                        z: o,
                        draw: u => {
                            this.drawBackground(), this.drawGrid(u), this.drawTitle()
                        }
                    }, {
                        z: c,
                        draw: () => {
                            this.drawBorder()
                        }
                    }, {
                        z: s,
                        draw: u => {
                            this.drawLabels(u)
                        }
                    }] : [{
                        z: s,
                        draw: u => {
                            this.draw(u)
                        }
                    }]
                }
                getMatchingVisibleMetas(a) {
                    const s = this.chart.getSortedVisibleDatasetMetas(),
                        o = this.axis + "AxisID",
                        c = [];
                    let u, f;
                    for (u = 0, f = s.length; u < f; ++u) {
                        const m = s[u];
                        m[o] === this.id && (!a || m.type === a) && c.push(m)
                    }
                    return c
                }
                _resolveTickFontOptions(a) {
                    return de(this.options.ticks.setContext(this.getContext(a)).font)
                }
                _maxDigits() {
                    const a = this._resolveTickFontOptions(0).lineHeight;
                    return (this.isHorizontal() ? this.width : this.height) / a
                }
            }
            class Ms {
                constructor(a, s, o) {
                    this.type = a, this.scope = s, this.override = o, this.items = Object.create(null)
                }
                isForType(a) {
                    return Object.prototype.isPrototypeOf.call(this.type.prototype, a.prototype)
                }
                register(a) {
                    const s = Object.getPrototypeOf(a);
                    let o;
                    (function Tl(n) {
                        return "id" in n && "defaults" in n
                    })(s) && (o = this.register(s));
                    const c = this.items,
                        u = a.id,
                        f = this.scope + "." + u;
                    if (!u) throw new Error("class does not have id: " + a);
                    return u in c || (c[u] = a, function Ll(n, a, s) {
                        const o = re(Object.create(null), [s ? Xt.get(s) : {}, Xt.get(a), n.defaults]);
                        Xt.set(a, o), n.defaultRoutes && function _l(n, a) {
                            Object.keys(a).forEach(s => {
                                const o = s.split("."),
                                    c = o.pop(),
                                    u = [n].concat(o).join("."),
                                    f = a[s].split("."),
                                    m = f.pop(),
                                    y = f.join(".");
                                Xt.route(u, c, y, m)
                            })
                        }(a, n.defaultRoutes), n.descriptors && Xt.describe(a, n.descriptors)
                    }(a, f, o), this.override && Xt.override(a.id, a.overrides)), f
                }
                get(a) {
                    return this.items[a]
                }
                unregister(a) {
                    const s = this.items,
                        o = a.id,
                        c = this.scope;
                    o in s && delete s[o], c && o in Xt[c] && (delete Xt[c][o], this.override && delete Kt[o])
                }
            }
            class Ol {
                constructor() {
                    this.controllers = new Ms(ki, "datasets", !0), this.elements = new Ms(ri, "elements"), this.plugins = new Ms(Object, "plugins"), this.scales = new Ms(Fi, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
                }
                add(...a) {
                    this._each("register", a)
                }
                remove(...a) {
                    this._each("unregister", a)
                }
                addControllers(...a) {
                    this._each("register", a, this.controllers)
                }
                addElements(...a) {
                    this._each("register", a, this.elements)
                }
                addPlugins(...a) {
                    this._each("register", a, this.plugins)
                }
                addScales(...a) {
                    this._each("register", a, this.scales)
                }
                getController(a) {
                    return this._get(a, this.controllers, "controller")
                }
                getElement(a) {
                    return this._get(a, this.elements, "element")
                }
                getPlugin(a) {
                    return this._get(a, this.plugins, "plugin")
                }
                getScale(a) {
                    return this._get(a, this.scales, "scale")
                }
                removeControllers(...a) {
                    this._each("unregister", a, this.controllers)
                }
                removeElements(...a) {
                    this._each("unregister", a, this.elements)
                }
                removePlugins(...a) {
                    this._each("unregister", a, this.plugins)
                }
                removeScales(...a) {
                    this._each("unregister", a, this.scales)
                }
                _each(a, s, o) {
                    [...s].forEach(c => {
                        const u = o || this._getRegistryForType(c);
                        o || u.isForType(c) || u === this.plugins && c.id ? this._exec(a, u, c) : Yt(c, f => {
                            const m = o || this._getRegistryForType(f);
                            this._exec(a, m, f)
                        })
                    })
                }
                _exec(a, s, o) {
                    const c = yi(a);
                    qt(o["before" + c], [], o), s[a](o), qt(o["after" + c], [], o)
                }
                _getRegistryForType(a) {
                    for (let s = 0; s < this._typedRegistries.length; s++) {
                        const o = this._typedRegistries[s];
                        if (o.isForType(a)) return o
                    }
                    return this.plugins
                }
                _get(a, s, o) {
                    const c = s.get(a);
                    if (void 0 === c) throw new Error('"' + a + '" is not a registered ' + o + ".");
                    return c
                }
            }
            var Je = new Ol;
            class El {
                constructor() {
                    this._init = []
                }
                notify(a, s, o, c) {
                    "beforeInit" === s && (this._init = this._createDescriptors(a, !0), this._notify(this._init, a, "install"));
                    const u = c ? this._descriptors(a).filter(c) : this._descriptors(a),
                        f = this._notify(u, a, s, o);
                    return "afterDestroy" === s && (this._notify(u, a, "stop"), this._notify(this._init, a, "uninstall")), f
                }
                _notify(a, s, o, c) {
                    c = c || {};
                    for (const u of a) {
                        const f = u.plugin;
                        if (!1 === qt(f[o], [s, c, u.options], f) && c.cancelable) return !1
                    }
                    return !0
                }
                invalidate() {
                    zt(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
                }
                _descriptors(a) {
                    if (this._cache) return this._cache;
                    const s = this._cache = this._createDescriptors(a);
                    return this._notifyStateChanges(a), s
                }
                _createDescriptors(a, s) {
                    const o = a && a.config,
                        c = Ct(o.options && o.options.plugins, {}),
                        u = function Dl(n) {
                            const a = {},
                                s = [],
                                o = Object.keys(Je.plugins.items);
                            for (let u = 0; u < o.length; u++) s.push(Je.getPlugin(o[u]));
                            const c = n.plugins || [];
                            for (let u = 0; u < c.length; u++) {
                                const f = c[u]; - 1 === s.indexOf(f) && (s.push(f), a[f.id] = !0)
                            }
                            return {
                                plugins: s,
                                localIds: a
                            }
                        }(o);
                    return !1 !== c || s ? function zl(n, {
                        plugins: a,
                        localIds: s
                    }, o, c) {
                        const u = [],
                            f = n.getContext();
                        for (const m of a) {
                            const y = m.id,
                                A = Il(o[y], c);
                            null !== A && u.push({
                                plugin: m,
                                options: Rl(n.config, {
                                    plugin: m,
                                    local: s[y]
                                }, A, f)
                            })
                        }
                        return u
                    }(a, u, c, s) : []
                }
                _notifyStateChanges(a) {
                    const s = this._oldCache || [],
                        o = this._cache,
                        c = (u, f) => u.filter(m => !f.some(y => m.plugin.id === y.plugin.id));
                    this._notify(c(s, o), a, "stop"), this._notify(c(o, s), a, "start")
                }
            }

            function Il(n, a) {
                return a || !1 !== n ? !0 === n ? {} : n : null
            }

            function Rl(n, {
                plugin: a,
                local: s
            }, o, c) {
                const u = n.pluginScopeKeys(a),
                    f = n.getOptionScopes(o, u);
                return s && a.defaults && f.push(a.defaults), n.createResolver(f, c, [""], {
                    scriptable: !1,
                    indexable: !1,
                    allKeys: !0
                })
            }

            function ta(n, a) {
                return ((a.datasets || {})[n] || {}).indexAxis || a.indexAxis || (Xt.datasets[n] || {}).indexAxis || "x"
            }

            function fn(n) {
                if ("x" === n || "y" === n || "r" === n) return n
            }

            function Nl(n) {
                return "top" === n || "bottom" === n ? "x" : "left" === n || "right" === n ? "y" : void 0
            }

            function ea(n, ...a) {
                if (fn(n)) return n;
                for (const s of a) {
                    const o = s.axis || Nl(s.position) || n.length > 1 && fn(n[0].toLowerCase());
                    if (o) return o
                }
                throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`)
            }

            function pn(n, a, s) {
                if (s[a + "AxisID"] === n) return {
                    axis: a
                }
            }

            function xn(n) {
                const a = n.options || (n.options = {});
                a.plugins = Ct(a.plugins, {}), a.scales = function Hl(n, a) {
                    const s = Kt[n.type] || {
                            scales: {}
                        },
                        o = a.scales || {},
                        c = ta(n.type, a),
                        u = Object.create(null);
                    return Object.keys(o).forEach(f => {
                        const m = o[f];
                        if (!Tt(m)) return console.error(`Invalid scale configuration for scale: ${f}`);
                        if (m._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${f}`);
                        const y = ea(f, m, function Bl(n, a) {
                                if (a.data && a.data.datasets) {
                                    const s = a.data.datasets.filter(o => o.xAxisID === n || o.yAxisID === n);
                                    if (s.length) return pn(n, "x", s[0]) || pn(n, "y", s[0])
                                }
                                return {}
                            }(f, n), Xt.scales[m.type]),
                            A = function Xl(n, a) {
                                return n === a ? "_index_" : "_value_"
                            }(y, c),
                            L = s.scales || {};
                        u[f] = qe(Object.create(null), [{
                            axis: y
                        }, m, L[y], L[A]])
                    }), n.data.datasets.forEach(f => {
                        const m = f.type || n.type,
                            y = f.indexAxis || ta(m, a),
                            L = (Kt[m] || {}).scales || {};
                        Object.keys(L).forEach(O => {
                            const z = function Fl(n, a) {
                                    let s = n;
                                    return "_index_" === n ? s = a : "_value_" === n && (s = "x" === a ? "y" : "x"), s
                                }(O, y),
                                B = f[z + "AxisID"] || z;
                            u[B] = u[B] || Object.create(null), qe(u[B], [{
                                axis: z
                            }, o[B], L[O]])
                        })
                    }), Object.keys(u).forEach(f => {
                        const m = u[f];
                        qe(m, [Xt.scales[m.type], Xt.scale])
                    }), u
                }(n, a)
            }

            function mn(n) {
                return (n = n || {}).datasets = n.datasets || [], n.labels = n.labels || [], n
            }
            const bn = new Map,
                vn = new Set;

            function Ps(n, a) {
                let s = bn.get(n);
                return s || (s = a(), bn.set(n, s), vn.add(s)), s
            }
            const hs = (n, a, s) => {
                const o = Fe(a, s);
                void 0 !== o && n.add(o)
            };
            class Wl {
                constructor(a) {
                    this._config = function Yl(n) {
                        return (n = n || {}).data = mn(n.data), xn(n), n
                    }(a), this._scopeCache = new Map, this._resolverCache = new Map
                }
                get platform() {
                    return this._config.platform
                }
                get type() {
                    return this._config.type
                }
                set type(a) {
                    this._config.type = a
                }
                get data() {
                    return this._config.data
                }
                set data(a) {
                    this._config.data = mn(a)
                }
                get options() {
                    return this._config.options
                }
                set options(a) {
                    this._config.options = a
                }
                get plugins() {
                    return this._config.plugins
                }
                update() {
                    const a = this._config;
                    this.clearCache(), xn(a)
                }
                clearCache() {
                    this._scopeCache.clear(), this._resolverCache.clear()
                }
                datasetScopeKeys(a) {
                    return Ps(a, () => [
                        [`datasets.${a}`, ""]
                    ])
                }
                datasetAnimationScopeKeys(a, s) {
                    return Ps(`${a}.transition.${s}`, () => [
                        [`datasets.${a}.transitions.${s}`, `transitions.${s}`],
                        [`datasets.${a}`, ""]
                    ])
                }
                datasetElementScopeKeys(a, s) {
                    return Ps(`${a}-${s}`, () => [
                        [`datasets.${a}.elements.${s}`, `datasets.${a}`, `elements.${s}`, ""]
                    ])
                }
                pluginScopeKeys(a) {
                    const s = a.id;
                    return Ps(`${this.type}-plugin-${s}`, () => [
                        [`plugins.${s}`, ...a.additionalOptionScopes || []]
                    ])
                }
                _cachedScopes(a, s) {
                    const o = this._scopeCache;
                    let c = o.get(a);
                    return (!c || s) && (c = new Map, o.set(a, c)), c
                }
                getOptionScopes(a, s, o) {
                    const {
                        options: c,
                        type: u
                    } = this, f = this._cachedScopes(a, o), m = f.get(s);
                    if (m) return m;
                    const y = new Set;
                    s.forEach(L => {
                        a && (y.add(a), L.forEach(O => hs(y, a, O))), L.forEach(O => hs(y, c, O)), L.forEach(O => hs(y, Kt[u] || {}, O)), L.forEach(O => hs(y, Xt, O)), L.forEach(O => hs(y, Ce, O))
                    });
                    const A = Array.from(y);
                    return 0 === A.length && A.push(Object.create(null)), vn.has(s) && f.set(s, A), A
                }
                chartOptionScopes() {
                    const {
                        options: a,
                        type: s
                    } = this;
                    return [a, Kt[s] || {}, Xt.datasets[s] || {}, {
                        type: s
                    }, Xt, Ce]
                }
                resolveNamedOptions(a, s, o, c = [""]) {
                    const u = {
                            $shared: !0
                        },
                        {
                            resolver: f,
                            subPrefixes: m
                        } = yn(this._resolverCache, a, c);
                    let y = f;
                    (function Gl(n, a) {
                        const {
                            isScriptable: s,
                            isIndexable: o
                        } = va(n);
                        for (const c of a) {
                            const u = s(c),
                                f = o(c),
                                m = (f || u) && n[c];
                            if (u && (Xe(m) || Vl(m)) || f && Qt(m)) return !0
                        }
                        return !1
                    })(f, s) && (u.$shared = !1, y = ji(f, o = Xe(o) ? o() : o, this.createResolver(a, o, m)));
                    for (const A of s) u[A] = y[A];
                    return u
                }
                createResolver(a, s, o = [""], c) {
                    const {
                        resolver: u
                    } = yn(this._resolverCache, a, o);
                    return Tt(s) ? ji(u, s, void 0, c) : u
                }
            }

            function yn(n, a, s) {
                let o = n.get(a);
                o || (o = new Map, n.set(a, o));
                const c = s.join();
                let u = o.get(c);
                return u || (u = {
                    resolver: Ys(a, s),
                    subPrefixes: s.filter(m => !m.toLowerCase().includes("hover"))
                }, o.set(c, u)), u
            }
            const Vl = n => Tt(n) && Object.getOwnPropertyNames(n).reduce((a, s) => a || Xe(n[s]), !1),
                Ul = ["top", "bottom", "left", "right", "chartArea"];

            function wn(n, a) {
                return "top" === n || "bottom" === n || -1 === Ul.indexOf(n) && "x" === a
            }

            function kn(n, a) {
                return function(s, o) {
                    return s[n] === o[n] ? s[a] - o[a] : s[n] - o[n]
                }
            }

            function An(n) {
                const a = n.chart,
                    s = a.options.animation;
                a.notifyPlugins("afterRender"), qt(s && s.onComplete, [n], a)
            }

            function Zl(n) {
                const a = n.chart,
                    s = a.options.animation;
                qt(s && s.onProgress, [n], a)
            }

            function Sn(n) {
                return Pa() && "string" == typeof n ? n = document.getElementById(n) : n && n.length && (n = n[0]), n && n.canvas && (n = n.canvas), n
            }
            const Ls = {},
                Cn = n => {
                    const a = Sn(n);
                    return Object.values(Ls).filter(s => s.canvas === a).pop()
                };

            function $l(n, a, s) {
                const o = Object.keys(n);
                for (const c of o) {
                    const u = +c;
                    if (u >= a) {
                        const f = n[c];
                        delete n[c], (s > 0 || u > a) && (n[u + s] = f)
                    }
                }
            }

            function _s(n, a, s) {
                return n.options.clip ? n[s] : a[s]
            }
            let Ts = (() => class n {
                static defaults = Xt;
                static instances = Ls;
                static overrides = Kt;
                static registry = Je;
                static version = "4.4.0";
                static getChart = Cn;
                static register(...s) {
                    Je.add(...s), Mn()
                }
                static unregister(...s) {
                    Je.remove(...s), Mn()
                }
                constructor(s, o) {
                    const c = this.config = new Wl(o),
                        u = Sn(s),
                        f = Cn(u);
                    if (f) throw new Error("Canvas is already in use. Chart with ID '" + f.id + "' must be destroyed before the canvas with ID '" + f.canvas.id + "' can be reused.");
                    const m = c.createResolver(c.chartOptionScopes(), this.getContext());
                    this.platform = new(c.platform || function fl(n) {
                        return !Pa() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? el : gl
                    }(u)), this.platform.updateConfig(c);
                    const y = this.platform.acquireContext(u, m.aspectRatio),
                        A = y && y.canvas,
                        L = A && A.height,
                        O = A && A.width;
                    this.id = pi(), this.ctx = y, this.canvas = A, this.width = O, this.height = L, this._options = m, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new El, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function S(n, a) {
                        let s;
                        return function(...o) {
                            return a ? (clearTimeout(s), s = setTimeout(n, a, o)) : n.apply(this, o), a
                        }
                    }(z => this.update(z), m.resizeDelay || 0), this._dataChanges = [], Ls[this.id] = this, y && A ? (ni.listen(this, "complete", An), ni.listen(this, "progress", Zl), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
                }
                get aspectRatio() {
                    const {
                        options: {
                            aspectRatio: s,
                            maintainAspectRatio: o
                        },
                        width: c,
                        height: u,
                        _aspectRatio: f
                    } = this;
                    return zt(s) ? o && f ? f : u ? c / u : null : s
                }
                get data() {
                    return this.config.data
                }
                set data(s) {
                    this.config.data = s
                }
                get options() {
                    return this._options
                }
                set options(s) {
                    this.config.options = s
                }
                get registry() {
                    return Je
                }
                _initialize() {
                    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : La(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
                }
                clear() {
                    return xa(this.canvas, this.ctx), this
                }
                stop() {
                    return ni.stop(this), this
                }
                resize(s, o) {
                    ni.running(this) ? this._resizeBeforeDraw = {
                        width: s,
                        height: o
                    } : this._resize(s, o)
                }
                _resize(s, o) {
                    const c = this.options,
                        m = this.platform.getMaximumSize(this.canvas, s, o, c.maintainAspectRatio && this.aspectRatio),
                        y = c.devicePixelRatio || this.platform.getDevicePixelRatio(),
                        A = this.width ? "resize" : "attach";
                    this.width = m.width, this.height = m.height, this._aspectRatio = this.aspectRatio, La(this, y, !0) && (this.notifyPlugins("resize", {
                        size: m
                    }), qt(c.onResize, [this, m], this), this.attached && this._doResize(A) && this.render())
                }
                ensureScalesHaveIDs() {
                    Yt(this.options.scales || {}, (c, u) => {
                        c.id = u
                    })
                }
                buildOrUpdateScales() {
                    const s = this.options,
                        o = s.scales,
                        c = this.scales,
                        u = Object.keys(c).reduce((m, y) => (m[y] = !1, m), {});
                    let f = [];
                    o && (f = f.concat(Object.keys(o).map(m => {
                        const y = o[m],
                            A = ea(m, y),
                            L = "r" === A,
                            O = "x" === A;
                        return {
                            options: y,
                            dposition: L ? "chartArea" : O ? "bottom" : "left",
                            dtype: L ? "radialLinear" : O ? "category" : "linear"
                        }
                    }))), Yt(f, m => {
                        const y = m.options,
                            A = y.id,
                            L = ea(A, y),
                            O = Ct(y.type, m.dtype);
                        (void 0 === y.position || wn(y.position, L) !== wn(m.dposition)) && (y.position = m.dposition), u[A] = !0;
                        let z = null;
                        A in c && c[A].type === O ? z = c[A] : (z = new(Je.getScale(O))({
                            id: A,
                            type: O,
                            ctx: this.ctx,
                            chart: this
                        }), c[z.id] = z), z.init(y, s)
                    }), Yt(u, (m, y) => {
                        m || delete c[y]
                    }), Yt(c, m => {
                        we.configure(this, m, m.options), we.addBox(this, m)
                    })
                }
                _updateMetasets() {
                    const s = this._metasets,
                        o = this.data.datasets.length,
                        c = s.length;
                    if (s.sort((u, f) => u.index - f.index), c > o) {
                        for (let u = o; u < c; ++u) this._destroyDatasetMeta(u);
                        s.splice(o, c - o)
                    }
                    this._sortedMetasets = s.slice(0).sort(kn("order", "index"))
                }
                _removeUnreferencedMetasets() {
                    const {
                        _metasets: s,
                        data: {
                            datasets: o
                        }
                    } = this;
                    s.length > o.length && delete this._stacks, s.forEach((c, u) => {
                        0 === o.filter(f => f === c._dataset).length && this._destroyDatasetMeta(u)
                    })
                }
                buildOrUpdateControllers() {
                    const s = [],
                        o = this.data.datasets;
                    let c, u;
                    for (this._removeUnreferencedMetasets(), c = 0, u = o.length; c < u; c++) {
                        const f = o[c];
                        let m = this.getDatasetMeta(c);
                        const y = f.type || this.config.type;
                        if (m.type && m.type !== y && (this._destroyDatasetMeta(c), m = this.getDatasetMeta(c)), m.type = y, m.indexAxis = f.indexAxis || ta(y, this.options), m.order = f.order || 0, m.index = c, m.label = "" + f.label, m.visible = this.isDatasetVisible(c), m.controller) m.controller.updateIndex(c), m.controller.linkScales();
                        else {
                            const A = Je.getController(y),
                                {
                                    datasetElementType: L,
                                    dataElementType: O
                                } = Xt.datasets[y];
                            Object.assign(A, {
                                dataElementType: Je.getElement(O),
                                datasetElementType: L && Je.getElement(L)
                            }), m.controller = new A(this, c), s.push(m.controller)
                        }
                    }
                    return this._updateMetasets(), s
                }
                _resetElements() {
                    Yt(this.data.datasets, (s, o) => {
                        this.getDatasetMeta(o).controller.reset()
                    }, this)
                }
                reset() {
                    this._resetElements(), this.notifyPlugins("reset")
                }
                update(s) {
                    const o = this.config;
                    o.update();
                    const c = this._options = o.createResolver(o.chartOptionScopes(), this.getContext()),
                        u = this._animationsDisabled = !c.animation;
                    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
                            mode: s,
                            cancelable: !0
                        })) return;
                    const f = this.buildOrUpdateControllers();
                    this.notifyPlugins("beforeElementsUpdate");
                    let m = 0;
                    for (let L = 0, O = this.data.datasets.length; L < O; L++) {
                        const {
                            controller: z
                        } = this.getDatasetMeta(L), B = !u && -1 === f.indexOf(z);
                        z.buildOrUpdateElements(B), m = Math.max(+z.getMaxOverflow(), m)
                    }
                    m = this._minPadding = c.layout.autoPadding ? m : 0, this._updateLayout(m), u || Yt(f, L => {
                        L.reset()
                    }), this._updateDatasets(s), this.notifyPlugins("afterUpdate", {
                        mode: s
                    }), this._layers.sort(kn("z", "_idx"));
                    const {
                        _active: y,
                        _lastEvent: A
                    } = this;
                    A ? this._eventHandler(A, !0) : y.length && this._updateHoverStyles(y, y, !0), this.render()
                }
                _updateScales() {
                    Yt(this.scales, s => {
                        we.removeBox(this, s)
                    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
                }
                _checkEventBindings() {
                    const s = this.options,
                        o = new Set(Object.keys(this._listeners)),
                        c = new Set(s.events);
                    (!Ne(o, c) || !!this._responsiveListeners !== s.responsive) && (this.unbindEvents(), this.bindEvents())
                }
                _updateHiddenIndices() {
                    const {
                        _hiddenIndices: s
                    } = this, o = this._getUniformDataChanges() || [];
                    for (const {
                            method: c,
                            start: u,
                            count: f
                        } of o) $l(s, u, "_removeElements" === c ? -f : f)
                }
                _getUniformDataChanges() {
                    const s = this._dataChanges;
                    if (!s || !s.length) return;
                    this._dataChanges = [];
                    const o = this.data.datasets.length,
                        c = f => new Set(s.filter(m => m[0] === f).map((m, y) => y + "," + m.splice(1).join(","))),
                        u = c(0);
                    for (let f = 1; f < o; f++)
                        if (!Ne(u, c(f))) return;
                    return Array.from(u).map(f => f.split(",")).map(f => ({
                        method: f[1],
                        start: +f[2],
                        count: +f[3]
                    }))
                }
                _updateLayout(s) {
                    if (!1 === this.notifyPlugins("beforeLayout", {
                            cancelable: !0
                        })) return;
                    we.update(this, this.width, this.height, s);
                    const o = this.chartArea,
                        c = o.width <= 0 || o.height <= 0;
                    this._layers = [], Yt(this.boxes, u => {
                        c && "chartArea" === u.position || (u.configure && u.configure(), this._layers.push(...u._layers()))
                    }, this), this._layers.forEach((u, f) => {
                        u._idx = f
                    }), this.notifyPlugins("afterLayout")
                }
                _updateDatasets(s) {
                    if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                            mode: s,
                            cancelable: !0
                        })) {
                        for (let o = 0, c = this.data.datasets.length; o < c; ++o) this.getDatasetMeta(o).controller.configure();
                        for (let o = 0, c = this.data.datasets.length; o < c; ++o) this._updateDataset(o, Xe(s) ? s({
                            datasetIndex: o
                        }) : s);
                        this.notifyPlugins("afterDatasetsUpdate", {
                            mode: s
                        })
                    }
                }
                _updateDataset(s, o) {
                    const c = this.getDatasetMeta(s),
                        u = {
                            meta: c,
                            index: s,
                            mode: o,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetUpdate", u) && (c.controller._update(o), u.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", u))
                }
                render() {
                    !1 !== this.notifyPlugins("beforeRender", {
                        cancelable: !0
                    }) && (ni.has(this) ? this.attached && !ni.running(this) && ni.start(this) : (this.draw(), An({
                        chart: this
                    })))
                }
                draw() {
                    let s;
                    if (this._resizeBeforeDraw) {
                        const {
                            width: c,
                            height: u
                        } = this._resizeBeforeDraw;
                        this._resize(c, u), this._resizeBeforeDraw = null
                    }
                    if (this.clear(), this.width <= 0 || this.height <= 0 || !1 === this.notifyPlugins("beforeDraw", {
                            cancelable: !0
                        })) return;
                    const o = this._layers;
                    for (s = 0; s < o.length && o[s].z <= 0; ++s) o[s].draw(this.chartArea);
                    for (this._drawDatasets(); s < o.length; ++s) o[s].draw(this.chartArea);
                    this.notifyPlugins("afterDraw")
                }
                _getSortedDatasetMetas(s) {
                    const o = this._sortedMetasets,
                        c = [];
                    let u, f;
                    for (u = 0, f = o.length; u < f; ++u) {
                        const m = o[u];
                        (!s || m.visible) && c.push(m)
                    }
                    return c
                }
                getSortedVisibleDatasetMetas() {
                    return this._getSortedDatasetMetas(!0)
                }
                _drawDatasets() {
                    if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                            cancelable: !0
                        })) return;
                    const s = this.getSortedVisibleDatasetMetas();
                    for (let o = s.length - 1; o >= 0; --o) this._drawDataset(s[o]);
                    this.notifyPlugins("afterDatasetsDraw")
                }
                _drawDataset(s) {
                    const o = this.ctx,
                        c = s._clip,
                        u = !c.disabled,
                        f = function Kl(n, a) {
                            const {
                                xScale: s,
                                yScale: o
                            } = n;
                            return s && o ? {
                                left: _s(s, a, "left"),
                                right: _s(s, a, "right"),
                                top: _s(o, a, "top"),
                                bottom: _s(o, a, "bottom")
                            } : a
                        }(s, this.chartArea),
                        m = {
                            meta: s,
                            index: s.index,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetDraw", m) && (u && xs(o, {
                        left: !1 === c.left ? 0 : f.left - c.left,
                        right: !1 === c.right ? this.width : f.right + c.right,
                        top: !1 === c.top ? 0 : f.top - c.top,
                        bottom: !1 === c.bottom ? this.height : f.bottom + c.bottom
                    }), s.controller.draw(), u && ms(o), m.cancelable = !1, this.notifyPlugins("afterDatasetDraw", m))
                }
                isPointInArea(s) {
                    return ai(s, this.chartArea, this._minPadding)
                }
                getElementsAtEventForMode(s, o, c, u) {
                    const f = Uo.modes[o];
                    return "function" == typeof f ? f(this, s, c, u) : []
                }
                getDatasetMeta(s) {
                    const o = this.data.datasets[s],
                        c = this._metasets;
                    let u = c.filter(f => f && f._dataset === o).pop();
                    return u || (u = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: o && o.order || 0,
                        index: s,
                        _dataset: o,
                        _parsed: [],
                        _sorted: !1
                    }, c.push(u)), u
                }
                getContext() {
                    return this.$context || (this.$context = wi(null, {
                        chart: this,
                        type: "chart"
                    }))
                }
                getVisibleDatasetCount() {
                    return this.getSortedVisibleDatasetMetas().length
                }
                isDatasetVisible(s) {
                    const o = this.data.datasets[s];
                    if (!o) return !1;
                    const c = this.getDatasetMeta(s);
                    return "boolean" == typeof c.hidden ? !c.hidden : !o.hidden
                }
                setDatasetVisibility(s, o) {
                    this.getDatasetMeta(s).hidden = !o
                }
                toggleDataVisibility(s) {
                    this._hiddenIndices[s] = !this._hiddenIndices[s]
                }
                getDataVisibility(s) {
                    return !this._hiddenIndices[s]
                }
                _updateVisibility(s, o, c) {
                    const u = c ? "show" : "hide",
                        f = this.getDatasetMeta(s),
                        m = f.controller._resolveAnimations(void 0, u);
                    Qe(o) ? (f.data[o].hidden = !c, this.update()) : (this.setDatasetVisibility(s, c), m.update(f, {
                        visible: c
                    }), this.update(y => y.datasetIndex === s ? u : void 0))
                }
                hide(s, o) {
                    this._updateVisibility(s, o, !1)
                }
                show(s, o) {
                    this._updateVisibility(s, o, !0)
                }
                _destroyDatasetMeta(s) {
                    const o = this._metasets[s];
                    o && o.controller && o.controller._destroy(), delete this._metasets[s]
                }
                _stop() {
                    let s, o;
                    for (this.stop(), ni.remove(this), s = 0, o = this.data.datasets.length; s < o; ++s) this._destroyDatasetMeta(s)
                }
                destroy() {
                    this.notifyPlugins("beforeDestroy");
                    const {
                        canvas: s,
                        ctx: o
                    } = this;
                    this._stop(), this.config.clearCache(), s && (this.unbindEvents(), xa(s, o), this.platform.releaseContext(o), this.canvas = null, this.ctx = null), delete Ls[this.id], this.notifyPlugins("afterDestroy")
                }
                toBase64Image(...s) {
                    return this.canvas.toDataURL(...s)
                }
                bindEvents() {
                    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
                }
                bindUserEvents() {
                    const s = this._listeners,
                        o = this.platform,
                        c = (f, m) => {
                            o.addEventListener(this, f, m), s[f] = m
                        },
                        u = (f, m, y) => {
                            f.offsetX = m, f.offsetY = y, this._eventHandler(f)
                        };
                    Yt(this.options.events, f => c(f, u))
                }
                bindResponsiveEvents() {
                    this._responsiveListeners || (this._responsiveListeners = {});
                    const s = this._responsiveListeners,
                        o = this.platform,
                        c = (A, L) => {
                            o.addEventListener(this, A, L), s[A] = L
                        },
                        u = (A, L) => {
                            s[A] && (o.removeEventListener(this, A, L), delete s[A])
                        },
                        f = (A, L) => {
                            this.canvas && this.resize(A, L)
                        };
                    let m;
                    const y = () => {
                        u("attach", y), this.attached = !0, this.resize(), c("resize", f), c("detach", m)
                    };
                    m = () => {
                        this.attached = !1, u("resize", f), this._stop(), this._resize(0, 0), c("attach", y)
                    }, o.isAttached(this.canvas) ? y() : m()
                }
                unbindEvents() {
                    Yt(this._listeners, (s, o) => {
                        this.platform.removeEventListener(this, o, s)
                    }), this._listeners = {}, Yt(this._responsiveListeners, (s, o) => {
                        this.platform.removeEventListener(this, o, s)
                    }), this._responsiveListeners = void 0
                }
                updateHoverStyle(s, o, c) {
                    const u = c ? "set" : "remove";
                    let f, m, y, A;
                    for ("dataset" === o && (f = this.getDatasetMeta(s[0].datasetIndex), f.controller["_" + u + "DatasetHoverStyle"]()), y = 0, A = s.length; y < A; ++y) {
                        m = s[y];
                        const L = m && this.getDatasetMeta(m.datasetIndex).controller;
                        L && L[u + "HoverStyle"](m.element, m.datasetIndex, m.index)
                    }
                }
                getActiveElements() {
                    return this._active || []
                }
                setActiveElements(s) {
                    const o = this._active || [],
                        c = s.map(({
                            datasetIndex: f,
                            index: m
                        }) => {
                            const y = this.getDatasetMeta(f);
                            if (!y) throw new Error("No dataset found at index " + f);
                            return {
                                datasetIndex: f,
                                element: y.data[m],
                                index: m
                            }
                        });
                    !xi(c, o) && (this._active = c, this._lastEvent = null, this._updateHoverStyles(c, o))
                }
                notifyPlugins(s, o, c) {
                    return this._plugins.notify(this, s, o, c)
                }
                isPluginEnabled(s) {
                    return 1 === this._plugins._cache.filter(o => o.plugin.id === s).length
                }
                _updateHoverStyles(s, o, c) {
                    const u = this.options.hover,
                        f = (A, L) => A.filter(O => !L.some(z => O.datasetIndex === z.datasetIndex && O.index === z.index)),
                        m = f(o, s),
                        y = c ? s : f(s, o);
                    m.length && this.updateHoverStyle(m, u.mode, !1), y.length && u.mode && this.updateHoverStyle(y, u.mode, !0)
                }
                _eventHandler(s, o) {
                    const c = {
                            event: s,
                            replay: o,
                            cancelable: !0,
                            inChartArea: this.isPointInArea(s)
                        },
                        u = m => (m.options.events || this.options.events).includes(s.native.type);
                    if (!1 === this.notifyPlugins("beforeEvent", c, u)) return;
                    const f = this._handleEvent(s, o, c.inChartArea);
                    return c.cancelable = !1, this.notifyPlugins("afterEvent", c, u), (f || c.changed) && this.render(), this
                }
                _handleEvent(s, o, c) {
                    const {
                        _active: u = [],
                        options: f
                    } = this, y = this._getActiveElements(s, u, c, o), A = function Gi(n) {
                        return "mouseup" === n.type || "click" === n.type || "contextmenu" === n.type
                    }(s), L = function ql(n, a, s, o) {
                        return s && "mouseout" !== n.type ? o ? a : n : null
                    }(s, this._lastEvent, c, A);
                    c && (this._lastEvent = null, qt(f.onHover, [s, y, this], this), A && qt(f.onClick, [s, y, this], this));
                    const O = !xi(y, u);
                    return (O || o) && (this._active = y, this._updateHoverStyles(y, u, o)), this._lastEvent = L, O
                }
                _getActiveElements(s, o, c, u) {
                    if ("mouseout" === s.type) return [];
                    if (!c) return o;
                    const f = this.options.hover;
                    return this.getElementsAtEventForMode(s, f.mode, f, u)
                }
            })();

            function Mn() {
                return Yt(Ts.instances, n => n._plugins.invalidate())
            }

            function $i(n, a, s, o) {
                return {
                    x: s + n * Math.cos(a),
                    y: o + n * Math.sin(a)
                }
            }

            function Os(n, a, s, o, c, u) {
                const {
                    x: f,
                    y: m,
                    startAngle: y,
                    pixelMargin: A,
                    innerRadius: L
                } = a, O = Math.max(a.outerRadius + o + s - A, 0), z = L > 0 ? L + o + s + A : 0;
                let B = 0;
                const V = c - y;
                if (o) {
                    const he = ((L > 0 ? L - o : 0) + (O > 0 ? O - o : 0)) / 2;
                    B = (V - (0 !== he ? V * he / (he + o) : V)) / 2
                }
                const Z = (V - Math.max(.001, V * O - s / jt) / O) / 2,
                    tt = y + Z + B,
                    J = c - Z - B,
                    {
                        outerStart: dt,
                        outerEnd: pt,
                        innerStart: nt,
                        innerEnd: ft
                    } = function th(n, a, s, o) {
                        const c = function Jl(n) {
                                return Hs(n, ["outerStart", "outerEnd", "innerStart", "innerEnd"])
                            }(n.options.borderRadius),
                            u = (s - a) / 2,
                            f = Math.min(u, o * a / 2),
                            m = y => {
                                const A = (s - Math.min(u, y)) * o / 2;
                                return Mt(y, 0, Math.min(u, A))
                            };
                        return {
                            outerStart: m(c.outerStart),
                            outerEnd: m(c.outerEnd),
                            innerStart: Mt(c.innerStart, 0, f),
                            innerEnd: Mt(c.innerEnd, 0, f)
                        }
                    }(a, z, O, J - tt),
                    At = O - dt,
                    vt = O - pt,
                    St = tt + dt / At,
                    It = J - pt / vt,
                    Ot = z + nt,
                    Ht = z + ft,
                    me = tt + nt / Ot,
                    Ie = J - ft / Ht;
                if (n.beginPath(), u) {
                    const se = (St + It) / 2;
                    if (n.arc(f, m, O, St, se), n.arc(f, m, O, se, It), pt > 0) {
                        const ke = $i(vt, It, f, m);
                        n.arc(ke.x, ke.y, pt, It, J + Y)
                    }
                    const oe = $i(Ht, J, f, m);
                    if (n.lineTo(oe.x, oe.y), ft > 0) {
                        const ke = $i(Ht, Ie, f, m);
                        n.arc(ke.x, ke.y, ft, J + Y, Ie + Math.PI)
                    }
                    const he = (J - ft / z + (tt + nt / z)) / 2;
                    if (n.arc(f, m, z, J - ft / z, he, !0), n.arc(f, m, z, he, tt + nt / z, !0), nt > 0) {
                        const ke = $i(Ot, me, f, m);
                        n.arc(ke.x, ke.y, nt, me + Math.PI, tt - Y)
                    }
                    const Ge = $i(At, tt, f, m);
                    if (n.lineTo(Ge.x, Ge.y), dt > 0) {
                        const ke = $i(At, St, f, m);
                        n.arc(ke.x, ke.y, dt, tt - Y, St)
                    }
                } else {
                    n.moveTo(f, m);
                    const se = Math.cos(St) * O + f,
                        oe = Math.sin(St) * O + m;
                    n.lineTo(se, oe);
                    const he = Math.cos(It) * O + f,
                        Ge = Math.sin(It) * O + m;
                    n.lineTo(he, Ge)
                }
                n.closePath()
            }

            function Pn(n, a, s = a) {
                n.lineCap = Ct(s.borderCapStyle, a.borderCapStyle), n.setLineDash(Ct(s.borderDash, a.borderDash)), n.lineDashOffset = Ct(s.borderDashOffset, a.borderDashOffset), n.lineJoin = Ct(s.borderJoinStyle, a.borderJoinStyle), n.lineWidth = Ct(s.borderWidth, a.borderWidth), n.strokeStyle = Ct(s.borderColor, a.borderColor)
            }

            function ah(n, a, s) {
                n.lineTo(s.x, s.y)
            }

            function Ln(n, a, s = {}) {
                const o = n.length,
                    {
                        start: c = 0,
                        end: u = o - 1
                    } = s,
                    {
                        start: f,
                        end: m
                    } = a,
                    y = Math.max(c, f),
                    A = Math.min(u, m);
                return {
                    count: o,
                    start: y,
                    loop: a.loop,
                    ilen: A < y && !(c < f && u < f || c > m && u > m) ? o + A - y : A - y
                }
            }

            function rh(n, a, s, o) {
                const {
                    points: c,
                    options: u
                } = a, {
                    count: f,
                    start: m,
                    loop: y,
                    ilen: A
                } = Ln(c, s, o), L = function nh(n) {
                    return n.stepped ? Ar : n.tension || "monotone" === n.cubicInterpolationMode ? Sr : ah
                }(u);
                let B, V, G, {
                    move: O = !0,
                    reverse: z
                } = o || {};
                for (B = 0; B <= A; ++B) V = c[(m + (z ? A - B : B)) % f], !V.skip && (O ? (n.moveTo(V.x, V.y), O = !1) : L(n, G, V, z, u.stepped), G = V);
                return y && (V = c[(m + (z ? A : 0)) % f], L(n, G, V, z, u.stepped)), !!y
            }

            function oh(n, a, s, o) {
                const c = a.points,
                    {
                        count: u,
                        start: f,
                        ilen: m
                    } = Ln(c, s, o),
                    {
                        move: y = !0,
                        reverse: A
                    } = o || {};
                let z, B, V, G, Z, tt, L = 0,
                    O = 0;
                const J = pt => (f + (A ? m - pt : pt)) % u,
                    dt = () => {
                        G !== Z && (n.lineTo(L, Z), n.lineTo(L, G), n.lineTo(L, tt))
                    };
                for (y && (B = c[J(0)], n.moveTo(B.x, B.y)), z = 0; z <= m; ++z) {
                    if (B = c[J(z)], B.skip) continue;
                    const pt = B.x,
                        nt = B.y,
                        ft = 0 | pt;
                    ft === V ? (nt < G ? G = nt : nt > Z && (Z = nt), L = (O * L + pt) / ++O) : (dt(), n.lineTo(pt, nt), V = ft, O = 0, G = Z = nt), tt = nt
                }
                dt()
            }

            function ia(n) {
                const a = n.options;
                return n._decimated || n._loop || a.tension || "monotone" === a.cubicInterpolationMode || a.stepped || a.borderDash && a.borderDash.length ? rh : oh
            }
            const dh = "function" == typeof Path2D;
            let Es = (() => class n extends ri {
                static id = "line";
                static defaults = {
                    borderCapStyle: "butt",
                    borderDash: [],
                    borderDashOffset: 0,
                    borderJoinStyle: "miter",
                    borderWidth: 3,
                    capBezierPoints: !0,
                    cubicInterpolationMode: "default",
                    fill: !1,
                    spanGaps: !1,
                    stepped: !1,
                    tension: 0
                };
                static defaultRoutes = {
                    backgroundColor: "backgroundColor",
                    borderColor: "borderColor"
                };
                static descriptors = {
                    _scriptable: !0,
                    _indexable: s => "borderDash" !== s && "fill" !== s
                };
                constructor(s) {
                    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, s && Object.assign(this, s)
                }
                updateControlPoints(s, o) {
                    const c = this.options;
                    !c.tension && "monotone" !== c.cubicInterpolationMode || c.stepped || this._pointsUpdated || (Zr(this._points, c, s, c.spanGaps ? this._loop : this._fullLoop, o), this._pointsUpdated = !0)
                }
                set points(s) {
                    this._points = s, delete this._segments, delete this._path, this._pointsUpdated = !1
                }
                get points() {
                    return this._points
                }
                get segments() {
                    return this._segments || (this._segments = function ho(n, a) {
                        const s = n.points,
                            o = n.options.spanGaps,
                            c = s.length;
                        if (!c) return [];
                        const u = !!n._loop,
                            {
                                start: f,
                                end: m
                            } = function oo(n, a, s, o) {
                                let c = 0,
                                    u = a - 1;
                                if (s && !o)
                                    for (; c < a && !n[c].skip;) c++;
                                for (; c < a && n[c].skip;) c++;
                                for (c %= a, s && (u += c); u > c && n[u % a].skip;) u--;
                                return u %= a, {
                                    start: c,
                                    end: u
                                }
                            }(s, c, u, o);
                        return function Ra(n, a, s, o) {
                            return o && o.setContext && s ? function co(n, a, s, o) {
                                const c = n._chart.getContext(),
                                    u = Fa(n.options),
                                    {
                                        _datasetIndex: f,
                                        options: {
                                            spanGaps: m
                                        }
                                    } = n,
                                    y = s.length,
                                    A = [];
                                let L = u,
                                    O = a[0].start,
                                    z = O;

                                function B(V, G, Z, tt) {
                                    const J = m ? -1 : 1;
                                    if (V !== G) {
                                        for (V += y; s[V % y].skip;) V -= J;
                                        for (; s[G % y].skip;) G += J;
                                        V % y != G % y && (A.push({
                                            start: V % y,
                                            end: G % y,
                                            loop: Z,
                                            style: tt
                                        }), L = tt, O = G % y)
                                    }
                                }
                                for (const V of a) {
                                    O = m ? O : V.start;
                                    let Z, G = s[O % y];
                                    for (z = O + 1; z <= V.end; z++) {
                                        const tt = s[z % y];
                                        Z = Fa(o.setContext(wi(c, {
                                            type: "segment",
                                            p0: G,
                                            p1: tt,
                                            p0DataIndex: (z - 1) % y,
                                            p1DataIndex: z % y,
                                            datasetIndex: f
                                        }))), uo(Z, L) && B(O, z - 1, V.loop, L), G = tt, L = Z
                                    }
                                    O < z - 1 && B(O, z - 1, V.loop, L)
                                }
                                return A
                            }(n, a, s, o) : a
                        }(n, !0 === o ? [{
                            start: f,
                            end: m,
                            loop: u
                        }] : function lo(n, a, s, o) {
                            const c = n.length,
                                u = [];
                            let y, f = a,
                                m = n[a];
                            for (y = a + 1; y <= s; ++y) {
                                const A = n[y % c];
                                A.skip || A.stop ? m.skip || (u.push({
                                    start: a % c,
                                    end: (y - 1) % c,
                                    loop: o = !1
                                }), a = f = A.stop ? y : null) : (f = y, m.skip && (a = y)), m = A
                            }
                            return null !== f && u.push({
                                start: a % c,
                                end: f % c,
                                loop: o
                            }), u
                        }(s, f, m < f ? m + c : m, !!n._fullLoop && 0 === f && m === c - 1), s, a)
                    }(this, this.options.segment))
                }
                first() {
                    const s = this.segments;
                    return s.length && this.points[s[0].start]
                }
                last() {
                    const s = this.segments,
                        c = s.length;
                    return c && this.points[s[c - 1].end]
                }
                interpolate(s, o) {
                    const c = this.options,
                        u = s[o],
                        f = this.points,
                        m = za(this, {
                            property: o,
                            start: u,
                            end: u
                        });
                    if (!m.length) return;
                    const y = [],
                        A = function lh(n) {
                            return n.stepped ? io : n.tension || "monotone" === n.cubicInterpolationMode ? so : zi
                        }(c);
                    let L, O;
                    for (L = 0, O = m.length; L < O; ++L) {
                        const {
                            start: z,
                            end: B
                        } = m[L], V = f[z], G = f[B];
                        if (V === G) {
                            y.push(V);
                            continue
                        }
                        const tt = A(V, G, Math.abs((u - V[o]) / (G[o] - V[o])), c.stepped);
                        tt[o] = s[o], y.push(tt)
                    }
                    return 1 === y.length ? y[0] : y
                }
                pathSegment(s, o, c) {
                    return ia(this)(s, this, o, c)
                }
                path(s, o, c) {
                    const u = this.segments,
                        f = ia(this);
                    let m = this._loop;
                    o = o || 0, c = c || this.points.length - o;
                    for (const y of u) m &= f(s, this, y, {
                        start: o,
                        end: o + c - 1
                    });
                    return !!m
                }
                draw(s, o, c, u) {
                    (this.points || []).length && (this.options || {}).borderWidth && (s.save(), function uh(n, a, s, o) {
                        dh && !a.options.segment ? function hh(n, a, s, o) {
                            let c = a._path;
                            c || (c = a._path = new Path2D, a.path(c, s, o) && c.closePath()), Pn(n, a.options), n.stroke(c)
                        }(n, a, s, o) : function ch(n, a, s, o) {
                            const {
                                segments: c,
                                options: u
                            } = a, f = ia(a);
                            for (const m of c) Pn(n, u, m.style), n.beginPath(), f(n, a, m, {
                                start: s,
                                end: s + o - 1
                            }) && n.closePath(), n.stroke()
                        }(n, a, s, o)
                    }(s, this, c, u), s.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
                }
            })();

            function _n(n, a, s, o) {
                const c = n.options,
                    {
                        [s]: u
                    } = n.getProps([s], o);
                return Math.abs(a - u) < c.radius + c.hitRadius
            }
            let gh = (() => class n extends ri {
                static id = "point";
                parsed;
                skip;
                stop;
                static defaults = {
                    borderWidth: 1,
                    hitRadius: 1,
                    hoverBorderWidth: 1,
                    hoverRadius: 4,
                    pointStyle: "circle",
                    radius: 3,
                    rotation: 0
                };
                static defaultRoutes = {
                    backgroundColor: "backgroundColor",
                    borderColor: "borderColor"
                };
                constructor(s) {
                    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, s && Object.assign(this, s)
                }
                inRange(s, o, c) {
                    const u = this.options,
                        {
                            x: f,
                            y: m
                        } = this.getProps(["x", "y"], c);
                    return Math.pow(s - f, 2) + Math.pow(o - m, 2) < Math.pow(u.hitRadius + u.radius, 2)
                }
                inXRange(s, o) {
                    return _n(this, s, "x", o)
                }
                inYRange(s, o) {
                    return _n(this, s, "y", o)
                }
                getCenterPoint(s) {
                    const {
                        x: o,
                        y: c
                    } = this.getProps(["x", "y"], s);
                    return {
                        x: o,
                        y: c
                    }
                }
                size(s) {
                    let o = (s = s || this.options || {}).radius || 0;
                    return o = Math.max(o, o && s.hoverRadius || 0), 2 * (o + (o && s.borderWidth || 0))
                }
                draw(s, o) {
                    const c = this.options;
                    this.skip || c.radius < .1 || !ai(this, o, this.size(c) / 2) || (s.strokeStyle = c.borderColor, s.lineWidth = c.borderWidth, s.fillStyle = c.backgroundColor, Bs(s, c, this.x, this.y))
                }
                getRange() {
                    const s = this.options || {};
                    return s.radius + s.hitRadius
                }
            })();

            function Tn(n, a) {
                const {
                    x: s,
                    y: o,
                    base: c,
                    width: u,
                    height: f
                } = n.getProps(["x", "y", "base", "width", "height"], a);
                let m, y, A, L, O;
                return n.horizontal ? (O = f / 2, m = Math.min(s, c), y = Math.max(s, c), A = o - O, L = o + O) : (O = u / 2, m = s - O, y = s + O, A = Math.min(o, c), L = Math.max(o, c)), {
                    left: m,
                    top: A,
                    right: y,
                    bottom: L
                }
            }

            function Ai(n, a, s, o) {
                return n ? 0 : Mt(a, s, o)
            }

            function sa(n, a, s, o) {
                const c = null === a,
                    u = null === s,
                    m = n && !(c && u) && Tn(n, o);
                return m && (c || t(a, m.left, m.right)) && (u || t(s, m.top, m.bottom))
            }

            function bh(n, a) {
                n.rect(a.x, a.y, a.w, a.h)
            }

            function aa(n, a, s = {}) {
                const o = n.x !== s.x ? -a : 0,
                    c = n.y !== s.y ? -a : 0;
                return {
                    x: n.x + o,
                    y: n.y + c,
                    w: n.w + ((n.x + n.w !== s.x + s.w ? a : 0) - o),
                    h: n.h + ((n.y + n.h !== s.y + s.h ? a : 0) - c),
                    radius: n.radius
                }
            }
            var yh = Object.freeze({
                __proto__: null,
                ArcElement: class sh extends ri {
                    static id = "arc";
                    static defaults = {
                        borderAlign: "center",
                        borderColor: "#fff",
                        borderDash: [],
                        borderDashOffset: 0,
                        borderJoinStyle: void 0,
                        borderRadius: 0,
                        borderWidth: 2,
                        offset: 0,
                        spacing: 0,
                        angle: void 0,
                        circular: !0
                    };
                    static defaultRoutes = {
                        backgroundColor: "backgroundColor"
                    };
                    static descriptors = {
                        _scriptable: !0,
                        _indexable: a => "borderDash" !== a
                    };
                    circumference;
                    endAngle;
                    fullCircles;
                    innerRadius;
                    outerRadius;
                    pixelMargin;
                    startAngle;
                    constructor(a) {
                        super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, a && Object.assign(this, a)
                    }
                    inRange(a, s, o) {
                        const c = this.getProps(["x", "y"], o),
                            {
                                angle: u,
                                distance: f
                            } = Te(c, {
                                x: a,
                                y: s
                            }),
                            {
                                startAngle: m,
                                endAngle: y,
                                innerRadius: A,
                                outerRadius: L,
                                circumference: O
                            } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], o),
                            z = (this.options.spacing + this.options.borderWidth) / 2,
                            V = Ct(O, y - m) >= W || Lt(u, m, y),
                            G = t(f, A + z, L + z);
                        return V && G
                    }
                    getCenterPoint(a) {
                        const {
                            x: s,
                            y: o,
                            startAngle: c,
                            endAngle: u,
                            innerRadius: f,
                            outerRadius: m
                        } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], a), {
                            offset: y,
                            spacing: A
                        } = this.options, L = (c + u) / 2, O = (f + m + A + y) / 2;
                        return {
                            x: s + Math.cos(L) * O,
                            y: o + Math.sin(L) * O
                        }
                    }
                    tooltipPosition(a) {
                        return this.getCenterPoint(a)
                    }
                    draw(a) {
                        const {
                            options: s,
                            circumference: o
                        } = this, c = (s.offset || 0) / 4, u = (s.spacing || 0) / 2, f = s.circular;
                        if (this.pixelMargin = "inner" === s.borderAlign ? .33 : 0, this.fullCircles = o > W ? Math.floor(o / W) : 0, 0 === o || this.innerRadius < 0 || this.outerRadius < 0) return;
                        a.save();
                        const m = (this.startAngle + this.endAngle) / 2;
                        a.translate(Math.cos(m) * c, Math.sin(m) * c);
                        const A = c * (1 - Math.sin(Math.min(jt, o || 0)));
                        a.fillStyle = s.backgroundColor, a.strokeStyle = s.borderColor,
                            function eh(n, a, s, o, c) {
                                const {
                                    fullCircles: u,
                                    startAngle: f,
                                    circumference: m
                                } = a;
                                let y = a.endAngle;
                                if (u) {
                                    Os(n, a, s, o, y, c);
                                    for (let A = 0; A < u; ++A) n.fill();
                                    isNaN(m) || (y = f + (m % W || W))
                                }
                                Os(n, a, s, o, y, c), n.fill()
                            }(a, this, A, u, f),
                            function ih(n, a, s, o, c) {
                                const {
                                    fullCircles: u,
                                    startAngle: f,
                                    circumference: m,
                                    options: y
                                } = a, {
                                    borderWidth: A,
                                    borderJoinStyle: L,
                                    borderDash: O,
                                    borderDashOffset: z
                                } = y, B = "inner" === y.borderAlign;
                                if (!A) return;
                                n.setLineDash(O || []), n.lineDashOffset = z, B ? (n.lineWidth = 2 * A, n.lineJoin = L || "round") : (n.lineWidth = A, n.lineJoin = L || "bevel");
                                let V = a.endAngle;
                                if (u) {
                                    Os(n, a, s, o, V, c);
                                    for (let G = 0; G < u; ++G) n.stroke();
                                    isNaN(m) || (V = f + (m % W || W))
                                }
                                B && function Ql(n, a, s) {
                                    const {
                                        startAngle: o,
                                        pixelMargin: c,
                                        x: u,
                                        y: f,
                                        outerRadius: m,
                                        innerRadius: y
                                    } = a;
                                    let A = c / m;
                                    n.beginPath(), n.arc(u, f, m, o - A, s + A), y > c ? (A = c / y, n.arc(u, f, y, s + A, o - A, !0)) : n.arc(u, f, c, s + Y, o - Y), n.closePath(), n.clip()
                                }(n, a, V), u || (Os(n, a, s, o, V, c), n.stroke())
                            }(a, this, A, u, f), a.restore()
                    }
                },
                BarElement: class vh extends ri {
                    static id = "bar";
                    static defaults = {
                        borderSkipped: "start",
                        borderWidth: 0,
                        borderRadius: 0,
                        inflateAmount: "auto",
                        pointStyle: void 0
                    };
                    static defaultRoutes = {
                        backgroundColor: "backgroundColor",
                        borderColor: "borderColor"
                    };
                    constructor(a) {
                        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, a && Object.assign(this, a)
                    }
                    draw(a) {
                        const {
                            inflateAmount: s,
                            options: {
                                borderColor: o,
                                backgroundColor: c
                            }
                        } = this, {
                            inner: u,
                            outer: f
                        } = function xh(n) {
                            const a = Tn(n),
                                s = a.right - a.left,
                                o = a.bottom - a.top,
                                c = function fh(n, a, s) {
                                    const c = n.borderSkipped,
                                        u = ba(n.options.borderWidth);
                                    return {
                                        t: Ai(c.top, u.top, 0, s),
                                        r: Ai(c.right, u.right, 0, a),
                                        b: Ai(c.bottom, u.bottom, 0, s),
                                        l: Ai(c.left, u.left, 0, a)
                                    }
                                }(n, s / 2, o / 2),
                                u = function ph(n, a, s) {
                                    const {
                                        enableBorderRadius: o
                                    } = n.getProps(["enableBorderRadius"]), c = n.options.borderRadius, u = Ei(c), f = Math.min(a, s), m = n.borderSkipped, y = o || Tt(c);
                                    return {
                                        topLeft: Ai(!y || m.top || m.left, u.topLeft, 0, f),
                                        topRight: Ai(!y || m.top || m.right, u.topRight, 0, f),
                                        bottomLeft: Ai(!y || m.bottom || m.left, u.bottomLeft, 0, f),
                                        bottomRight: Ai(!y || m.bottom || m.right, u.bottomRight, 0, f)
                                    }
                                }(n, s / 2, o / 2);
                            return {
                                outer: {
                                    x: a.left,
                                    y: a.top,
                                    w: s,
                                    h: o,
                                    radius: u
                                },
                                inner: {
                                    x: a.left + c.l,
                                    y: a.top + c.t,
                                    w: s - c.l - c.r,
                                    h: o - c.t - c.b,
                                    radius: {
                                        topLeft: Math.max(0, u.topLeft - Math.max(c.t, c.l)),
                                        topRight: Math.max(0, u.topRight - Math.max(c.t, c.r)),
                                        bottomLeft: Math.max(0, u.bottomLeft - Math.max(c.b, c.l)),
                                        bottomRight: Math.max(0, u.bottomRight - Math.max(c.b, c.r))
                                    }
                                }
                            }
                        }(this), m = function mh(n) {
                            return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight
                        }(f.radius) ? ts : bh;
                        a.save(), (f.w !== u.w || f.h !== u.h) && (a.beginPath(), m(a, aa(f, s, u)), a.clip(), m(a, aa(u, -s, f)), a.fillStyle = o, a.fill("evenodd")), a.beginPath(), m(a, aa(u, s)), a.fillStyle = c, a.fill(), a.restore()
                    }
                    inRange(a, s, o) {
                        return sa(this, a, s, o)
                    }
                    inXRange(a, s) {
                        return sa(this, a, null, s)
                    }
                    inYRange(a, s) {
                        return sa(this, null, a, s)
                    }
                    getCenterPoint(a) {
                        const {
                            x: s,
                            y: o,
                            base: c,
                            horizontal: u
                        } = this.getProps(["x", "y", "base", "horizontal"], a);
                        return {
                            x: u ? (s + c) / 2 : s,
                            y: u ? o : (o + c) / 2
                        }
                    }
                    getRange(a) {
                        return "x" === a ? this.width / 2 : this.height / 2
                    }
                },
                LineElement: Es,
                PointElement: gh
            });
            const na = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"],
                On = na.map(n => n.replace("rgb(", "rgba(").replace(")", ", 0.5)"));

            function En(n) {
                return na[n % na.length]
            }

            function Dn(n) {
                return On[n % On.length]
            }

            function In(n) {
                let a;
                for (a in n)
                    if (n[a].borderColor || n[a].backgroundColor) return !0;
                return !1
            }
            var Mh = {
                id: "colors",
                defaults: {
                    enabled: !0,
                    forceOverride: !1
                },
                beforeLayout(n, a, s) {
                    if (!s.enabled) return;
                    const {
                        data: {
                            datasets: o
                        },
                        options: c
                    } = n.config, {
                        elements: u
                    } = c;
                    if (!s.forceOverride && (In(o) || function Ch(n) {
                            return n && (n.borderColor || n.backgroundColor)
                        }(c) || u && In(u))) return;
                    const f = function Sh(n) {
                        let a = 0;
                        return (s, o) => {
                            const c = n.getDatasetMeta(o).controller;
                            c instanceof $s ? a = function kh(n, a) {
                                return n.backgroundColor = n.data.map(() => En(a++)), a
                            }(s, a) : c instanceof Ka ? a = function Ah(n, a) {
                                return n.backgroundColor = n.data.map(() => Dn(a++)), a
                            }(s, a) : c && (a = function wh(n, a) {
                                return n.borderColor = En(a), n.backgroundColor = Dn(a), ++a
                            }(s, a))
                        }
                    }(n);
                    o.forEach(f)
                }
            };

            function zn(n) {
                if (n._decimated) {
                    const a = n._data;
                    delete n._decimated, delete n._data, Object.defineProperty(n, "data", {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        value: a
                    })
                }
            }

            function Rn(n) {
                n.data.datasets.forEach(a => {
                    zn(a)
                })
            }
            var Th = {
                id: "decimation",
                defaults: {
                    algorithm: "min-max",
                    enabled: !1
                },
                beforeElementsUpdate: (n, a, s) => {
                    if (!s.enabled) return void Rn(n);
                    const o = n.width;
                    n.data.datasets.forEach((c, u) => {
                        const {
                            _data: f,
                            indexAxis: m
                        } = c, y = n.getDatasetMeta(u), A = f || c.data;
                        if ("y" === es([m, n.options.indexAxis]) || !y.controller.supportsDecimation) return;
                        const L = n.scales[y.xAxisID];
                        if ("linear" !== L.type && "time" !== L.type || n.options.parsing) return;
                        let V, {
                            start: O,
                            count: z
                        } = function _h(n, a) {
                            const s = a.length;
                            let c, o = 0;
                            const {
                                iScale: u
                            } = n, {
                                min: f,
                                max: m,
                                minDefined: y,
                                maxDefined: A
                            } = u.getUserBounds();
                            return y && (o = Mt(i(a, u.axis, f).lo, 0, s - 1)), c = A ? Mt(i(a, u.axis, m).hi + 1, o, s) - o : s - o, {
                                start: o,
                                count: c
                            }
                        }(y, A);
                        if (z <= (s.threshold || 4 * o)) zn(c);
                        else {
                            switch (zt(f) && (c._data = A, delete c.data, Object.defineProperty(c, "data", {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    return this._decimated
                                },
                                set: function(G) {
                                    this._data = G
                                }
                            })), s.algorithm) {
                                case "lttb":
                                    V = function Ph(n, a, s, o, c) {
                                        const u = c.samples || o;
                                        if (u >= s) return n.slice(a, a + s);
                                        const f = [],
                                            m = (s - 2) / (u - 2);
                                        let y = 0;
                                        const A = a + s - 1;
                                        let O, z, B, V, G, L = a;
                                        for (f[y++] = n[L], O = 0; O < u - 2; O++) {
                                            let J, Z = 0,
                                                tt = 0;
                                            const dt = Math.floor((O + 1) * m) + 1 + a,
                                                pt = Math.min(Math.floor((O + 2) * m) + 1, s) + a,
                                                nt = pt - dt;
                                            for (J = dt; J < pt; J++) Z += n[J].x, tt += n[J].y;
                                            Z /= nt, tt /= nt;
                                            const ft = Math.floor(O * m) + 1 + a,
                                                At = Math.min(Math.floor((O + 1) * m) + 1, s) + a,
                                                {
                                                    x: vt,
                                                    y: St
                                                } = n[L];
                                            for (B = V = -1, J = ft; J < At; J++) V = .5 * Math.abs((vt - Z) * (n[J].y - St) - (vt - n[J].x) * (tt - St)), V > B && (B = V, z = n[J], G = J);
                                            f[y++] = z, L = G
                                        }
                                        return f[y++] = n[A], f
                                    }(A, O, z, o, s);
                                    break;
                                case "min-max":
                                    V = function Lh(n, a, s, o) {
                                        let f, m, y, A, L, O, z, B, V, G, c = 0,
                                            u = 0;
                                        const Z = [],
                                            J = n[a].x,
                                            pt = n[a + s - 1].x - J;
                                        for (f = a; f < a + s; ++f) {
                                            m = n[f], y = (m.x - J) / pt * o, A = m.y;
                                            const nt = 0 | y;
                                            if (nt === L) A < V ? (V = A, O = f) : A > G && (G = A, z = f), c = (u * c + m.x) / ++u;
                                            else {
                                                const ft = f - 1;
                                                if (!zt(O) && !zt(z)) {
                                                    const At = Math.min(O, z),
                                                        vt = Math.max(O, z);
                                                    At !== B && At !== ft && Z.push({ ...n[At],
                                                        x: c
                                                    }), vt !== B && vt !== ft && Z.push({ ...n[vt],
                                                        x: c
                                                    })
                                                }
                                                f > 0 && ft !== B && Z.push(n[ft]), Z.push(m), L = nt, u = 0, V = G = A, O = z = B = f
                                            }
                                        }
                                        return Z
                                    }(A, O, z, o);
                                    break;
                                default:
                                    throw new Error(`Unsupported decimation algorithm '${s.algorithm}'`)
                            }
                            c._decimated = V
                        }
                    })
                },
                destroy(n) {
                    Rn(n)
                }
            };

            function ra(n, a, s, o) {
                if (o) return;
                let c = a[n],
                    u = s[n];
                return "angle" === n && (c = Wt(c), u = Wt(u)), {
                    property: n,
                    start: c,
                    end: u
                }
            }

            function oa(n, a, s) {
                for (; a > n; a--) {
                    const o = s[a];
                    if (!isNaN(o.x) && !isNaN(o.y)) break
                }
                return a
            }

            function Fn(n, a, s, o) {
                return n && a ? o(n[s], a[s]) : n ? n[s] : a ? a[s] : 0
            }

            function Xn(n, a) {
                let s = [],
                    o = !1;
                return Qt(n) ? (o = !0, s = n) : s = function Eh(n, a) {
                    const {
                        x: s = null,
                        y: o = null
                    } = n || {}, c = a.points, u = [];
                    return a.segments.forEach(({
                        start: f,
                        end: m
                    }) => {
                        m = oa(f, m, c);
                        const y = c[f],
                            A = c[m];
                        null !== o ? (u.push({
                            x: y.x,
                            y: o
                        }), u.push({
                            x: A.x,
                            y: o
                        })) : null !== s && (u.push({
                            x: s,
                            y: y.y
                        }), u.push({
                            x: s,
                            y: A.y
                        }))
                    }), u
                }(n, a), s.length ? new Es({
                    points: s,
                    options: {
                        tension: 0
                    },
                    _loop: o,
                    _fullLoop: o
                }) : null
            }

            function Nn(n) {
                return n && !1 !== n.fill
            }

            function Dh(n, a, s) {
                let c = n[a].fill;
                const u = [a];
                let f;
                if (!s) return c;
                for (; !1 !== c && -1 === u.indexOf(c);) {
                    if (!$t(c)) return c;
                    if (f = n[c], !f) return !1;
                    if (f.visible) return c;
                    u.push(c), c = f.fill
                }
                return !1
            }

            function Ih(n, a, s) {
                const o = function Xh(n) {
                    const a = n.options,
                        s = a.fill;
                    let o = Ct(s && s.target, s);
                    return void 0 === o && (o = !!a.backgroundColor), !1 !== o && null !== o && (!0 === o ? "origin" : o)
                }(n);
                if (Tt(o)) return !isNaN(o.value) && o;
                let c = parseFloat(o);
                return $t(c) && Math.floor(c) === c ? function zh(n, a, s, o) {
                    return ("-" === n || "+" === n) && (s = a + s), !(s === a || s < 0 || s >= o) && s
                }(o[0], a, c, s) : ["origin", "start", "end", "stack", "shape"].indexOf(o) >= 0 && o
            }

            function Hh(n, a, s) {
                const o = [];
                for (let c = 0; c < s.length; c++) {
                    const u = s[c],
                        {
                            first: f,
                            last: m,
                            point: y
                        } = Yh(u, a, "x");
                    if (!(!y || f && m))
                        if (f) o.unshift(y);
                        else if (n.push(y), !m) break
                }
                n.push(...o)
            }

            function Yh(n, a, s) {
                const o = n.interpolate(a, s);
                if (!o) return {};
                const c = o[s],
                    u = n.segments,
                    f = n.points;
                let m = !1,
                    y = !1;
                for (let A = 0; A < u.length; A++) {
                    const L = u[A],
                        O = f[L.start][s],
                        z = f[L.end][s];
                    if (t(c, O, z)) {
                        m = c === O, y = c === z;
                        break
                    }
                }
                return {
                    first: m,
                    last: y,
                    point: o
                }
            }
            class Bn {
                constructor(a) {
                    this.x = a.x, this.y = a.y, this.radius = a.radius
                }
                pathSegment(a, s, o) {
                    const {
                        x: c,
                        y: u,
                        radius: f
                    } = this;
                    return a.arc(c, u, f, (s = s || {
                        start: 0,
                        end: W
                    }).end, s.start, !0), !o.bounds
                }
                interpolate(a) {
                    const {
                        x: s,
                        y: o,
                        radius: c
                    } = this, u = a.angle;
                    return {
                        x: s + Math.cos(u) * c,
                        y: o + Math.sin(u) * c,
                        angle: u
                    }
                }
            }

            function la(n, a, s) {
                const o = function Wh(n) {
                        const {
                            chart: a,
                            fill: s,
                            line: o
                        } = n;
                        if ($t(s)) return function Vh(n, a) {
                            const s = n.getDatasetMeta(a);
                            return s && n.isDatasetVisible(a) ? s.dataset : null
                        }(a, s);
                        if ("stack" === s) return function Nh(n) {
                            const {
                                scale: a,
                                index: s,
                                line: o
                            } = n, c = [], u = o.segments, f = o.points, m = function Bh(n, a) {
                                const s = [],
                                    o = n.getMatchingVisibleMetas("line");
                                for (let c = 0; c < o.length; c++) {
                                    const u = o[c];
                                    if (u.index === a) break;
                                    u.hidden || s.unshift(u.dataset)
                                }
                                return s
                            }(a, s);
                            m.push(Xn({
                                x: null,
                                y: a.bottom
                            }, o));
                            for (let y = 0; y < u.length; y++) {
                                const A = u[y];
                                for (let L = A.start; L <= A.end; L++) Hh(c, f[L], m)
                            }
                            return new Es({
                                points: c,
                                options: {}
                            })
                        }(n);
                        if ("shape" === s) return !0;
                        const c = function Gh(n) {
                            return (n.scale || {}).getPointPositionForValue ? function Uh(n) {
                                const {
                                    scale: a,
                                    fill: s
                                } = n, o = a.options, c = a.getLabels().length, u = o.reverse ? a.max : a.min, f = function Fh(n, a, s) {
                                    let o;
                                    return o = "start" === n ? s : "end" === n ? a.options.reverse ? a.min : a.max : Tt(n) ? n.value : a.getBaseValue(), o
                                }(s, a, u), m = [];
                                if (o.grid.circular) {
                                    const y = a.getPointPositionForValue(0, u);
                                    return new Bn({
                                        x: y.x,
                                        y: y.y,
                                        radius: a.getDistanceFromCenterForValue(f)
                                    })
                                }
                                for (let y = 0; y < c; ++y) m.push(a.getPointPositionForValue(y, f));
                                return m
                            }(n) : function jh(n) {
                                const {
                                    scale: a = {},
                                    fill: s
                                } = n, o = function Rh(n, a) {
                                    let s = null;
                                    return "start" === n ? s = a.bottom : "end" === n ? s = a.top : Tt(n) ? s = a.getPixelForValue(n.value) : a.getBasePixel && (s = a.getBasePixel()), s
                                }(s, a);
                                if ($t(o)) {
                                    const c = a.isHorizontal();
                                    return {
                                        x: c ? o : null,
                                        y: c ? null : o
                                    }
                                }
                                return null
                            }(n)
                        }(n);
                        return c instanceof Bn ? c : Xn(c, o)
                    }(a),
                    {
                        line: c,
                        scale: u,
                        axis: f
                    } = a,
                    m = c.options,
                    y = m.fill,
                    A = m.backgroundColor,
                    {
                        above: L = A,
                        below: O = A
                    } = y || {};
                o && c.points.length && (xs(n, s), function Zh(n, a) {
                    const {
                        line: s,
                        target: o,
                        above: c,
                        below: u,
                        area: f,
                        scale: m
                    } = a, y = s._loop ? "angle" : a.axis;
                    n.save(), "x" === y && u !== c && (Hn(n, o, f.top), Yn(n, {
                        line: s,
                        target: o,
                        color: c,
                        scale: m,
                        property: y
                    }), n.restore(), n.save(), Hn(n, o, f.bottom)), Yn(n, {
                        line: s,
                        target: o,
                        color: u,
                        scale: m,
                        property: y
                    }), n.restore()
                }(n, {
                    line: c,
                    target: o,
                    above: L,
                    below: O,
                    area: s,
                    scale: u,
                    axis: f
                }), ms(n))
            }

            function Hn(n, a, s) {
                const {
                    segments: o,
                    points: c
                } = a;
                let u = !0,
                    f = !1;
                n.beginPath();
                for (const m of o) {
                    const {
                        start: y,
                        end: A
                    } = m, L = c[y], O = c[oa(y, A, c)];
                    u ? (n.moveTo(L.x, L.y), u = !1) : (n.lineTo(L.x, s), n.lineTo(L.x, L.y)), f = !!a.pathSegment(n, m, {
                        move: f
                    }), f ? n.closePath() : n.lineTo(O.x, s)
                }
                n.lineTo(a.first().x, s), n.closePath(), n.clip()
            }

            function Yn(n, a) {
                const {
                    line: s,
                    target: o,
                    property: c,
                    color: u,
                    scale: f
                } = a, m = function Oh(n, a, s) {
                    const o = n.segments,
                        c = n.points,
                        u = a.points,
                        f = [];
                    for (const m of o) {
                        let {
                            start: y,
                            end: A
                        } = m;
                        A = oa(y, A, c);
                        const L = ra(s, c[y], c[A], m.loop);
                        if (!a.segments) {
                            f.push({
                                source: m,
                                target: L,
                                start: c[y],
                                end: c[A]
                            });
                            continue
                        }
                        const O = za(a, L);
                        for (const z of O) {
                            const B = ra(s, u[z.start], u[z.end], z.loop),
                                V = Ia(m, c, B);
                            for (const G of V) f.push({
                                source: G,
                                target: z,
                                start: {
                                    [s]: Fn(L, B, "start", Math.max)
                                },
                                end: {
                                    [s]: Fn(L, B, "end", Math.min)
                                }
                            })
                        }
                    }
                    return f
                }(s, o, c);
                for (const {
                        source: y,
                        target: A,
                        start: L,
                        end: O
                    } of m) {
                    const {
                        style: {
                            backgroundColor: z = u
                        } = {}
                    } = y, B = !0 !== o;
                    n.save(), n.fillStyle = z, $h(n, f, B && ra(c, L, O)), n.beginPath();
                    const V = !!s.pathSegment(n, y);
                    let G;
                    if (B) {
                        V ? n.closePath() : Wn(n, o, O, c);
                        const Z = !!o.pathSegment(n, A, {
                            move: V,
                            reverse: !0
                        });
                        G = V && Z, G || Wn(n, o, L, c)
                    }
                    n.closePath(), n.fill(G ? "evenodd" : "nonzero"), n.restore()
                }
            }

            function $h(n, a, s) {
                const {
                    top: o,
                    bottom: c
                } = a.chart.chartArea, {
                    property: u,
                    start: f,
                    end: m
                } = s || {};
                "x" === u && (n.beginPath(), n.rect(f, o, m - f, c - o), n.clip())
            }

            function Wn(n, a, s, o) {
                const c = a.interpolate(s, o);
                c && n.lineTo(c.x, c.y)
            }
            var qh = {
                id: "filler",
                afterDatasetsUpdate(n, a, s) {
                    const o = (n.data.datasets || []).length,
                        c = [];
                    let u, f, m, y;
                    for (f = 0; f < o; ++f) u = n.getDatasetMeta(f), m = u.dataset, y = null, m && m.options && m instanceof Es && (y = {
                        visible: n.isDatasetVisible(f),
                        index: f,
                        fill: Ih(m, f, o),
                        chart: n,
                        axis: u.controller.options.indexAxis,
                        scale: u.vScale,
                        line: m
                    }), u.$filler = y, c.push(y);
                    for (f = 0; f < o; ++f) y = c[f], y && !1 !== y.fill && (y.fill = Dh(c, f, s.propagate))
                },
                beforeDraw(n, a, s) {
                    const o = "beforeDraw" === s.drawTime,
                        c = n.getSortedVisibleDatasetMetas(),
                        u = n.chartArea;
                    for (let f = c.length - 1; f >= 0; --f) {
                        const m = c[f].$filler;
                        m && (m.line.updateControlPoints(u, m.axis), o && m.fill && la(n.ctx, m, u))
                    }
                },
                beforeDatasetsDraw(n, a, s) {
                    if ("beforeDatasetsDraw" !== s.drawTime) return;
                    const o = n.getSortedVisibleDatasetMetas();
                    for (let c = o.length - 1; c >= 0; --c) {
                        const u = o[c].$filler;
                        Nn(u) && la(n.ctx, u, n.chartArea)
                    }
                },
                beforeDatasetDraw(n, a, s) {
                    const o = a.meta.$filler;
                    !Nn(o) || "beforeDatasetDraw" !== s.drawTime || la(n.ctx, o, n.chartArea)
                },
                defaults: {
                    propagate: !0,
                    drawTime: "beforeDatasetDraw"
                }
            };
            const Vn = (n, a) => {
                let {
                    boxHeight: s = a,
                    boxWidth: o = a
                } = n;
                return n.usePointStyle && (s = Math.min(s, a), o = n.pointStyleWidth || Math.min(o, a)), {
                    boxWidth: o,
                    boxHeight: s,
                    itemHeight: Math.max(a, s)
                }
            };
            class Gn extends ri {
                constructor(a) {
                    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
                }
                update(a, s, o) {
                    this.maxWidth = a, this.maxHeight = s, this._margins = o, this.setDimensions(), this.buildLabels(), this.fit()
                }
                setDimensions() {
                    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
                }
                buildLabels() {
                    const a = this.options.labels || {};
                    let s = qt(a.generateLabels, [this.chart], this) || [];
                    a.filter && (s = s.filter(o => a.filter(o, this.chart.data))), a.sort && (s = s.sort((o, c) => a.sort(o, c, this.chart.data))), this.options.reverse && s.reverse(), this.legendItems = s
                }
                fit() {
                    const {
                        options: a,
                        ctx: s
                    } = this;
                    if (!a.display) return void(this.width = this.height = 0);
                    const o = a.labels,
                        c = de(o.font),
                        u = c.size,
                        f = this._computeTitleHeight(),
                        {
                            boxWidth: m,
                            itemHeight: y
                        } = Vn(o, u);
                    let A, L;
                    s.font = c.string, this.isHorizontal() ? (A = this.maxWidth, L = this._fitRows(f, u, m, y) + 10) : (L = this.maxHeight, A = this._fitCols(f, c, m, y) + 10), this.width = Math.min(A, a.maxWidth || this.maxWidth), this.height = Math.min(L, a.maxHeight || this.maxHeight)
                }
                _fitRows(a, s, o, c) {
                    const {
                        ctx: u,
                        maxWidth: f,
                        options: {
                            labels: {
                                padding: m
                            }
                        }
                    } = this, y = this.legendHitBoxes = [], A = this.lineWidths = [0], L = c + m;
                    let O = a;
                    u.textAlign = "left", u.textBaseline = "middle";
                    let z = -1,
                        B = -L;
                    return this.legendItems.forEach((V, G) => {
                        const Z = o + s / 2 + u.measureText(V.text).width;
                        (0 === G || A[A.length - 1] + Z + 2 * m > f) && (O += L, A[A.length - (G > 0 ? 0 : 1)] = 0, B += L, z++), y[G] = {
                            left: 0,
                            top: B,
                            row: z,
                            width: Z,
                            height: c
                        }, A[A.length - 1] += Z + m
                    }), O
                }
                _fitCols(a, s, o, c) {
                    const {
                        ctx: u,
                        maxHeight: f,
                        options: {
                            labels: {
                                padding: m
                            }
                        }
                    } = this, y = this.legendHitBoxes = [], A = this.columnSizes = [], L = f - a;
                    let O = m,
                        z = 0,
                        B = 0,
                        V = 0,
                        G = 0;
                    return this.legendItems.forEach((Z, tt) => {
                        const {
                            itemWidth: J,
                            itemHeight: dt
                        } = function Qh(n, a, s, o, c) {
                            const u = function Jh(n, a, s, o) {
                                    let c = n.text;
                                    return c && "string" != typeof c && (c = c.reduce((u, f) => u.length > f.length ? u : f)), a + s.size / 2 + o.measureText(c).width
                                }(o, n, a, s),
                                f = function tc(n, a, s) {
                                    let o = n;
                                    return "string" != typeof a.text && (o = jn(a, s)), o
                                }(c, o, a.lineHeight);
                            return {
                                itemWidth: u,
                                itemHeight: f
                            }
                        }(o, s, u, Z, c);
                        tt > 0 && B + dt + 2 * m > L && (O += z + m, A.push({
                            width: z,
                            height: B
                        }), V += z + m, G++, z = B = 0), y[tt] = {
                            left: V,
                            top: B,
                            col: G,
                            width: J,
                            height: dt
                        }, z = Math.max(z, J), B += dt + m
                    }), O += z, A.push({
                        width: z,
                        height: B
                    }), O
                }
                adjustHitBoxes() {
                    if (!this.options.display) return;
                    const a = this._computeTitleHeight(),
                        {
                            legendHitBoxes: s,
                            options: {
                                align: o,
                                labels: {
                                    padding: c
                                },
                                rtl: u
                            }
                        } = this,
                        f = Zi(u, this.left, this.width);
                    if (this.isHorizontal()) {
                        let m = 0,
                            y = P(o, this.left + c, this.right - this.lineWidths[m]);
                        for (const A of s) m !== A.row && (m = A.row, y = P(o, this.left + c, this.right - this.lineWidths[m])), A.top += this.top + a + c, A.left = f.leftForLtr(f.x(y), A.width), y += A.width + c
                    } else {
                        let m = 0,
                            y = P(o, this.top + a + c, this.bottom - this.columnSizes[m].height);
                        for (const A of s) A.col !== m && (m = A.col, y = P(o, this.top + a + c, this.bottom - this.columnSizes[m].height)), A.top = y, A.left += this.left + c, A.left = f.leftForLtr(f.x(A.left), A.width), y += A.height + c
                    }
                }
                isHorizontal() {
                    return "top" === this.options.position || "bottom" === this.options.position
                }
                draw() {
                    if (this.options.display) {
                        const a = this.ctx;
                        xs(a, this), this._draw(), ms(a)
                    }
                }
                _draw() {
                    const {
                        options: a,
                        columnSizes: s,
                        lineWidths: o,
                        ctx: c
                    } = this, {
                        align: u,
                        labels: f
                    } = a, m = Xt.color, y = Zi(a.rtl, this.left, this.width), A = de(f.font), {
                        padding: L
                    } = f, O = A.size, z = O / 2;
                    let B;
                    this.drawTitle(), c.textAlign = y.textAlign("left"), c.textBaseline = "middle", c.lineWidth = .5, c.font = A.string;
                    const {
                        boxWidth: V,
                        boxHeight: G,
                        itemHeight: Z
                    } = Vn(f, O), dt = this.isHorizontal(), pt = this._computeTitleHeight();
                    B = dt ? {
                        x: P(u, this.left + L, this.right - o[0]),
                        y: this.top + L + pt,
                        line: 0
                    } : {
                        x: this.left + L,
                        y: P(u, this.top + pt + L, this.bottom - s[0].height),
                        line: 0
                    }, Ta(this.ctx, a.textDirection);
                    const nt = Z + L;
                    this.legendItems.forEach((ft, At) => {
                        c.strokeStyle = ft.fontColor, c.fillStyle = ft.fontColor;
                        const vt = c.measureText(ft.text).width,
                            St = y.textAlign(ft.textAlign || (ft.textAlign = f.textAlign)),
                            It = V + z + vt;
                        let Ot = B.x,
                            Ht = B.y;
                        y.setWidth(this.width), dt ? At > 0 && Ot + It + L > this.right && (Ht = B.y += nt, B.line++, Ot = B.x = P(u, this.left + L, this.right - o[B.line])) : At > 0 && Ht + nt > this.bottom && (Ot = B.x = Ot + s[B.line].width + L, B.line++, Ht = B.y = P(u, this.top + pt + L, this.bottom - s[B.line].height)),
                            function(ft, At, vt) {
                                if (isNaN(V) || V <= 0 || isNaN(G) || G < 0) return;
                                c.save();
                                const St = Ct(vt.lineWidth, 1);
                                if (c.fillStyle = Ct(vt.fillStyle, m), c.lineCap = Ct(vt.lineCap, "butt"), c.lineDashOffset = Ct(vt.lineDashOffset, 0), c.lineJoin = Ct(vt.lineJoin, "miter"), c.lineWidth = St, c.strokeStyle = Ct(vt.strokeStyle, m), c.setLineDash(Ct(vt.lineDash, [])), f.usePointStyle) {
                                    const It = {
                                            radius: G * Math.SQRT2 / 2,
                                            pointStyle: vt.pointStyle,
                                            rotation: vt.rotation,
                                            borderWidth: St
                                        },
                                        Ot = y.xPlus(ft, V / 2);
                                    ma(c, It, Ot, At + z, f.pointStyleWidth && V)
                                } else {
                                    const It = At + Math.max((O - G) / 2, 0),
                                        Ot = y.leftForLtr(ft, V),
                                        Ht = Ei(vt.borderRadius);
                                    c.beginPath(), Object.values(Ht).some(me => 0 !== me) ? ts(c, {
                                        x: Ot,
                                        y: It,
                                        w: V,
                                        h: G,
                                        radius: Ht
                                    }) : c.rect(Ot, It, V, G), c.fill(), 0 !== St && c.stroke()
                                }
                                c.restore()
                            }(y.x(Ot), Ht, ft), Ot = ((n, a, s, o) => n === (o ? "left" : "right") ? s : "center" === n ? (a + s) / 2 : a)(St, Ot + V + z, dt ? Ot + It : this.right, a.rtl),
                            function(ft, At, vt) {
                                Oi(c, vt.text, ft, At + Z / 2, A, {
                                    strikethrough: vt.hidden,
                                    textAlign: y.textAlign(vt.textAlign)
                                })
                            }(y.x(Ot), Ht, ft), dt ? B.x += It + L : B.y += "string" != typeof ft.text ? jn(ft, A.lineHeight) + L : nt
                    }), Oa(this.ctx, a.textDirection)
                }
                drawTitle() {
                    const a = this.options,
                        s = a.title,
                        o = de(s.font),
                        c = ye(s.padding);
                    if (!s.display) return;
                    const u = Zi(a.rtl, this.left, this.width),
                        f = this.ctx,
                        m = s.position,
                        A = c.top + o.size / 2;
                    let L, O = this.left,
                        z = this.width;
                    if (this.isHorizontal()) z = Math.max(...this.lineWidths), L = this.top + A, O = P(a.align, O, this.right - z);
                    else {
                        const V = this.columnSizes.reduce((G, Z) => Math.max(G, Z.height), 0);
                        L = A + P(a.align, this.top, this.bottom - V - a.labels.padding - this._computeTitleHeight())
                    }
                    const B = P(m, O, O + z);
                    f.textAlign = u.textAlign(C(m)), f.textBaseline = "middle", f.strokeStyle = s.color, f.fillStyle = s.color, f.font = o.string, Oi(f, s.text, B, L, o)
                }
                _computeTitleHeight() {
                    const a = this.options.title,
                        s = de(a.font),
                        o = ye(a.padding);
                    return a.display ? s.lineHeight + o.height : 0
                }
                _getLegendItemAt(a, s) {
                    let o, c, u;
                    if (t(a, this.left, this.right) && t(s, this.top, this.bottom))
                        for (u = this.legendHitBoxes, o = 0; o < u.length; ++o)
                            if (c = u[o], t(a, c.left, c.left + c.width) && t(s, c.top, c.top + c.height)) return this.legendItems[o];
                    return null
                }
                handleEvent(a) {
                    const s = this.options;
                    if (! function ec(n, a) {
                            return !(("mousemove" !== n && "mouseout" !== n || !a.onHover && !a.onLeave) && (!a.onClick || "click" !== n && "mouseup" !== n))
                        }(a.type, s)) return;
                    const o = this._getLegendItemAt(a.x, a.y);
                    if ("mousemove" === a.type || "mouseout" === a.type) {
                        const c = this._hoveredItem,
                            u = ((n, a) => null !== n && null !== a && n.datasetIndex === a.datasetIndex && n.index === a.index)(c, o);
                        c && !u && qt(s.onLeave, [a, c, this], this), this._hoveredItem = o, o && !u && qt(s.onHover, [a, o, this], this)
                    } else o && qt(s.onClick, [a, o, this], this)
                }
            }

            function jn(n, a) {
                return a * (n.text ? n.text.length : 0)
            }
            var ic = {
                id: "legend",
                _element: Gn,
                start(n, a, s) {
                    const o = n.legend = new Gn({
                        ctx: n.ctx,
                        options: s,
                        chart: n
                    });
                    we.configure(n, o, s), we.addBox(n, o)
                },
                stop(n) {
                    we.removeBox(n, n.legend), delete n.legend
                },
                beforeUpdate(n, a, s) {
                    const o = n.legend;
                    we.configure(n, o, s), o.options = s
                },
                afterUpdate(n) {
                    const a = n.legend;
                    a.buildLabels(), a.adjustHitBoxes()
                },
                afterEvent(n, a) {
                    a.replay || n.legend.handleEvent(a.event)
                },
                defaults: {
                    display: !0,
                    position: "top",
                    align: "center",
                    fullSize: !0,
                    reverse: !1,
                    weight: 1e3,
                    onClick(n, a, s) {
                        const o = a.datasetIndex,
                            c = s.chart;
                        c.isDatasetVisible(o) ? (c.hide(o), a.hidden = !0) : (c.show(o), a.hidden = !1)
                    },
                    onHover: null,
                    onLeave: null,
                    labels: {
                        color: n => n.chart.options.color,
                        boxWidth: 40,
                        padding: 10,
                        generateLabels(n) {
                            const a = n.data.datasets,
                                {
                                    labels: {
                                        usePointStyle: s,
                                        pointStyle: o,
                                        textAlign: c,
                                        color: u,
                                        useBorderRadius: f,
                                        borderRadius: m
                                    }
                                } = n.legend.options;
                            return n._getSortedDatasetMetas().map(y => {
                                const A = y.controller.getStyle(s ? 0 : void 0),
                                    L = ye(A.borderWidth);
                                return {
                                    text: a[y.index].label,
                                    fillStyle: A.backgroundColor,
                                    fontColor: u,
                                    hidden: !y.visible,
                                    lineCap: A.borderCapStyle,
                                    lineDash: A.borderDash,
                                    lineDashOffset: A.borderDashOffset,
                                    lineJoin: A.borderJoinStyle,
                                    lineWidth: (L.width + L.height) / 4,
                                    strokeStyle: A.borderColor,
                                    pointStyle: o || A.pointStyle,
                                    rotation: A.rotation,
                                    textAlign: c || A.textAlign,
                                    borderRadius: f && (m || A.borderRadius),
                                    datasetIndex: y.index
                                }
                            }, this)
                        }
                    },
                    title: {
                        color: n => n.chart.options.color,
                        display: !1,
                        position: "center",
                        text: ""
                    }
                },
                descriptors: {
                    _scriptable: n => !n.startsWith("on"),
                    labels: {
                        _scriptable: n => !["generateLabels", "filter", "sort"].includes(n)
                    }
                }
            };
            class ha extends ri {
                constructor(a) {
                    super(), this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
                }
                update(a, s) {
                    const o = this.options;
                    if (this.left = 0, this.top = 0, !o.display) return void(this.width = this.height = this.right = this.bottom = 0);
                    this.width = this.right = a, this.height = this.bottom = s;
                    const c = Qt(o.text) ? o.text.length : 1;
                    this._padding = ye(o.padding);
                    const u = c * de(o.font).lineHeight + this._padding.height;
                    this.isHorizontal() ? this.height = u : this.width = u
                }
                isHorizontal() {
                    const a = this.options.position;
                    return "top" === a || "bottom" === a
                }
                _drawArgs(a) {
                    const {
                        top: s,
                        left: o,
                        bottom: c,
                        right: u,
                        options: f
                    } = this, m = f.align;
                    let A, L, O, y = 0;
                    return this.isHorizontal() ? (L = P(m, o, u), O = s + a, A = u - o) : ("left" === f.position ? (L = o + a, O = P(m, c, s), y = -.5 * jt) : (L = u - a, O = P(m, s, c), y = .5 * jt), A = c - s), {
                        titleX: L,
                        titleY: O,
                        maxWidth: A,
                        rotation: y
                    }
                }
                draw() {
                    const a = this.ctx,
                        s = this.options;
                    if (!s.display) return;
                    const o = de(s.font),
                        u = o.lineHeight / 2 + this._padding.top,
                        {
                            titleX: f,
                            titleY: m,
                            maxWidth: y,
                            rotation: A
                        } = this._drawArgs(u);
                    Oi(a, s.text, 0, 0, o, {
                        color: s.color,
                        maxWidth: y,
                        rotation: A,
                        textAlign: C(s.align),
                        textBaseline: "middle",
                        translation: [f, m]
                    })
                }
            }
            var ac = {
                id: "title",
                _element: ha,
                start(n, a, s) {
                    ! function sc(n, a) {
                        const s = new ha({
                            ctx: n.ctx,
                            options: a,
                            chart: n
                        });
                        we.configure(n, s, a), we.addBox(n, s), n.titleBlock = s
                    }(n, s)
                },
                stop(n) {
                    we.removeBox(n, n.titleBlock), delete n.titleBlock
                },
                beforeUpdate(n, a, s) {
                    const o = n.titleBlock;
                    we.configure(n, o, s), o.options = s
                },
                defaults: {
                    align: "center",
                    display: !1,
                    font: {
                        weight: "bold"
                    },
                    fullSize: !0,
                    padding: 10,
                    position: "top",
                    text: "",
                    weight: 2e3
                },
                defaultRoutes: {
                    color: "color"
                },
                descriptors: {
                    _scriptable: !0,
                    _indexable: !1
                }
            };
            const Ds = new WeakMap;
            var nc = {
                id: "subtitle",
                start(n, a, s) {
                    const o = new ha({
                        ctx: n.ctx,
                        options: s,
                        chart: n
                    });
                    we.configure(n, o, s), we.addBox(n, o), Ds.set(n, o)
                },
                stop(n) {
                    we.removeBox(n, Ds.get(n)), Ds.delete(n)
                },
                beforeUpdate(n, a, s) {
                    const o = Ds.get(n);
                    we.configure(n, o, s), o.options = s
                },
                defaults: {
                    align: "center",
                    display: !1,
                    font: {
                        weight: "normal"
                    },
                    fullSize: !0,
                    padding: 0,
                    position: "top",
                    text: "",
                    weight: 1500
                },
                defaultRoutes: {
                    color: "color"
                },
                descriptors: {
                    _scriptable: !0,
                    _indexable: !1
                }
            };
            const cs = {
                average(n) {
                    if (!n.length) return !1;
                    let a, s, o = 0,
                        c = 0,
                        u = 0;
                    for (a = 0, s = n.length; a < s; ++a) {
                        const f = n[a].element;
                        if (f && f.hasValue()) {
                            const m = f.tooltipPosition();
                            o += m.x, c += m.y, ++u
                        }
                    }
                    return {
                        x: o / u,
                        y: c / u
                    }
                },
                nearest(n, a) {
                    if (!n.length) return !1;
                    let u, f, m, s = a.x,
                        o = a.y,
                        c = Number.POSITIVE_INFINITY;
                    for (u = 0, f = n.length; u < f; ++u) {
                        const y = n[u].element;
                        if (y && y.hasValue()) {
                            const L = ge(a, y.getCenterPoint());
                            L < c && (c = L, m = y)
                        }
                    }
                    if (m) {
                        const y = m.tooltipPosition();
                        s = y.x, o = y.y
                    }
                    return {
                        x: s,
                        y: o
                    }
                }
            };

            function ti(n, a) {
                return a && (Qt(a) ? Array.prototype.push.apply(n, a) : n.push(a)), n
            }

            function oi(n) {
                return ("string" == typeof n || n instanceof String) && n.indexOf("\n") > -1 ? n.split("\n") : n
            }

            function rc(n, a) {
                const {
                    element: s,
                    datasetIndex: o,
                    index: c
                } = a, u = n.getDatasetMeta(o).controller, {
                    label: f,
                    value: m
                } = u.getLabelAndValue(c);
                return {
                    chart: n,
                    label: f,
                    parsed: u.getParsed(c),
                    raw: n.data.datasets[o].data[c],
                    formattedValue: m,
                    dataset: u.getDataset(),
                    dataIndex: c,
                    datasetIndex: o,
                    element: s
                }
            }

            function Un(n, a) {
                const s = n.chart.ctx,
                    {
                        body: o,
                        footer: c,
                        title: u
                    } = n,
                    {
                        boxWidth: f,
                        boxHeight: m
                    } = a,
                    y = de(a.bodyFont),
                    A = de(a.titleFont),
                    L = de(a.footerFont),
                    O = u.length,
                    z = c.length,
                    B = o.length,
                    V = ye(a.padding);
                let G = V.height,
                    Z = 0,
                    tt = o.reduce((pt, nt) => pt + nt.before.length + nt.lines.length + nt.after.length, 0);
                tt += n.beforeBody.length + n.afterBody.length, O && (G += O * A.lineHeight + (O - 1) * a.titleSpacing + a.titleMarginBottom), tt && (G += B * (a.displayColors ? Math.max(m, y.lineHeight) : y.lineHeight) + (tt - B) * y.lineHeight + (tt - 1) * a.bodySpacing), z && (G += a.footerMarginTop + z * L.lineHeight + (z - 1) * a.footerSpacing);
                let J = 0;
                const dt = function(pt) {
                    Z = Math.max(Z, s.measureText(pt).width + J)
                };
                return s.save(), s.font = A.string, Yt(n.title, dt), s.font = y.string, Yt(n.beforeBody.concat(n.afterBody), dt), J = a.displayColors ? f + 2 + a.boxPadding : 0, Yt(o, pt => {
                    Yt(pt.before, dt), Yt(pt.lines, dt), Yt(pt.after, dt)
                }), J = 0, s.font = L.string, Yt(n.footer, dt), s.restore(), Z += V.width, {
                    width: Z,
                    height: G
                }
            }

            function hc(n, a, s, o) {
                const {
                    x: c,
                    width: u
                } = s, {
                    width: f,
                    chartArea: {
                        left: m,
                        right: y
                    }
                } = n;
                let A = "center";
                return "center" === o ? A = c <= (m + y) / 2 ? "left" : "right" : c <= u / 2 ? A = "left" : c >= f - u / 2 && (A = "right"),
                    function lc(n, a, s, o) {
                        const {
                            x: c,
                            width: u
                        } = o, f = s.caretSize + s.caretPadding;
                        if ("left" === n && c + u + f > a.width || "right" === n && c - u - f < 0) return !0
                    }(A, n, a, s) && (A = "center"), A
            }

            function Zn(n, a, s) {
                const o = s.yAlign || a.yAlign || function oc(n, a) {
                    const {
                        y: s,
                        height: o
                    } = a;
                    return s < o / 2 ? "top" : s > n.height - o / 2 ? "bottom" : "center"
                }(n, s);
                return {
                    xAlign: s.xAlign || a.xAlign || hc(n, a, s, o),
                    yAlign: o
                }
            }

            function $n(n, a, s, o) {
                const {
                    caretSize: c,
                    caretPadding: u,
                    cornerRadius: f
                } = n, {
                    xAlign: m,
                    yAlign: y
                } = s, A = c + u, {
                    topLeft: L,
                    topRight: O,
                    bottomLeft: z,
                    bottomRight: B
                } = Ei(f);
                let V = function cc(n, a) {
                    let {
                        x: s,
                        width: o
                    } = n;
                    return "right" === a ? s -= o : "center" === a && (s -= o / 2), s
                }(a, m);
                const G = function dc(n, a, s) {
                    let {
                        y: o,
                        height: c
                    } = n;
                    return "top" === a ? o += s : o -= "bottom" === a ? c + s : c / 2, o
                }(a, y, A);
                return "center" === y ? "left" === m ? V += A : "right" === m && (V -= A) : "left" === m ? V -= Math.max(L, z) + c : "right" === m && (V += Math.max(O, B) + c), {
                    x: Mt(V, 0, o.width - a.width),
                    y: Mt(G, 0, o.height - a.height)
                }
            }

            function Is(n, a, s) {
                const o = ye(s.padding);
                return "center" === a ? n.x + n.width / 2 : "right" === a ? n.x + n.width - o.right : n.x + o.left
            }

            function qn(n) {
                return ti([], oi(n))
            }

            function Kn(n, a) {
                const s = a && a.dataset && a.dataset.tooltip && a.dataset.tooltip.callbacks;
                return s ? n.override(s) : n
            }
            const Qn = {
                beforeTitle: Ae,
                title(n) {
                    if (n.length > 0) {
                        const a = n[0],
                            s = a.chart.data.labels,
                            o = s ? s.length : 0;
                        if (this && this.options && "dataset" === this.options.mode) return a.dataset.label || "";
                        if (a.label) return a.label;
                        if (o > 0 && a.dataIndex < o) return s[a.dataIndex]
                    }
                    return ""
                },
                afterTitle: Ae,
                beforeBody: Ae,
                beforeLabel: Ae,
                label(n) {
                    if (this && this.options && "dataset" === this.options.mode) return n.label + ": " + n.formattedValue || n.formattedValue;
                    let a = n.dataset.label || "";
                    a && (a += ": ");
                    const s = n.formattedValue;
                    return zt(s) || (a += s), a
                },
                labelColor(n) {
                    const s = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
                    return {
                        borderColor: s.borderColor,
                        backgroundColor: s.backgroundColor,
                        borderWidth: s.borderWidth,
                        borderDash: s.borderDash,
                        borderDashOffset: s.borderDashOffset,
                        borderRadius: 0
                    }
                },
                labelTextColor() {
                    return this.options.bodyColor
                },
                labelPointStyle(n) {
                    const s = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
                    return {
                        pointStyle: s.pointStyle,
                        rotation: s.rotation
                    }
                },
                afterLabel: Ae,
                afterBody: Ae,
                beforeFooter: Ae,
                footer: Ae,
                afterFooter: Ae
            };

            function Oe(n, a, s, o) {
                const c = n[a].call(s, o);
                return typeof c > "u" ? Qn[a].call(s, o) : c
            }
            let Jn = (() => class n extends ri {
                static positioners = cs;
                constructor(s) {
                    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = s.chart, this.options = s.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
                }
                initialize(s) {
                    this.options = s, this._cachedAnimations = void 0, this.$context = void 0
                }
                _resolveAnimations() {
                    const s = this._cachedAnimations;
                    if (s) return s;
                    const o = this.chart,
                        c = this.options.setContext(this.getContext()),
                        u = c.enabled && o.options.animation && c.animations,
                        f = new Na(this.chart, u);
                    return u._cacheable && (this._cachedAnimations = Object.freeze(f)), f
                }
                getContext() {
                    return this.$context || (this.$context = function uc(n, a, s) {
                        return wi(n, {
                            tooltip: a,
                            tooltipItems: s,
                            type: "tooltip"
                        })
                    }(this.chart.getContext(), this, this._tooltipItems))
                }
                getTitle(s, o) {
                    const {
                        callbacks: c
                    } = o, u = Oe(c, "beforeTitle", this, s), f = Oe(c, "title", this, s), m = Oe(c, "afterTitle", this, s);
                    let y = [];
                    return y = ti(y, oi(u)), y = ti(y, oi(f)), y = ti(y, oi(m)), y
                }
                getBeforeBody(s, o) {
                    return qn(Oe(o.callbacks, "beforeBody", this, s))
                }
                getBody(s, o) {
                    const {
                        callbacks: c
                    } = o, u = [];
                    return Yt(s, f => {
                        const m = {
                                before: [],
                                lines: [],
                                after: []
                            },
                            y = Kn(c, f);
                        ti(m.before, oi(Oe(y, "beforeLabel", this, f))), ti(m.lines, Oe(y, "label", this, f)), ti(m.after, oi(Oe(y, "afterLabel", this, f))), u.push(m)
                    }), u
                }
                getAfterBody(s, o) {
                    return qn(Oe(o.callbacks, "afterBody", this, s))
                }
                getFooter(s, o) {
                    const {
                        callbacks: c
                    } = o, u = Oe(c, "beforeFooter", this, s), f = Oe(c, "footer", this, s), m = Oe(c, "afterFooter", this, s);
                    let y = [];
                    return y = ti(y, oi(u)), y = ti(y, oi(f)), y = ti(y, oi(m)), y
                }
                _createItems(s) {
                    const o = this._active,
                        c = this.chart.data,
                        u = [],
                        f = [],
                        m = [];
                    let A, L, y = [];
                    for (A = 0, L = o.length; A < L; ++A) y.push(rc(this.chart, o[A]));
                    return s.filter && (y = y.filter((O, z, B) => s.filter(O, z, B, c))), s.itemSort && (y = y.sort((O, z) => s.itemSort(O, z, c))), Yt(y, O => {
                        const z = Kn(s.callbacks, O);
                        u.push(Oe(z, "labelColor", this, O)), f.push(Oe(z, "labelPointStyle", this, O)), m.push(Oe(z, "labelTextColor", this, O))
                    }), this.labelColors = u, this.labelPointStyles = f, this.labelTextColors = m, this.dataPoints = y, y
                }
                update(s, o) {
                    const c = this.options.setContext(this.getContext()),
                        u = this._active;
                    let f, m = [];
                    if (u.length) {
                        const y = cs[c.position].call(this, u, this._eventPosition);
                        m = this._createItems(c), this.title = this.getTitle(m, c), this.beforeBody = this.getBeforeBody(m, c), this.body = this.getBody(m, c), this.afterBody = this.getAfterBody(m, c), this.footer = this.getFooter(m, c);
                        const A = this._size = Un(this, c),
                            L = Object.assign({}, y, A),
                            O = Zn(this.chart, c, L),
                            z = $n(c, L, O, this.chart);
                        this.xAlign = O.xAlign, this.yAlign = O.yAlign, f = {
                            opacity: 1,
                            x: z.x,
                            y: z.y,
                            width: A.width,
                            height: A.height,
                            caretX: y.x,
                            caretY: y.y
                        }
                    } else 0 !== this.opacity && (f = {
                        opacity: 0
                    });
                    this._tooltipItems = m, this.$context = void 0, f && this._resolveAnimations().update(this, f), s && c.external && c.external.call(this, {
                        chart: this.chart,
                        tooltip: this,
                        replay: o
                    })
                }
                drawCaret(s, o, c, u) {
                    const f = this.getCaretPosition(s, c, u);
                    o.lineTo(f.x1, f.y1), o.lineTo(f.x2, f.y2), o.lineTo(f.x3, f.y3)
                }
                getCaretPosition(s, o, c) {
                    const {
                        xAlign: u,
                        yAlign: f
                    } = this, {
                        caretSize: m,
                        cornerRadius: y
                    } = c, {
                        topLeft: A,
                        topRight: L,
                        bottomLeft: O,
                        bottomRight: z
                    } = Ei(y), {
                        x: B,
                        y: V
                    } = s, {
                        width: G,
                        height: Z
                    } = o;
                    let tt, J, dt, pt, nt, ft;
                    return "center" === f ? (nt = V + Z / 2, "left" === u ? (tt = B, J = tt - m, pt = nt + m, ft = nt - m) : (tt = B + G, J = tt + m, pt = nt - m, ft = nt + m), dt = tt) : (J = "left" === u ? B + Math.max(A, O) + m : "right" === u ? B + G - Math.max(L, z) - m : this.caretX, "top" === f ? (pt = V, nt = pt - m, tt = J - m, dt = J + m) : (pt = V + Z, nt = pt + m, tt = J + m, dt = J - m), ft = pt), {
                        x1: tt,
                        x2: J,
                        x3: dt,
                        y1: pt,
                        y2: nt,
                        y3: ft
                    }
                }
                drawTitle(s, o, c) {
                    const u = this.title,
                        f = u.length;
                    let m, y, A;
                    if (f) {
                        const L = Zi(c.rtl, this.x, this.width);
                        for (s.x = Is(this, c.titleAlign, c), o.textAlign = L.textAlign(c.titleAlign), o.textBaseline = "middle", m = de(c.titleFont), y = c.titleSpacing, o.fillStyle = c.titleColor, o.font = m.string, A = 0; A < f; ++A) o.fillText(u[A], L.x(s.x), s.y + m.lineHeight / 2), s.y += m.lineHeight + y, A + 1 === f && (s.y += c.titleMarginBottom - y)
                    }
                }
                _drawColorBox(s, o, c, u, f) {
                    const m = this.labelColors[c],
                        y = this.labelPointStyles[c],
                        {
                            boxHeight: A,
                            boxWidth: L
                        } = f,
                        O = de(f.bodyFont),
                        z = Is(this, "left", f),
                        B = u.x(z),
                        G = o.y + (A < O.lineHeight ? (O.lineHeight - A) / 2 : 0);
                    if (f.usePointStyle) {
                        const Z = {
                                radius: Math.min(L, A) / 2,
                                pointStyle: y.pointStyle,
                                rotation: y.rotation,
                                borderWidth: 1
                            },
                            tt = u.leftForLtr(B, L) + L / 2,
                            J = G + A / 2;
                        s.strokeStyle = f.multiKeyBackground, s.fillStyle = f.multiKeyBackground, Bs(s, Z, tt, J), s.strokeStyle = m.borderColor, s.fillStyle = m.backgroundColor, Bs(s, Z, tt, J)
                    } else {
                        s.lineWidth = Tt(m.borderWidth) ? Math.max(...Object.values(m.borderWidth)) : m.borderWidth || 1, s.strokeStyle = m.borderColor, s.setLineDash(m.borderDash || []), s.lineDashOffset = m.borderDashOffset || 0;
                        const Z = u.leftForLtr(B, L),
                            tt = u.leftForLtr(u.xPlus(B, 1), L - 2),
                            J = Ei(m.borderRadius);
                        Object.values(J).some(dt => 0 !== dt) ? (s.beginPath(), s.fillStyle = f.multiKeyBackground, ts(s, {
                            x: Z,
                            y: G,
                            w: L,
                            h: A,
                            radius: J
                        }), s.fill(), s.stroke(), s.fillStyle = m.backgroundColor, s.beginPath(), ts(s, {
                            x: tt,
                            y: G + 1,
                            w: L - 2,
                            h: A - 2,
                            radius: J
                        }), s.fill()) : (s.fillStyle = f.multiKeyBackground, s.fillRect(Z, G, L, A), s.strokeRect(Z, G, L, A), s.fillStyle = m.backgroundColor, s.fillRect(tt, G + 1, L - 2, A - 2))
                    }
                    s.fillStyle = this.labelTextColors[c]
                }
                drawBody(s, o, c) {
                    const {
                        body: u
                    } = this, {
                        bodySpacing: f,
                        bodyAlign: m,
                        displayColors: y,
                        boxHeight: A,
                        boxWidth: L,
                        boxPadding: O
                    } = c, z = de(c.bodyFont);
                    let B = z.lineHeight,
                        V = 0;
                    const G = Zi(c.rtl, this.x, this.width),
                        Z = function(St) {
                            o.fillText(St, G.x(s.x + V), s.y + B / 2), s.y += B + f
                        },
                        tt = G.textAlign(m);
                    let J, dt, pt, nt, ft, At, vt;
                    for (o.textAlign = m, o.textBaseline = "middle", o.font = z.string, s.x = Is(this, tt, c), o.fillStyle = c.bodyColor, Yt(this.beforeBody, Z), V = y && "right" !== tt ? "center" === m ? L / 2 + O : L + 2 + O : 0, nt = 0, At = u.length; nt < At; ++nt) {
                        for (J = u[nt], dt = this.labelTextColors[nt], o.fillStyle = dt, Yt(J.before, Z), pt = J.lines, y && pt.length && (this._drawColorBox(o, s, nt, G, c), B = Math.max(z.lineHeight, A)), ft = 0, vt = pt.length; ft < vt; ++ft) Z(pt[ft]), B = z.lineHeight;
                        Yt(J.after, Z)
                    }
                    V = 0, B = z.lineHeight, Yt(this.afterBody, Z), s.y -= f
                }
                drawFooter(s, o, c) {
                    const u = this.footer,
                        f = u.length;
                    let m, y;
                    if (f) {
                        const A = Zi(c.rtl, this.x, this.width);
                        for (s.x = Is(this, c.footerAlign, c), s.y += c.footerMarginTop, o.textAlign = A.textAlign(c.footerAlign), o.textBaseline = "middle", m = de(c.footerFont), o.fillStyle = c.footerColor, o.font = m.string, y = 0; y < f; ++y) o.fillText(u[y], A.x(s.x), s.y + m.lineHeight / 2), s.y += m.lineHeight + c.footerSpacing
                    }
                }
                drawBackground(s, o, c, u) {
                    const {
                        xAlign: f,
                        yAlign: m
                    } = this, {
                        x: y,
                        y: A
                    } = s, {
                        width: L,
                        height: O
                    } = c, {
                        topLeft: z,
                        topRight: B,
                        bottomLeft: V,
                        bottomRight: G
                    } = Ei(u.cornerRadius);
                    o.fillStyle = u.backgroundColor, o.strokeStyle = u.borderColor, o.lineWidth = u.borderWidth, o.beginPath(), o.moveTo(y + z, A), "top" === m && this.drawCaret(s, o, c, u), o.lineTo(y + L - B, A), o.quadraticCurveTo(y + L, A, y + L, A + B), "center" === m && "right" === f && this.drawCaret(s, o, c, u), o.lineTo(y + L, A + O - G), o.quadraticCurveTo(y + L, A + O, y + L - G, A + O), "bottom" === m && this.drawCaret(s, o, c, u), o.lineTo(y + V, A + O), o.quadraticCurveTo(y, A + O, y, A + O - V), "center" === m && "left" === f && this.drawCaret(s, o, c, u), o.lineTo(y, A + z), o.quadraticCurveTo(y, A, y + z, A), o.closePath(), o.fill(), u.borderWidth > 0 && o.stroke()
                }
                _updateAnimationTarget(s) {
                    const o = this.chart,
                        c = this.$animations,
                        u = c && c.x,
                        f = c && c.y;
                    if (u || f) {
                        const m = cs[s.position].call(this, this._active, this._eventPosition);
                        if (!m) return;
                        const y = this._size = Un(this, s),
                            A = Object.assign({}, m, this._size),
                            L = Zn(o, s, A),
                            O = $n(s, A, L, o);
                        (u._to !== O.x || f._to !== O.y) && (this.xAlign = L.xAlign, this.yAlign = L.yAlign, this.width = y.width, this.height = y.height, this.caretX = m.x, this.caretY = m.y, this._resolveAnimations().update(this, O))
                    }
                }
                _willRender() {
                    return !!this.opacity
                }
                draw(s) {
                    const o = this.options.setContext(this.getContext());
                    let c = this.opacity;
                    if (!c) return;
                    this._updateAnimationTarget(o);
                    const u = {
                            width: this.width,
                            height: this.height
                        },
                        f = {
                            x: this.x,
                            y: this.y
                        };
                    c = Math.abs(c) < .001 ? 0 : c;
                    const m = ye(o.padding);
                    o.enabled && (this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length) && (s.save(), s.globalAlpha = c, this.drawBackground(f, s, u, o), Ta(s, o.textDirection), f.y += m.top, this.drawTitle(f, s, o), this.drawBody(f, s, o), this.drawFooter(f, s, o), Oa(s, o.textDirection), s.restore())
                }
                getActiveElements() {
                    return this._active || []
                }
                setActiveElements(s, o) {
                    const c = this._active,
                        u = s.map(({
                            datasetIndex: y,
                            index: A
                        }) => {
                            const L = this.chart.getDatasetMeta(y);
                            if (!L) throw new Error("Cannot find a dataset at index " + y);
                            return {
                                datasetIndex: y,
                                element: L.data[A],
                                index: A
                            }
                        }),
                        f = !xi(c, u),
                        m = this._positionChanged(u, o);
                    (f || m) && (this._active = u, this._eventPosition = o, this._ignoreReplayEvents = !0, this.update(!0))
                }
                handleEvent(s, o, c = !0) {
                    if (o && this._ignoreReplayEvents) return !1;
                    this._ignoreReplayEvents = !1;
                    const u = this.options,
                        f = this._active || [],
                        m = this._getActiveElements(s, f, o, c),
                        y = this._positionChanged(m, s),
                        A = o || !xi(m, f) || y;
                    return A && (this._active = m, (u.enabled || u.external) && (this._eventPosition = {
                        x: s.x,
                        y: s.y
                    }, this.update(!0, o))), A
                }
                _getActiveElements(s, o, c, u) {
                    const f = this.options;
                    if ("mouseout" === s.type) return [];
                    if (!u) return o;
                    const m = this.chart.getElementsAtEventForMode(s, f.mode, f, c);
                    return f.reverse && m.reverse(), m
                }
                _positionChanged(s, o) {
                    const {
                        caretX: c,
                        caretY: u,
                        options: f
                    } = this, m = cs[f.position].call(this, s, o);
                    return !1 !== m && (c !== m.x || u !== m.y)
                }
            })();
            var fc = Object.freeze({
                __proto__: null,
                Colors: Mh,
                Decimation: Th,
                Filler: qh,
                Legend: ic,
                SubTitle: nc,
                Title: ac,
                Tooltip: {
                    id: "tooltip",
                    _element: Jn,
                    positioners: cs,
                    afterInit(n, a, s) {
                        s && (n.tooltip = new Jn({
                            chart: n,
                            options: s
                        }))
                    },
                    beforeUpdate(n, a, s) {
                        n.tooltip && n.tooltip.initialize(s)
                    },
                    reset(n, a, s) {
                        n.tooltip && n.tooltip.initialize(s)
                    },
                    afterDraw(n) {
                        const a = n.tooltip;
                        if (a && a._willRender()) {
                            const s = {
                                tooltip: a
                            };
                            if (!1 === n.notifyPlugins("beforeTooltipDraw", { ...s,
                                    cancelable: !0
                                })) return;
                            a.draw(n.ctx), n.notifyPlugins("afterTooltipDraw", s)
                        }
                    },
                    afterEvent(n, a) {
                        n.tooltip && n.tooltip.handleEvent(a.event, a.replay, a.inChartArea) && (a.changed = !0)
                    },
                    defaults: {
                        enabled: !0,
                        external: null,
                        position: "average",
                        backgroundColor: "rgba(0,0,0,0.8)",
                        titleColor: "#fff",
                        titleFont: {
                            weight: "bold"
                        },
                        titleSpacing: 2,
                        titleMarginBottom: 6,
                        titleAlign: "left",
                        bodyColor: "#fff",
                        bodySpacing: 2,
                        bodyFont: {},
                        bodyAlign: "left",
                        footerColor: "#fff",
                        footerSpacing: 2,
                        footerMarginTop: 6,
                        footerFont: {
                            weight: "bold"
                        },
                        footerAlign: "left",
                        padding: 6,
                        caretPadding: 2,
                        caretSize: 5,
                        cornerRadius: 6,
                        boxHeight: (n, a) => a.bodyFont.size,
                        boxWidth: (n, a) => a.bodyFont.size,
                        multiKeyBackground: "#fff",
                        displayColors: !0,
                        boxPadding: 0,
                        borderColor: "rgba(0,0,0,0)",
                        borderWidth: 0,
                        animation: {
                            duration: 400,
                            easing: "easeOutQuart"
                        },
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "width", "height", "caretX", "caretY"]
                            },
                            opacity: {
                                easing: "linear",
                                duration: 200
                            }
                        },
                        callbacks: Qn
                    },
                    defaultRoutes: {
                        bodyFont: "font",
                        footerFont: "font",
                        titleFont: "font"
                    },
                    descriptors: {
                        _scriptable: n => "filter" !== n && "itemSort" !== n && "external" !== n,
                        _indexable: !1,
                        callbacks: {
                            _scriptable: !1,
                            _indexable: !1
                        },
                        animation: {
                            _fallback: !1
                        },
                        animations: {
                            _fallback: "animation"
                        }
                    },
                    additionalOptionScopes: ["interaction"]
                }
            });

            function tr(n) {
                const a = this.getLabels();
                return n >= 0 && n < a.length ? a[n] : n
            }
            let bc = (() => class n extends Fi {
                static id = "category";
                static defaults = {
                    ticks: {
                        callback: tr
                    }
                };
                constructor(s) {
                    super(s), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
                }
                init(s) {
                    const o = this._addedLabels;
                    if (o.length) {
                        const c = this.getLabels();
                        for (const {
                                index: u,
                                label: f
                            } of o) c[u] === f && c.splice(u, 1);
                        this._addedLabels = []
                    }
                    super.init(s)
                }
                parse(s, o) {
                    if (zt(s)) return null;
                    const c = this.getLabels();
                    return ((n, a) => null === n ? null : Mt(Math.round(n), 0, a))(o = isFinite(o) && c[o] === s ? o : function xc(n, a, s, o) {
                        const c = n.indexOf(a);
                        return -1 === c ? ((n, a, s, o) => ("string" == typeof a ? (s = n.push(a) - 1, o.unshift({
                            index: s,
                            label: a
                        })) : isNaN(a) && (s = null), s))(n, a, s, o) : c !== n.lastIndexOf(a) ? s : c
                    }(c, s, Ct(o, s), this._addedLabels), c.length - 1)
                }
                determineDataLimits() {
                    const {
                        minDefined: s,
                        maxDefined: o
                    } = this.getUserBounds();
                    let {
                        min: c,
                        max: u
                    } = this.getMinMax(!0);
                    "ticks" === this.options.bounds && (s || (c = 0), o || (u = this.getLabels().length - 1)), this.min = c, this.max = u
                }
                buildTicks() {
                    const s = this.min,
                        o = this.max,
                        c = this.options.offset,
                        u = [];
                    let f = this.getLabels();
                    f = 0 === s && o === f.length - 1 ? f : f.slice(s, o + 1), this._valueRange = Math.max(f.length - (c ? 0 : 1), 1), this._startValue = this.min - (c ? .5 : 0);
                    for (let m = s; m <= o; m++) u.push({
                        value: m
                    });
                    return u
                }
                getLabelForValue(s) {
                    return tr.call(this, s)
                }
                configure() {
                    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
                }
                getPixelForValue(s) {
                    return "number" != typeof s && (s = this.parse(s)), null === s ? NaN : this.getPixelForDecimal((s - this._startValue) / this._valueRange)
                }
                getPixelForTick(s) {
                    const o = this.ticks;
                    return s < 0 || s > o.length - 1 ? null : this.getPixelForValue(o[s].value)
                }
                getValueForPixel(s) {
                    return Math.round(this._startValue + this.getDecimalForPixel(s) * this._valueRange)
                }
                getBasePixel() {
                    return this.bottom
                }
            })();

            function er(n, a, {
                horizontal: s,
                minRotation: o
            }) {
                const c = Gt(o),
                    u = (s ? Math.sin(c) : Math.cos(c)) || .001;
                return Math.min(a / u, .75 * a * ("" + n).length)
            }
            class zs extends Fi {
                constructor(a) {
                    super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
                }
                parse(a, s) {
                    return zt(a) || ("number" == typeof a || a instanceof Number) && !isFinite(+a) ? null : +a
                }
                handleTickRangeOptions() {
                    const {
                        beginAtZero: a
                    } = this.options, {
                        minDefined: s,
                        maxDefined: o
                    } = this.getUserBounds();
                    let {
                        min: c,
                        max: u
                    } = this;
                    const f = y => c = s ? c : y,
                        m = y => u = o ? u : y;
                    if (a) {
                        const y = rt(c),
                            A = rt(u);
                        y < 0 && A < 0 ? m(0) : y > 0 && A > 0 && f(0)
                    }
                    if (c === u) {
                        let y = 0 === u ? 1 : Math.abs(.05 * u);
                        m(u + y), a || f(c - y)
                    }
                    this.min = c, this.max = u
                }
                getTickLimit() {
                    const a = this.options.ticks;
                    let c, {
                        maxTicksLimit: s,
                        stepSize: o
                    } = a;
                    return o ? (c = Math.ceil(this.max / o) - Math.floor(this.min / o) + 1, c > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${o} would result generating up to ${c} ticks. Limiting to 1000.`), c = 1e3)) : (c = this.computeTickLimit(), s = s || 11), s && (c = Math.min(s, c)), c
                }
                computeTickLimit() {
                    return Number.POSITIVE_INFINITY
                }
                buildTicks() {
                    const a = this.options,
                        s = a.ticks;
                    let o = this.getTickLimit();
                    o = Math.max(2, o);
                    const f = function vc(n, a) {
                        const s = [],
                            {
                                bounds: c,
                                step: u,
                                min: f,
                                max: m,
                                precision: y,
                                count: A,
                                maxTicks: L,
                                maxDigits: O,
                                includeBounds: z
                            } = n,
                            B = u || 1,
                            V = L - 1,
                            {
                                min: G,
                                max: Z
                            } = a,
                            tt = !zt(f),
                            J = !zt(m),
                            dt = !zt(A),
                            pt = (Z - G) / (O + 1);
                        let ft, At, vt, St, nt = ct((Z - G) / V / B) * B;
                        if (nt < 1e-14 && !tt && !J) return [{
                            value: G
                        }, {
                            value: Z
                        }];
                        St = Math.ceil(Z / nt) - Math.floor(G / nt), St > V && (nt = ct(St * nt / V / B) * B), zt(y) || (ft = Math.pow(10, y), nt = Math.ceil(nt * ft) / ft), "ticks" === c ? (At = Math.floor(G / nt) * nt, vt = Math.ceil(Z / nt) * nt) : (At = G, vt = Z), tt && J && u && function kt(n, a) {
                            const s = Math.round(n);
                            return s - a <= n && s + a >= n
                        }((m - f) / u, nt / 1e3) ? (St = Math.round(Math.min((m - f) / nt, L)), nt = (m - f) / St, At = f, vt = m) : dt ? (At = tt ? f : At, vt = J ? m : vt, St = A - 1, nt = (vt - At) / St) : (St = (vt - At) / nt, St = lt(St, Math.round(St), nt / 1e3) ? Math.round(St) : Math.ceil(St));
                        const It = Math.max(_e(nt), _e(At));
                        ft = Math.pow(10, zt(y) ? It : y), At = Math.round(At * ft) / ft, vt = Math.round(vt * ft) / ft;
                        let Ot = 0;
                        for (tt && (z && At !== f ? (s.push({
                                value: f
                            }), At < f && Ot++, lt(Math.round((At + Ot * nt) * ft) / ft, f, er(f, pt, n)) && Ot++) : At < f && Ot++); Ot < St; ++Ot) {
                            const Ht = Math.round((At + Ot * nt) * ft) / ft;
                            if (J && Ht > m) break;
                            s.push({
                                value: Ht
                            })
                        }
                        return J && z && vt !== m ? s.length && lt(s[s.length - 1].value, m, er(m, pt, n)) ? s[s.length - 1].value = m : s.push({
                            value: m
                        }) : (!J || vt === m) && s.push({
                            value: vt
                        }), s
                    }({
                        maxTicks: o,
                        bounds: a.bounds,
                        min: a.min,
                        max: a.max,
                        precision: s.precision,
                        step: s.stepSize,
                        count: s.count,
                        maxDigits: this._maxDigits(),
                        horizontal: this.isHorizontal(),
                        minRotation: s.minRotation || 0,
                        includeBounds: !1 !== s.includeBounds
                    }, this._range || this);
                    return "ticks" === a.bounds && gt(f, this, "value"), a.reverse ? (f.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), f
                }
                configure() {
                    const a = this.ticks;
                    let s = this.min,
                        o = this.max;
                    if (super.configure(), this.options.offset && a.length) {
                        const c = (o - s) / Math.max(a.length - 1, 1) / 2;
                        s -= c, o += c
                    }
                    this._startValue = s, this._endValue = o, this._valueRange = o - s
                }
                getLabelForValue(a) {
                    return Pt(a, this.chart.options.locale, this.options.ticks.format)
                }
            }
            const ds = n => Math.floor(et(n)),
                Xi = (n, a) => Math.pow(10, ds(n) + a);

            function ir(n) {
                return n / Math.pow(10, ds(n)) == 1
            }

            function sr(n, a, s) {
                const o = Math.pow(10, s),
                    c = Math.floor(n / o);
                return Math.ceil(a / o) - c
            }

            function ca(n) {
                const a = n.ticks;
                if (a.display && n.display) {
                    const s = ye(a.backdropPadding);
                    return Ct(a.font && a.font.size, Xt.font.size) + s.height
                }
                return 0
            }

            function Sc(n, a, s) {
                return s = Qt(s) ? s : [s], {
                    w: kr(n, a.string, s),
                    h: s.length * a.lineHeight
                }
            }

            function ar(n, a, s, o, c) {
                return n === o || n === c ? {
                    start: a - s / 2,
                    end: a + s / 2
                } : n < o || n > c ? {
                    start: a - s,
                    end: a
                } : {
                    start: a,
                    end: a + s
                }
            }

            function Mc(n, a, s, o, c) {
                const u = Math.abs(Math.sin(s)),
                    f = Math.abs(Math.cos(s));
                let m = 0,
                    y = 0;
                o.start < a.l ? (m = (a.l - o.start) / u, n.l = Math.min(n.l, a.l - m)) : o.end > a.r && (m = (o.end - a.r) / u, n.r = Math.max(n.r, a.r + m)), c.start < a.t ? (y = (a.t - c.start) / f, n.t = Math.min(n.t, a.t - y)) : c.end > a.b && (y = (c.end - a.b) / f, n.b = Math.max(n.b, a.b + y))
            }

            function Pc(n, a, s) {
                const o = n.drawingArea,
                    {
                        extra: c,
                        additionalAngle: u,
                        padding: f,
                        size: m
                    } = s,
                    y = n.getPointPosition(a, o + c + f, u),
                    A = Math.round(Ut(Wt(y.angle + Y))),
                    L = function Ec(n, a, s) {
                        return 90 === s || 270 === s ? n -= a / 2 : (s > 270 || s < 90) && (n -= a), n
                    }(y.y, m.h, A),
                    O = function Tc(n) {
                        return 0 === n || 180 === n ? "center" : n < 180 ? "left" : "right"
                    }(A),
                    z = function Oc(n, a, s) {
                        return "right" === s ? n -= a : "center" === s && (n -= a / 2), n
                    }(y.x, m.w, O);
                return {
                    visible: !0,
                    x: y.x,
                    y: L,
                    textAlign: O,
                    left: z,
                    top: L,
                    right: z + m.w,
                    bottom: L + m.h
                }
            }

            function Lc(n, a) {
                if (!a) return !0;
                const {
                    left: s,
                    top: o,
                    right: c,
                    bottom: u
                } = n;
                return !(ai({
                    x: s,
                    y: o
                }, a) || ai({
                    x: s,
                    y: u
                }, a) || ai({
                    x: c,
                    y: o
                }, a) || ai({
                    x: c,
                    y: u
                }, a))
            }

            function Dc(n, a, s) {
                const {
                    left: o,
                    top: c,
                    right: u,
                    bottom: f
                } = s, {
                    backdropColor: m
                } = a;
                if (!zt(m)) {
                    const y = Ei(a.borderRadius),
                        A = ye(a.backdropPadding);
                    n.fillStyle = m;
                    const L = o - A.left,
                        O = c - A.top,
                        z = u - o + A.width,
                        B = f - c + A.height;
                    Object.values(y).some(V => 0 !== V) ? (n.beginPath(), ts(n, {
                        x: L,
                        y: O,
                        w: z,
                        h: B,
                        radius: y
                    }), n.fill()) : n.fillRect(L, O, z, B)
                }
            }

            function nr(n, a, s, o) {
                const {
                    ctx: c
                } = n;
                if (s) c.arc(n.xCenter, n.yCenter, a, 0, W);
                else {
                    let u = n.getPointPosition(0, a);
                    c.moveTo(u.x, u.y);
                    for (let f = 1; f < o; f++) u = n.getPointPosition(f, a), c.lineTo(u.x, u.y)
                }
            }
            const Rs = {
                    millisecond: {
                        common: !0,
                        size: 1,
                        steps: 1e3
                    },
                    second: {
                        common: !0,
                        size: 1e3,
                        steps: 60
                    },
                    minute: {
                        common: !0,
                        size: 6e4,
                        steps: 60
                    },
                    hour: {
                        common: !0,
                        size: 36e5,
                        steps: 24
                    },
                    day: {
                        common: !0,
                        size: 864e5,
                        steps: 30
                    },
                    week: {
                        common: !1,
                        size: 6048e5,
                        steps: 4
                    },
                    month: {
                        common: !0,
                        size: 2628e6,
                        steps: 12
                    },
                    quarter: {
                        common: !1,
                        size: 7884e6,
                        steps: 4
                    },
                    year: {
                        common: !0,
                        size: 3154e7
                    }
                },
                Ee = Object.keys(Rs);

            function rr(n, a) {
                return n - a
            }

            function or(n, a) {
                if (zt(a)) return null;
                const s = n._adapter,
                    {
                        parser: o,
                        round: c,
                        isoWeekday: u
                    } = n._parseOpts;
                let f = a;
                return "function" == typeof o && (f = o(f)), $t(f) || (f = "string" == typeof o ? s.parse(f, o) : s.parse(f)), null === f ? null : (c && (f = "week" !== c || !st(u) && !0 !== u ? s.startOf(f, c) : s.startOf(f, "isoWeek", u)), +f)
            }

            function lr(n, a, s, o) {
                const c = Ee.length;
                for (let u = Ee.indexOf(n); u < c - 1; ++u) {
                    const f = Rs[Ee[u]];
                    if (f.common && Math.ceil((s - a) / ((f.steps ? f.steps : Number.MAX_SAFE_INTEGER) * f.size)) <= o) return Ee[u]
                }
                return Ee[c - 1]
            }

            function hr(n, a, s) {
                if (s) {
                    if (s.length) {
                        const {
                            lo: o,
                            hi: c
                        } = e(s, a);
                        n[s[o] >= a ? s[o] : s[c]] = !0
                    }
                } else n[a] = !0
            }

            function cr(n, a, s) {
                const o = [],
                    c = {},
                    u = a.length;
                let f, m;
                for (f = 0; f < u; ++f) m = a[f], c[m] = f, o.push({
                    value: m,
                    major: !1
                });
                return 0 !== u && s ? function Bc(n, a, s, o) {
                    const c = n._adapter,
                        u = +c.startOf(a[0].value, o),
                        f = a[a.length - 1].value;
                    let m, y;
                    for (m = u; m <= f; m = +c.add(m, 1, o)) y = s[m], y >= 0 && (a[y].major = !0);
                    return a
                }(n, o, c, s) : o
            }
            let da = (() => class n extends Fi {
                static id = "time";
                static defaults = {
                    bounds: "data",
                    adapters: {},
                    time: {
                        parser: !1,
                        unit: !1,
                        round: !1,
                        isoWeekday: !1,
                        minUnit: "millisecond",
                        displayFormats: {}
                    },
                    ticks: {
                        source: "auto",
                        callback: !1,
                        major: {
                            enabled: !1
                        }
                    }
                };
                constructor(s) {
                    super(s), this._cache = {
                        data: [],
                        labels: [],
                        all: []
                    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
                }
                init(s, o = {}) {
                    const c = s.time || (s.time = {}),
                        u = this._adapter = new Yo__date(s.adapters.date);
                    u.init(o), qe(c.displayFormats, u.formats()), this._parseOpts = {
                        parser: c.parser,
                        round: c.round,
                        isoWeekday: c.isoWeekday
                    }, super.init(s), this._normalized = o.normalized
                }
                parse(s, o) {
                    return void 0 === s ? null : or(this, s)
                }
                beforeLayout() {
                    super.beforeLayout(), this._cache = {
                        data: [],
                        labels: [],
                        all: []
                    }
                }
                determineDataLimits() {
                    const s = this.options,
                        o = this._adapter,
                        c = s.time.unit || "day";
                    let {
                        min: u,
                        max: f,
                        minDefined: m,
                        maxDefined: y
                    } = this.getUserBounds();

                    function A(L) {
                        !m && !isNaN(L.min) && (u = Math.min(u, L.min)), !y && !isNaN(L.max) && (f = Math.max(f, L.max))
                    }(!m || !y) && (A(this._getLabelBounds()), ("ticks" !== s.bounds || "labels" !== s.ticks.source) && A(this.getMinMax(!1))), u = $t(u) && !isNaN(u) ? u : +o.startOf(Date.now(), c), f = $t(f) && !isNaN(f) ? f : +o.endOf(Date.now(), c) + 1, this.min = Math.min(u, f - 1), this.max = Math.max(u + 1, f)
                }
                _getLabelBounds() {
                    const s = this.getLabelTimestamps();
                    let o = Number.POSITIVE_INFINITY,
                        c = Number.NEGATIVE_INFINITY;
                    return s.length && (o = s[0], c = s[s.length - 1]), {
                        min: o,
                        max: c
                    }
                }
                buildTicks() {
                    const s = this.options,
                        o = s.time,
                        c = s.ticks,
                        u = "labels" === c.source ? this.getLabelTimestamps() : this._generate();
                    "ticks" === s.bounds && u.length && (this.min = this._userMin || u[0], this.max = this._userMax || u[u.length - 1]);
                    const f = this.min,
                        y = function l(n, a, s) {
                            let o = 0,
                                c = n.length;
                            for (; o < c && n[o] < a;) o++;
                            for (; c > o && n[c - 1] > s;) c--;
                            return o > 0 || c < n.length ? n.slice(o, c) : n
                        }(u, f, this.max);
                    return this._unit = o.unit || (c.autoSkip ? lr(o.minUnit, this.min, this.max, this._getLabelCapacity(f)) : function Xc(n, a, s, o, c) {
                        for (let u = Ee.length - 1; u >= Ee.indexOf(s); u--) {
                            const f = Ee[u];
                            if (Rs[f].common && n._adapter.diff(c, o, f) >= a - 1) return f
                        }
                        return Ee[s ? Ee.indexOf(s) : 0]
                    }(this, y.length, o.minUnit, this.min, this.max)), this._majorUnit = c.major.enabled && "year" !== this._unit ? function Nc(n) {
                        for (let a = Ee.indexOf(n) + 1, s = Ee.length; a < s; ++a)
                            if (Rs[Ee[a]].common) return Ee[a]
                    }(this._unit) : void 0, this.initOffsets(u), s.reverse && y.reverse(), cr(this, y, this._majorUnit)
                }
                afterAutoSkip() {
                    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(s => +s.value))
                }
                initOffsets(s = []) {
                    let u, f, o = 0,
                        c = 0;
                    this.options.offset && s.length && (u = this.getDecimalForValue(s[0]), o = 1 === s.length ? 1 - u : (this.getDecimalForValue(s[1]) - u) / 2, f = this.getDecimalForValue(s[s.length - 1]), c = 1 === s.length ? f : (f - this.getDecimalForValue(s[s.length - 2])) / 2);
                    const m = s.length < 3 ? .5 : .25;
                    o = Mt(o, 0, m), c = Mt(c, 0, m), this._offsets = {
                        start: o,
                        end: c,
                        factor: 1 / (o + 1 + c)
                    }
                }
                _generate() {
                    const s = this._adapter,
                        o = this.min,
                        c = this.max,
                        u = this.options,
                        f = u.time,
                        m = f.unit || lr(f.minUnit, o, c, this._getLabelCapacity(o)),
                        y = Ct(u.ticks.stepSize, 1),
                        A = "week" === m && f.isoWeekday,
                        L = st(A) || !0 === A,
                        O = {};
                    let B, V, z = o;
                    if (L && (z = +s.startOf(z, "isoWeek", A)), z = +s.startOf(z, L ? "day" : m), s.diff(c, o, m) > 1e5 * y) throw new Error(o + " and " + c + " are too far apart with stepSize of " + y + " " + m);
                    const G = "data" === u.ticks.source && this.getDataTimestamps();
                    for (B = z, V = 0; B < c; B = +s.add(B, y, m), V++) hr(O, B, G);
                    return (B === c || "ticks" === u.bounds || 1 === V) && hr(O, B, G), Object.keys(O).sort(rr).map(Z => +Z)
                }
                getLabelForValue(s) {
                    const c = this.options.time;
                    return this._adapter.format(s, c.tooltipFormat ? c.tooltipFormat : c.displayFormats.datetime)
                }
                format(s, o) {
                    return this._adapter.format(s, o || this.options.time.displayFormats[this._unit])
                }
                _tickFormatFunction(s, o, c, u) {
                    const f = this.options,
                        m = f.ticks.callback;
                    if (m) return qt(m, [s, o, c], this);
                    const y = f.time.displayFormats,
                        A = this._unit,
                        L = this._majorUnit,
                        z = L && y[L],
                        B = c[o];
                    return this._adapter.format(s, u || (L && z && B && B.major ? z : A && y[A]))
                }
                generateTickLabels(s) {
                    let o, c, u;
                    for (o = 0, c = s.length; o < c; ++o) u = s[o], u.label = this._tickFormatFunction(u.value, o, s)
                }
                getDecimalForValue(s) {
                    return null === s ? NaN : (s - this.min) / (this.max - this.min)
                }
                getPixelForValue(s) {
                    const o = this._offsets,
                        c = this.getDecimalForValue(s);
                    return this.getPixelForDecimal((o.start + c) * o.factor)
                }
                getValueForPixel(s) {
                    const o = this._offsets,
                        c = this.getDecimalForPixel(s) / o.factor - o.end;
                    return this.min + c * (this.max - this.min)
                }
                _getLabelSize(s) {
                    const o = this.options.ticks,
                        c = this.ctx.measureText(s).width,
                        u = Gt(this.isHorizontal() ? o.maxRotation : o.minRotation),
                        f = Math.cos(u),
                        m = Math.sin(u),
                        y = this._resolveTickFontOptions(0).size;
                    return {
                        w: c * f + y * m,
                        h: c * m + y * f
                    }
                }
                _getLabelCapacity(s) {
                    const o = this.options.time,
                        c = o.displayFormats,
                        u = c[o.unit] || c.millisecond,
                        f = this._tickFormatFunction(s, 0, cr(this, [s], this._majorUnit), u),
                        m = this._getLabelSize(f),
                        y = Math.floor(this.isHorizontal() ? this.width / m.w : this.height / m.h) - 1;
                    return y > 0 ? y : 1
                }
                getDataTimestamps() {
                    let o, c, s = this._cache.data || [];
                    if (s.length) return s;
                    const u = this.getMatchingVisibleMetas();
                    if (this._normalized && u.length) return this._cache.data = u[0].controller.getAllParsedValues(this);
                    for (o = 0, c = u.length; o < c; ++o) s = s.concat(u[o].controller.getAllParsedValues(this));
                    return this._cache.data = this.normalize(s)
                }
                getLabelTimestamps() {
                    const s = this._cache.labels || [];
                    let o, c;
                    if (s.length) return s;
                    const u = this.getLabels();
                    for (o = 0, c = u.length; o < c; ++o) s.push(or(this, u[o]));
                    return this._cache.labels = this._normalized ? s : this.normalize(s)
                }
                normalize(s) {
                    return x(s.sort(rr))
                }
            })();

            function Fs(n, a, s) {
                let u, f, m, y, o = 0,
                    c = n.length - 1;
                s ? (a >= n[o].pos && a <= n[c].pos && ({
                    lo: o,
                    hi: c
                } = i(n, "pos", a)), ({
                    pos: u,
                    time: m
                } = n[o]), ({
                    pos: f,
                    time: y
                } = n[c])) : (a >= n[o].time && a <= n[c].time && ({
                    lo: o,
                    hi: c
                } = i(n, "time", a)), ({
                    time: u,
                    pos: m
                } = n[o]), ({
                    time: f,
                    pos: y
                } = n[c]));
                const A = f - u;
                return A ? m + (y - m) * (a - u) / A : m
            }
            const Wc = [Ho, yh, fc, Object.freeze({
                __proto__: null,
                CategoryScale: bc,
                LinearScale: class yc extends zs {
                    static id = "linear";
                    static defaults = {
                        ticks: {
                            callback: ee.formatters.numeric
                        }
                    };
                    determineDataLimits() {
                        const {
                            min: a,
                            max: s
                        } = this.getMinMax(!0);
                        this.min = $t(a) ? a : 0, this.max = $t(s) ? s : 1, this.handleTickRangeOptions()
                    }
                    computeTickLimit() {
                        const a = this.isHorizontal(),
                            s = a ? this.width : this.height,
                            o = Gt(this.options.ticks.minRotation),
                            c = (a ? Math.sin(o) : Math.cos(o)) || .001,
                            u = this._resolveTickFontOptions(0);
                        return Math.ceil(s / Math.min(40, u.lineHeight / c))
                    }
                    getPixelForValue(a) {
                        return null === a ? NaN : this.getPixelForDecimal((a - this._startValue) / this._valueRange)
                    }
                    getValueForPixel(a) {
                        return this._startValue + this.getDecimalForPixel(a) * this._valueRange
                    }
                },
                LogarithmicScale: class Ac extends Fi {
                    static id = "logarithmic";
                    static defaults = {
                        ticks: {
                            callback: ee.formatters.logarithmic,
                            major: {
                                enabled: !0
                            }
                        }
                    };
                    constructor(a) {
                        super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
                    }
                    parse(a, s) {
                        const o = zs.prototype.parse.apply(this, [a, s]);
                        if (0 !== o) return $t(o) && o > 0 ? o : null;
                        this._zero = !0
                    }
                    determineDataLimits() {
                        const {
                            min: a,
                            max: s
                        } = this.getMinMax(!0);
                        this.min = $t(a) ? Math.max(0, a) : null, this.max = $t(s) ? Math.max(0, s) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !$t(this._userMin) && (this.min = a === Xi(this.min, 0) ? Xi(this.min, -1) : Xi(this.min, 0)), this.handleTickRangeOptions()
                    }
                    handleTickRangeOptions() {
                        const {
                            minDefined: a,
                            maxDefined: s
                        } = this.getUserBounds();
                        let o = this.min,
                            c = this.max;
                        const u = m => o = a ? o : m,
                            f = m => c = s ? c : m;
                        o === c && (o <= 0 ? (u(1), f(10)) : (u(Xi(o, -1)), f(Xi(c, 1)))), o <= 0 && u(Xi(c, -1)), c <= 0 && f(Xi(o, 1)), this.min = o, this.max = c
                    }
                    buildTicks() {
                        const a = this.options,
                            o = function kc(n, {
                                min: a,
                                max: s
                            }) {
                                a = Jt(n.min, a);
                                const o = [],
                                    c = ds(a);
                                let u = function wc(n, a) {
                                        let o = ds(a - n);
                                        for (; sr(n, a, o) > 10;) o++;
                                        for (; sr(n, a, o) < 10;) o--;
                                        return Math.min(o, ds(n))
                                    }(a, s),
                                    f = u < 0 ? Math.pow(10, Math.abs(u)) : 1;
                                const m = Math.pow(10, u),
                                    y = c > u ? Math.pow(10, c) : 0,
                                    A = Math.round((a - y) * f) / f,
                                    L = Math.floor((a - y) / m / 10) * m * 10;
                                let O = Math.floor((A - L) / Math.pow(10, u)),
                                    z = Jt(n.min, Math.round((y + L + O * Math.pow(10, u)) * f) / f);
                                for (; z < s;) o.push({
                                    value: z,
                                    major: ir(z),
                                    significand: O
                                }), O >= 10 ? O = O < 15 ? 15 : 20 : O++, O >= 20 && (u++, O = 2, f = u >= 0 ? 1 : f), z = Math.round((y + L + O * Math.pow(10, u)) * f) / f;
                                const B = Jt(n.max, z);
                                return o.push({
                                    value: B,
                                    major: ir(B),
                                    significand: O
                                }), o
                            }({
                                min: this._userMin,
                                max: this._userMax
                            }, this);
                        return "ticks" === a.bounds && gt(o, this, "value"), a.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o
                    }
                    getLabelForValue(a) {
                        return void 0 === a ? "0" : Pt(a, this.chart.options.locale, this.options.ticks.format)
                    }
                    configure() {
                        const a = this.min;
                        super.configure(), this._startValue = et(a), this._valueRange = et(this.max) - et(a)
                    }
                    getPixelForValue(a) {
                        return (void 0 === a || 0 === a) && (a = this.min), null === a || isNaN(a) ? NaN : this.getPixelForDecimal(a === this.min ? 0 : (et(a) - this._startValue) / this._valueRange)
                    }
                    getValueForPixel(a) {
                        const s = this.getDecimalForPixel(a);
                        return Math.pow(10, this._startValue + s * this._valueRange)
                    }
                },
                RadialLinearScale: class Fc extends zs {
                    static id = "radialLinear";
                    static defaults = {
                        display: !0,
                        animate: !0,
                        position: "chartArea",
                        angleLines: {
                            display: !0,
                            lineWidth: 1,
                            borderDash: [],
                            borderDashOffset: 0
                        },
                        grid: {
                            circular: !1
                        },
                        startAngle: 0,
                        ticks: {
                            showLabelBackdrop: !0,
                            callback: ee.formatters.numeric
                        },
                        pointLabels: {
                            backdropColor: void 0,
                            backdropPadding: 2,
                            display: !0,
                            font: {
                                size: 10
                            },
                            callback: a => a,
                            padding: 5,
                            centerPointLabels: !1
                        }
                    };
                    static defaultRoutes = {
                        "angleLines.color": "borderColor",
                        "pointLabels.color": "color",
                        "ticks.color": "color"
                    };
                    static descriptors = {
                        angleLines: {
                            _fallback: "grid"
                        }
                    };
                    constructor(a) {
                        super(a), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
                    }
                    setDimensions() {
                        const a = this._padding = ye(ca(this.options) / 2),
                            s = this.width = this.maxWidth - a.width,
                            o = this.height = this.maxHeight - a.height;
                        this.xCenter = Math.floor(this.left + s / 2 + a.left), this.yCenter = Math.floor(this.top + o / 2 + a.top), this.drawingArea = Math.floor(Math.min(s, o) / 2)
                    }
                    determineDataLimits() {
                        const {
                            min: a,
                            max: s
                        } = this.getMinMax(!1);
                        this.min = $t(a) && !isNaN(a) ? a : 0, this.max = $t(s) && !isNaN(s) ? s : 0, this.handleTickRangeOptions()
                    }
                    computeTickLimit() {
                        return Math.ceil(this.drawingArea / ca(this.options))
                    }
                    generateTickLabels(a) {
                        zs.prototype.generateTickLabels.call(this, a), this._pointLabels = this.getLabels().map((s, o) => {
                            const c = qt(this.options.pointLabels.callback, [s, o], this);
                            return c || 0 === c ? c : ""
                        }).filter((s, o) => this.chart.getDataVisibility(o))
                    }
                    fit() {
                        const a = this.options;
                        a.display && a.pointLabels.display ? function Cc(n) {
                            const a = {
                                    l: n.left + n._padding.left,
                                    r: n.right - n._padding.right,
                                    t: n.top + n._padding.top,
                                    b: n.bottom - n._padding.bottom
                                },
                                s = Object.assign({}, a),
                                o = [],
                                c = [],
                                u = n._pointLabels.length,
                                f = n.options.pointLabels,
                                m = f.centerPointLabels ? jt / u : 0;
                            for (let y = 0; y < u; y++) {
                                const A = f.setContext(n.getPointLabelContext(y));
                                c[y] = A.padding;
                                const L = n.getPointPosition(y, n.drawingArea + c[y], m),
                                    O = de(A.font),
                                    z = Sc(n.ctx, O, n._pointLabels[y]);
                                o[y] = z;
                                const B = Wt(n.getIndexAngle(y) + m),
                                    V = Math.round(Ut(B));
                                Mc(s, a, B, ar(V, L.x, z.w, 0, 180), ar(V, L.y, z.h, 90, 270))
                            }
                            n.setCenterPoint(a.l - s.l, s.r - a.r, a.t - s.t, s.b - a.b), n._pointLabelItems = function _c(n, a, s) {
                                const o = [],
                                    c = n._pointLabels.length,
                                    u = n.options,
                                    {
                                        centerPointLabels: f,
                                        display: m
                                    } = u.pointLabels,
                                    y = {
                                        extra: ca(u) / 2,
                                        additionalAngle: f ? jt / c : 0
                                    };
                                let A;
                                for (let L = 0; L < c; L++) {
                                    y.padding = s[L], y.size = a[L];
                                    const O = Pc(n, L, y);
                                    o.push(O), "auto" === m && (O.visible = Lc(O, A), O.visible && (A = O))
                                }
                                return o
                            }(n, o, c)
                        }(this) : this.setCenterPoint(0, 0, 0, 0)
                    }
                    setCenterPoint(a, s, o, c) {
                        this.xCenter += Math.floor((a - s) / 2), this.yCenter += Math.floor((o - c) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(a, s, o, c))
                    }
                    getIndexAngle(a) {
                        return Wt(a * (W / (this._pointLabels.length || 1)) + Gt(this.options.startAngle || 0))
                    }
                    getDistanceFromCenterForValue(a) {
                        if (zt(a)) return NaN;
                        const s = this.drawingArea / (this.max - this.min);
                        return this.options.reverse ? (this.max - a) * s : (a - this.min) * s
                    }
                    getValueForDistanceFromCenter(a) {
                        if (zt(a)) return NaN;
                        const s = a / (this.drawingArea / (this.max - this.min));
                        return this.options.reverse ? this.max - s : this.min + s
                    }
                    getPointLabelContext(a) {
                        const s = this._pointLabels || [];
                        if (a >= 0 && a < s.length) {
                            const o = s[a];
                            return function Rc(n, a, s) {
                                return wi(n, {
                                    label: s,
                                    index: a,
                                    type: "pointLabel"
                                })
                            }(this.getContext(), a, o)
                        }
                    }
                    getPointPosition(a, s, o = 0) {
                        const c = this.getIndexAngle(a) - Y + o;
                        return {
                            x: Math.cos(c) * s + this.xCenter,
                            y: Math.sin(c) * s + this.yCenter,
                            angle: c
                        }
                    }
                    getPointPositionForValue(a, s) {
                        return this.getPointPosition(a, this.getDistanceFromCenterForValue(s))
                    }
                    getBasePosition(a) {
                        return this.getPointPositionForValue(a || 0, this.getBaseValue())
                    }
                    getPointLabelPosition(a) {
                        const {
                            left: s,
                            top: o,
                            right: c,
                            bottom: u
                        } = this._pointLabelItems[a];
                        return {
                            left: s,
                            top: o,
                            right: c,
                            bottom: u
                        }
                    }
                    drawBackground() {
                        const {
                            backgroundColor: a,
                            grid: {
                                circular: s
                            }
                        } = this.options;
                        if (a) {
                            const o = this.ctx;
                            o.save(), o.beginPath(), nr(this, this.getDistanceFromCenterForValue(this._endValue), s, this._pointLabels.length), o.closePath(), o.fillStyle = a, o.fill(), o.restore()
                        }
                    }
                    drawGrid() {
                        const a = this.ctx,
                            s = this.options,
                            {
                                angleLines: o,
                                grid: c,
                                border: u
                            } = s,
                            f = this._pointLabels.length;
                        let m, y, A;
                        if (s.pointLabels.display && function Ic(n, a) {
                                const {
                                    ctx: s,
                                    options: {
                                        pointLabels: o
                                    }
                                } = n;
                                for (let c = a - 1; c >= 0; c--) {
                                    const u = n._pointLabelItems[c];
                                    if (!u.visible) continue;
                                    const f = o.setContext(n.getPointLabelContext(c));
                                    Dc(s, f, u);
                                    const m = de(f.font),
                                        {
                                            x: y,
                                            y: A,
                                            textAlign: L
                                        } = u;
                                    Oi(s, n._pointLabels[c], y, A + m.lineHeight / 2, m, {
                                        color: f.color,
                                        textAlign: L,
                                        textBaseline: "middle"
                                    })
                                }
                            }(this, f), c.display && this.ticks.forEach((L, O) => {
                                if (0 !== O) {
                                    y = this.getDistanceFromCenterForValue(L.value);
                                    const z = this.getContext(O),
                                        B = c.setContext(z),
                                        V = u.setContext(z);
                                    ! function zc(n, a, s, o, c) {
                                        const u = n.ctx,
                                            f = a.circular,
                                            {
                                                color: m,
                                                lineWidth: y
                                            } = a;
                                        !f && !o || !m || !y || s < 0 || (u.save(), u.strokeStyle = m, u.lineWidth = y, u.setLineDash(c.dash), u.lineDashOffset = c.dashOffset, u.beginPath(), nr(n, s, f, o), u.closePath(), u.stroke(), u.restore())
                                    }(this, B, y, f, V)
                                }
                            }), o.display) {
                            for (a.save(), m = f - 1; m >= 0; m--) {
                                const L = o.setContext(this.getPointLabelContext(m)),
                                    {
                                        color: O,
                                        lineWidth: z
                                    } = L;
                                !z || !O || (a.lineWidth = z, a.strokeStyle = O, a.setLineDash(L.borderDash), a.lineDashOffset = L.borderDashOffset, y = this.getDistanceFromCenterForValue(s.ticks.reverse ? this.min : this.max), A = this.getPointPosition(m, y), a.beginPath(), a.moveTo(this.xCenter, this.yCenter), a.lineTo(A.x, A.y), a.stroke())
                            }
                            a.restore()
                        }
                    }
                    drawBorder() {}
                    drawLabels() {
                        const a = this.ctx,
                            s = this.options,
                            o = s.ticks;
                        if (!o.display) return;
                        const c = this.getIndexAngle(0);
                        let u, f;
                        a.save(), a.translate(this.xCenter, this.yCenter), a.rotate(c), a.textAlign = "center", a.textBaseline = "middle", this.ticks.forEach((m, y) => {
                            if (0 === y && !s.reverse) return;
                            const A = o.setContext(this.getContext(y)),
                                L = de(A.font);
                            if (u = this.getDistanceFromCenterForValue(this.ticks[y].value), A.showLabelBackdrop) {
                                a.font = L.string, f = a.measureText(m.label).width, a.fillStyle = A.backdropColor;
                                const O = ye(A.backdropPadding);
                                a.fillRect(-f / 2 - O.left, -u - L.size / 2 - O.top, f + O.width, L.size + O.height)
                            }
                            Oi(a, m.label, 0, -u, L, {
                                color: A.color,
                                strokeColor: A.textStrokeColor,
                                strokeWidth: A.textStrokeWidth
                            })
                        }), a.restore()
                    }
                    drawTitle() {}
                },
                TimeScale: da,
                TimeSeriesScale: class Hc extends da {
                    static id = "timeseries";
                    static defaults = da.defaults;
                    constructor(a) {
                        super(a), this._table = [], this._minPos = void 0, this._tableRange = void 0
                    }
                    initOffsets() {
                        const a = this._getTimestampsForTable(),
                            s = this._table = this.buildLookupTable(a);
                        this._minPos = Fs(s, this.min), this._tableRange = Fs(s, this.max) - this._minPos, super.initOffsets(a)
                    }
                    buildLookupTable(a) {
                        const {
                            min: s,
                            max: o
                        } = this, c = [], u = [];
                        let f, m, y, A, L;
                        for (f = 0, m = a.length; f < m; ++f) A = a[f], A >= s && A <= o && c.push(A);
                        if (c.length < 2) return [{
                            time: s,
                            pos: 0
                        }, {
                            time: o,
                            pos: 1
                        }];
                        for (f = 0, m = c.length; f < m; ++f) L = c[f + 1], y = c[f - 1], A = c[f], Math.round((L + y) / 2) !== A && u.push({
                            time: A,
                            pos: f / (m - 1)
                        });
                        return u
                    }
                    _generate() {
                        const a = this.min,
                            s = this.max;
                        let o = super.getDataTimestamps();
                        return (!o.includes(a) || !o.length) && o.splice(0, 0, a), (!o.includes(s) || 1 === o.length) && o.push(s), o.sort((c, u) => c - u)
                    }
                    _getTimestampsForTable() {
                        let a = this._cache.all || [];
                        if (a.length) return a;
                        const s = this.getDataTimestamps(),
                            o = this.getLabelTimestamps();
                        return a = s.length && o.length ? this.normalize(s.concat(o)) : s.length ? s : o, a = this._cache.all = a, a
                    }
                    getDecimalForValue(a) {
                        return (Fs(this._table, a) - this._minPos) / this._tableRange
                    }
                    getValueForPixel(a) {
                        const s = this._offsets,
                            o = this.getDecimalForPixel(a) / s.factor - s.end;
                        return Fs(this._table, o * this._tableRange + this._minPos, !0)
                    }
                }
            })];
            var Vc = Nt(3997),
                Gc = Nt(286),
                jc = Nt(6041),
                dr = Nt(8418);
            const ua = function Uc(n, a, s) {
                    (void 0 !== s && !(0, dr.Z)(n[a], s) || void 0 === s && !(a in n)) && (0, jc.Z)(n, a, s)
                },
                qc = function Zc(n) {
                    return function(a, s, o) {
                        for (var c = -1, u = Object(a), f = o(a), m = f.length; m--;) {
                            var y = f[n ? m : ++c];
                            if (!1 === s(u[y], y, u)) break
                        }
                        return a
                    }
                }();
            var Kc = Nt(4203),
                Qc = Nt(3734),
                Jc = Nt(2307),
                td = Nt(7324),
                ur = Nt(5727),
                gr = Nt(9977),
                fr = Nt(6247),
                ed = Nt(1196);
            var ad = Nt(9354),
                nd = Nt(4842),
                ga = Nt(5829),
                rd = Nt(5511),
                od = Nt(7227);
            const fa = function ld(n, a) {
                if (("constructor" !== a || "function" != typeof n[a]) && "__proto__" != a) return n[a]
            };
            var hd = Nt(6299),
                pr = Nt(2851);
            const gd = function ud(n, a, s, o, c, u, f) {
                    var m = fa(n, s),
                        y = fa(a, s),
                        A = f.get(y);
                    if (A) ua(n, s, A);
                    else {
                        var L = u ? u(m, y, s + "", n, a, f) : void 0,
                            O = void 0 === L;
                        if (O) {
                            var z = (0, gr.Z)(y),
                                B = !z && (0, ad.Z)(y),
                                V = !z && !B && (0, od.Z)(y);
                            L = y, z || B || V ? (0, gr.Z)(m) ? L = m : function id(n) {
                                return (0, ed.Z)(n) && (0, fr.Z)(n)
                            }(m) ? L = (0, Jc.Z)(m) : B ? (O = !1, L = (0, Kc.Z)(y, !0)) : V ? (O = !1, L = (0, Qc.Z)(y, !0)) : L = [] : (0, rd.Z)(y) || (0, ur.Z)(y) ? (L = m, (0, ur.Z)(m) ? L = function cd(n) {
                                return (0, hd.Z)(n, (0, pr.Z)(n))
                            }(m) : (!(0, ga.Z)(m) || (0, nd.Z)(m)) && (L = (0, td.Z)(y))) : O = !1
                        }
                        O && (f.set(y, L), c(L, y, o, u, f), f.delete(y)), ua(n, s, L)
                    }
                },
                fd = function xr(n, a, s, o, c) {
                    n !== a && qc(a, function(u, f) {
                        if (c || (c = new Gc.Z), (0, ga.Z)(u)) gd(n, a, f, s, xr, o, c);
                        else {
                            var m = o ? o(fa(n, f), u, f + "", n, a, c) : void 0;
                            void 0 === m && (m = u), ua(n, f, m)
                        }
                    }, pr.Z)
                },
                mr = function pd(n) {
                    return n
                };
            var br = Math.max;
            const wd = function yd(n) {
                return function() {
                    return n
                }
            };
            var vr = Nt(5753),
                Md = Date.now;
            const _d = function Pd(n) {
                    var a = 0,
                        s = 0;
                    return function() {
                        var o = Md(),
                            c = 16 - (o - s);
                        if (s = o, c > 0) {
                            if (++a >= 800) return arguments[0]
                        } else a = 0;
                        return n.apply(void 0, arguments)
                    }
                }(vr.Z ? function(n, a) {
                    return (0, vr.Z)(n, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: wd(a),
                        writable: !0
                    })
                } : mr),
                Od = function Td(n, a) {
                    return _d(function bd(n, a, s) {
                        return a = br(void 0 === a ? n.length - 1 : a, 0),
                            function() {
                                for (var o = arguments, c = -1, u = br(o.length - a, 0), f = Array(u); ++c < u;) f[c] = o[a + c];
                                c = -1;
                                for (var m = Array(a + 1); ++c < a;) m[c] = o[c];
                                return m[a] = s(f),
                                    function xd(n, a, s) {
                                        switch (s.length) {
                                            case 0:
                                                return n.call(a);
                                            case 1:
                                                return n.call(a, s[0]);
                                            case 2:
                                                return n.call(a, s[0], s[1]);
                                            case 3:
                                                return n.call(a, s[0], s[1], s[2])
                                        }
                                        return n.apply(a, s)
                                    }(n, this, m)
                            }
                    }(n, a, mr), n + "")
                };
            var Ed = Nt(9229);
            const yr = function zd(n) {
                return Od(function(a, s) {
                    var o = -1,
                        c = s.length,
                        u = c > 1 ? s[c - 1] : void 0,
                        f = c > 2 ? s[2] : void 0;
                    for (u = n.length > 3 && "function" == typeof u ? (c--, u) : void 0, f && function Dd(n, a, s) {
                            if (!(0, ga.Z)(s)) return !1;
                            var o = typeof a;
                            return !!("number" == o ? (0, fr.Z)(s) && (0, Ed.Z)(a, s.length) : "string" == o && a in s) && (0, dr.Z)(s[a], n)
                        }(s[0], s[1], f) && (u = c < 3 ? void 0 : u, c = 1), a = Object(a); ++o < c;) {
                        var m = s[o];
                        m && n(a, m, o, u)
                    }
                    return a
                })
            }(function(n, a, s) {
                fd(n, a, s)
            });
            var Fd = Nt(5619);
            let Xd = (() => {
                    class n {
                        constructor() {
                            this.colorschemesOptions = new Fd.X(void 0)
                        }
                        setColorschemesOptions(s) {
                            this.pColorschemesOptions = s, this.colorschemesOptions.next(s)
                        }
                        getColorschemesOptions() {
                            return this.pColorschemesOptions
                        }
                    }
                    return n.\u0275fac = function(s) {
                        return new(s || n)
                    }, n.\u0275prov = _t.Yz7({
                        token: n,
                        factory: n.\u0275fac,
                        providedIn: "root"
                    }), n
                })(),
                Nd = (() => {
                    class n {
                        constructor(s, o, c) {
                            this.zone = o, this.themeService = c, this.type = "bar", this.plugins = [], this.chartClick = new _t.vpe, this.chartHover = new _t.vpe, this.subs = [], this.themeOverrides = {}, this.ctx = s.nativeElement.getContext("2d"), this.subs.push(this.themeService.colorschemesOptions.pipe((0, Vc.x)()).subscribe(u => this.themeChanged(u)))
                        }
                        ngOnChanges(s) {
                            const o = ["type"],
                                c = Object.getOwnPropertyNames(s);
                            if (c.some(u => o.includes(u)) || c.every(u => s[u].isFirstChange())) this.render();
                            else {
                                const u = this.getChartConfiguration();
                                this.chart && (Object.assign(this.chart.config.data, u.data), this.chart.config.plugins && Object.assign(this.chart.config.plugins, u.plugins), this.chart.config.options && Object.assign(this.chart.config.options, u.options)), this.update()
                            }
                        }
                        ngOnDestroy() {
                            this.chart && (this.chart.destroy(), this.chart = void 0), this.subs.forEach(s => s.unsubscribe())
                        }
                        render() {
                            return this.chart && this.chart.destroy(), this.zone.runOutsideAngular(() => this.chart = new Ts(this.ctx, this.getChartConfiguration()))
                        }
                        update(s) {
                            this.chart && this.zone.runOutsideAngular(() => this.chart ? .update(s))
                        }
                        hideDataset(s, o) {
                            this.chart && (this.chart.getDatasetMeta(s).hidden = o, this.update())
                        }
                        isDatasetHidden(s) {
                            return this.chart ? .getDatasetMeta(s) ? .hidden
                        }
                        toBase64Image() {
                            return this.chart ? .toBase64Image()
                        }
                        themeChanged(s) {
                            this.themeOverrides = s, this.chart && (this.chart.config.options && Object.assign(this.chart.config.options, this.getChartOptions()), this.update())
                        }
                        getChartOptions() {
                            return yr({
                                onHover: (s, o) => {
                                    !this.chartHover.observed && !this.chartHover.observers ? .length || this.zone.run(() => this.chartHover.emit({
                                        event: s,
                                        active: o
                                    }))
                                },
                                onClick: (s, o) => {
                                    !this.chartClick.observed && !this.chartClick.observers ? .length || this.zone.run(() => this.chartClick.emit({
                                        event: s,
                                        active: o
                                    }))
                                }
                            }, this.themeOverrides, this.options, {
                                plugins: {
                                    legend: {
                                        display: this.legend
                                    }
                                }
                            })
                        }
                        getChartConfiguration() {
                            return {
                                type: this.type,
                                data: this.getChartData(),
                                options: this.getChartOptions(),
                                plugins: this.plugins
                            }
                        }
                        getChartData() {
                            return this.data ? this.data : {
                                labels: this.labels || [],
                                datasets: this.datasets || []
                            }
                        }
                    }
                    return n.\u0275fac = function(s) {
                        return new(s || n)(_t.Y36(_t.SBq), _t.Y36(_t.R0b), _t.Y36(Xd))
                    }, n.\u0275dir = _t.lG2({
                        type: n,
                        selectors: [
                            ["canvas", "baseChart", ""]
                        ],
                        inputs: {
                            type: "type",
                            legend: "legend",
                            data: "data",
                            options: "options",
                            plugins: "plugins",
                            labels: "labels",
                            datasets: "datasets"
                        },
                        outputs: {
                            chartClick: "chartClick",
                            chartHover: "chartHover"
                        },
                        exportAs: ["base-chart"],
                        features: [_t.TTD]
                    }), n
                })();
            const Bd = [
                    [255, 99, 132],
                    [54, 162, 235],
                    [255, 206, 86],
                    [231, 233, 237],
                    [75, 192, 192],
                    [151, 187, 205],
                    [220, 220, 220],
                    [247, 70, 74],
                    [70, 191, 189],
                    [253, 180, 92],
                    [148, 159, 177],
                    [77, 83, 96]
                ],
                Hd = {
                    plugins: {
                        colors: {
                            enabled: !1
                        }
                    },
                    datasets: {
                        line: {
                            backgroundColor: n => Si(Ci(n.datasetIndex), .4),
                            borderColor: n => Si(Ci(n.datasetIndex), 1),
                            pointBackgroundColor: n => Si(Ci(n.datasetIndex), 1),
                            pointBorderColor: "#fff"
                        },
                        bar: {
                            backgroundColor: n => Si(Ci(n.datasetIndex), .6),
                            borderColor: n => Si(Ci(n.datasetIndex), 1)
                        },
                        get radar() {
                            return this.line
                        },
                        doughnut: {
                            backgroundColor: n => Si(Ci(n.dataIndex), .6),
                            borderColor: "#fff"
                        },
                        get pie() {
                            return this.doughnut
                        },
                        polarArea: {
                            backgroundColor: n => Si(Ci(n.dataIndex), .6),
                            borderColor: n => Si(Ci(n.dataIndex), 1)
                        },
                        get bubble() {
                            return this.doughnut
                        },
                        get scatter() {
                            return this.doughnut
                        },
                        get area() {
                            return this.polarArea
                        }
                    }
                };

            function Si(n, a) {
                return "rgba(" + n.concat(a).join(",") + ")"
            }

            function pa(n, a) {
                return Math.floor(Math.random() * (a - n + 1)) + n
            }

            function Ci(n = 0) {
                return Bd[n] || function Yd() {
                    return [pa(0, 255), pa(0, 255), pa(0, 255)]
                }()
            }
            let wr = (() => {
                class n {
                    constructor() {
                        this.generateColors = !0
                    }
                }
                return n.\u0275fac = function(s) {
                    return new(s || n)
                }, n.\u0275prov = _t.Yz7({
                    token: n,
                    factory: n.\u0275fac,
                    providedIn: "root"
                }), n
            })();
            Ts.register(...Wc);
            let Wd = (() => {
                class n {
                    constructor(s) {
                        s ? .plugins && Ts.register(...s ? .plugins);
                        const o = yr(s ? .generateColors ? Hd : {}, s ? .defaults || {});
                        Xt.set(o)
                    }
                    static forRoot(s) {
                        return {
                            ngModule: n,
                            providers: [{
                                provide: wr,
                                useValue: s
                            }]
                        }
                    }
                }
                return n.\u0275fac = function(s) {
                    return new(s || n)(_t.LFG(wr, 8))
                }, n.\u0275mod = _t.oAB({
                    type: n
                }), n.\u0275inj = _t.cJS({}), n
            })()
        }
    }
]);